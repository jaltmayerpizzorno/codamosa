

---- 2024-03-18 06:05:05.002700
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:07.739748
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:11.301140
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:15.092068
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:18.443071
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:21.445587
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:24.941063
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:27.569563
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:30.518377
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:05:35.067679
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Base data provider.\"\"\"\n\nimport collections.abc\nimport contextlib\nimport functools\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Generator, Mapping\n\nfrom mimesis import locales\nfrom mimesis.exceptions import NonEnumerableError, UnsupportedLocale\nfrom mimesis.random import Random, get_random_item, random\nfrom mimesis.typing import JSON, Seed\n\n__all__ = ['BaseDataProvider', 'BaseProvider']\n\n\nclass BaseProvider(object):\n    \"\"\"This is a base class for all providers.\"\"\"\n\n    def __init__(self, seed: Seed = None) -> None:\n        \"\"\"Initialize attributes.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        self.seed = seed\n        self.random = random\n\n        if seed is not None:\n            self.reseed(seed)\n\n    def reseed(self, seed: Seed = None) -> None:\n        \"\"\"Reseed the internal random generator.\n\n        In case we use the default seed, we need to create a per instance\n        random generator, in this case two providers with the same seed\n        will always return the same values.\n\n        :param seed: Seed for random.\n            When set to `None` the current system time is used.\n        \"\"\"\n        if self.random is random:\n            self.random = Random()\n\n        self.seed = seed\n        self.random.seed(self.seed)\n\n    def _validate_enum(self, item: Any, enum: Any) -> Any:\n        \"\"\"Validate enum parameter of method in subclasses of BaseProvider.\n\n        :param item: Item of enum object.\n        :param enum: Enum object.\n        :return: Value of item.\n        :raises NonEnumerableError: if ``item`` not in ``enum``.\n        \"\"\"\n        if item is None:\n            result = get_random_item(enum, self.random)\n        elif item and isinstance(item, enum):\n            result = item\n        else:\n            raise NonEnumerableError(enum)\n\n        return result.value\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        return self.__class__.__name__\n\n\nclass BaseDataProvider(BaseProvider):\n    \"\"\"This is a base class for all data providers.\"\"\"\n\n    def __init__(self, locale: str = locales.DEFAULT_LOCALE,\n                 seed: Seed = None) -> None:\n        \"\"\"Initialize attributes for data providers.\n\n        :param locale: Current locale.\n        :param seed: Seed to all the random functions.\n        \"\"\"\n        super().__init__(seed=seed)\n        self._data: JSON = {}\n        self._datafile = ''\n        self._setup_locale(locale)\n        self._data_dir = Path(__file__).parent.parent.joinpath('data')\n\n    def _setup_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Set up locale after pre-check.\n\n        :param str locale: Locale\n        :raises UnsupportedLocale: When locale not supported.\n        :return: Nothing.\n        \"\"\"\n        if not locale:\n            locale = locales.DEFAULT_LOCALE\n\n        locale = locale.lower()\n        if locale not in locales.SUPPORTED_LOCALES:\n            raise UnsupportedLocale(locale)\n\n        self.locale = locale\n\n    def _update_dict(self, initial: JSON, other: Mapping) -> JSON:\n        \"\"\"Recursively update a dictionary.\n\n        :param initial: Dict to update.\n        :param other: Dict to update from.\n        :return: Updated dict.\n        \"\"\"\n        for key, value in other.items():\n            if isinstance(value, collections.abc.Mapping):\n                r = self._update_dict(initial.get(key, {}), value)\n                initial[key] = r\n            else:\n                initial[key] = other[key]\n        return initial\n\n    @functools.lru_cache(maxsize=None)\n    def _pull(self, datafile: str = '') -> None:\n        \"\"\"Pull the content from the JSON and memorize one.\n\n        Opens JSON file ``file`` in the folder ``data/locale``\n        and get content from the file and memorize ones using lru_cache.\n\n        :param datafile: The name of file.\n        :return: The content of the file.\n        :raises UnsupportedLocale: Raises if locale is unsupported.\n        \"\"\"\n        locale = self.locale\n        data_dir = self._data_dir\n\n        if not datafile:\n            datafile = self._datafile\n\n        def get_data(locale_name: str) -> JSON:\n            \"\"\"Pull JSON data from file.\n\n            :param locale_name: Locale name.\n            :return: Content of JSON file as dict.\n            \"\"\"\n            file_path = Path(data_dir).joinpath(locale_name, datafile)\n            with open(file_path, 'r', encoding='utf8') as f:\n                return json.load(f)\n\n        separator = locales.LOCALE_SEPARATOR\n\n        master_locale = locale.split(separator).pop(0)\n        data = get_data(master_locale)\n\n        if separator in locale:\n            data = self._update_dict(data, get_data(locale))\n\n        self._data = data\n\n    def get_current_locale(self) -> str:\n        \"\"\"Get current locale.\n\n        If locale is not defined then this method will always return ``en``,\n        because ``en`` is default locale for all providers, excluding builtins.\n\n        :return: Current locale.\n        \"\"\"\n        return self.locale\n\n    def _override_locale(self, locale: str = locales.DEFAULT_LOCALE) -> None:\n        \"\"\"Overrides current locale with passed and pull data for new locale.\n\n        :param locale: Locale\n        :return: Nothing.\n        \"\"\"\n        self.locale = locale\n        self._pull.cache_clear()\n        self._pull()\n\n    @contextlib.contextmanager\n    def override_locale(self, locale: str = locales.EN,\n                        ) -> Generator['BaseDataProvider', None, None]:\n        \"\"\"Context manager which allows overriding current locale.\n\n        Temporarily overrides current locale for\n        locale-dependent providers.\n\n        :param locale: Locale.\n        :return: Provider with overridden locale.\n        \"\"\"\n        try:\n            origin_locale = self.locale\n            self._override_locale(locale)\n            try:\n                yield self\n            finally:\n                self._override_locale(origin_locale)\n        except AttributeError:\n            raise ValueError('\u00ab{}\u00bb has not locale dependent'.format(\n                self.__class__.__name__))\n\n    def __str__(self) -> str:\n        \"\"\"Human-readable representation of locale.\"\"\"\n        locale = getattr(self, 'locale', locales.DEFAULT_LOCALE)\n        return '{} <{}>'.format(self.__class__.__name__, locale)\n\n# Unit test for method override_locale of class BaseDataProvider\ndef test_BaseDataProvider_override_locale():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}