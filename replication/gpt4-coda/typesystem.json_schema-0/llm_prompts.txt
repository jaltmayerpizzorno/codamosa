

---- 2024-03-18 08:46:04.993318
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:14.531581
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n# Unit test for function enum_from_json_schema\ndef test_enum_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:20.802160
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:26.258506
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:27.224088
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:28.367957
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n# Unit test for function enum_from_json_schema\ndef test_enum_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:36.201741
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:37.405753
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n# Unit test for function get_valid_types\ndef test_get_valid_types():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:46.887547
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n# Unit test for function type_from_json_schema\ndef test_type_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:46:55.404171
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:18.001603
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:18.649038
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:30.602924
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n# Unit test for function const_from_json_schema\ndef test_const_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:36.786249
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:37.583964
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n# Unit test for function enum_from_json_schema\ndef test_enum_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:42.691903
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n# Unit test for function type_from_json_schema\ndef test_type_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:49.164346
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n# Unit test for function const_from_json_schema\ndef test_const_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:47:59.170336
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n# Unit test for function const_from_json_schema\ndef test_const_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:05.545229
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n# Unit test for function one_of_from_json_schema\ndef test_one_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:09.696552
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:37.494439
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:43.408227
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n# Unit test for function type_from_json_schema\ndef test_type_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:49.428742
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:55.203621
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:56.370300
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n# Unit test for function type_from_json_schema\ndef test_type_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:04.104329
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n# Unit test for function type_from_json_schema\ndef test_type_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:10.694287
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:16.763956
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:23.017110
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n# Unit test for function const_from_json_schema\ndef test_const_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:32.034218
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:21.683987
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:22.310304
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:27.617405
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:34.806637
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:43.255568
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:47.722130
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:48.944355
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:57.754007
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:51:02.397754
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:51:11.015353
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:20.636293
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:25.430213
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:33.829725
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:41.311729
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:51.007253
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:00.394380
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:05.786384
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:07.340030
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:17.776734
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:23.394937
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:02.406562
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:09.145339
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:18.998516
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n# Unit test for function from_json_schema\ndef test_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:26.347123
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:31.136349
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:36.109132
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n# Unit test for function from_json_schema\ndef test_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:45.408971
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:50.583195
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n# Unit test for function const_from_json_schema\ndef test_const_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:58.581196
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n# Unit test for function const_from_json_schema\ndef test_const_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:55:05.346953
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}