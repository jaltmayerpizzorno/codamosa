# Automatically generated by Pynguin.
import ansible.plugins.filter.mathstuff as module_0

def test_case_0():
    try:
        float_0 = 0.2
        str_0 = 'pA&~SDkLOB04#t'
        bool_0 = False
        list_0 = []
        var_0 = module_0.unique(bool_0, list_0)
        dict_0 = {str_0: float_0, str_0: str_0}
        set_0 = {float_0}
        var_1 = module_0.min(dict_0, set_0)
        filter_module_0 = module_0.FilterModule()
        set_1 = {float_0, float_0, float_0, float_0}
        var_2 = filter_module_0.filters()
        list_1 = [set_1]
        list_2 = [float_0, list_1]
        var_3 = module_0.unique(float_0, list_1, list_2)
        var_4 = module_0.logarithm(set_0)
    except BaseException:
        pass

def test_case_1():
    try:
        filter_module_0 = module_0.FilterModule()
        var_0 = module_0.unique(filter_module_0, filter_module_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = '\tB25RO\x0c7@;#Mj]s'
        tuple_0 = ()
        bool_0 = True
        var_0 = module_0.intersect(str_0, tuple_0, bool_0)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = '1"6Go\x0c5")'
        str_1 = '8?tf3OxM,/qt$Rs\x0bE'
        list_0 = [str_0, str_0, str_0, str_1]
        bytes_0 = b''
        var_0 = module_0.difference(str_0, list_0, bytes_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = ';'
        tuple_0 = (str_0,)
        str_1 = '\n        Find bystem executable in PATH.\n\n        :param arg: The executable to find.\n        :param required: if executable is not found and required is ``True``, fail_json\n        :param opt_dirs: optional list of directories to search in addition to ``PATH``\n        :returns: if found return full path; otherwise return None\n        '
        var_0 = module_0.difference(str_0, tuple_0, str_1)
        dict_0 = {}
        var_1 = module_0.intersect(dict_0, dict_0, dict_0)
        bytes_0 = b'\x97\xea\x81\xa1\xec?>\xfd\xe8\xad\x9c\xe1\xedv{'
        float_0 = 2.718281828459045
        list_0 = [dict_0, float_0]
        str_2 = 'p\\5nM~i'
        dict_1 = {str_0: float_0, str_2: float_0}
        str_3 = 'could not cleanup %s: %s'
        var_2 = module_0.union(list_0, str_3, bytes_0)
        float_1 = 2.718281828459045
        var_3 = module_0.rekey_on_member(dict_1, float_1)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = 'y\rvCI!q6Iz^q('
        bytes_0 = b'\x0e'
        set_0 = {str_0, bytes_0}
        list_0 = [set_0, str_0, bytes_0]
        str_1 = 'deprecate requires a string not a %s'
        tuple_0 = (list_0, str_1)
        var_0 = module_0.union(tuple_0, set_0, tuple_0)
    except BaseException:
        pass

def test_case_6():
    try:
        bytes_0 = None
        list_0 = None
        var_0 = module_0.min(bytes_0, list_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = 'ee7k\nBU}uafDFFG&%cN'
        var_0 = module_0.logarithm(str_0)
    except BaseException:
        pass

def test_case_8():
    try:
        filter_module_0 = module_0.FilterModule()
        bytes_0 = b'\x8c\xdb\x0bq\x01\xca\xcaa4F\x9d\xf40\xe4'
        str_0 = ']Lo#hz=;;'
        var_0 = module_0.power(bytes_0, str_0)
    except BaseException:
        pass

def test_case_9():
    try:
        dict_0 = None
        var_0 = module_0.inversepower(dict_0)
    except BaseException:
        pass

def test_case_10():
    try:
        tuple_0 = None
        str_0 = "Incorrect value for 'Required', a boolean is needed: %s"
        list_0 = [tuple_0, str_0, str_0]
        var_0 = module_0.human_readable(tuple_0, str_0, list_0)
    except BaseException:
        pass

def test_case_11():
    try:
        filter_module_0 = module_0.FilterModule()
        var_0 = module_0.human_readable(filter_module_0)
    except BaseException:
        pass

def test_case_12():
    try:
        filter_module_0 = None
        var_0 = module_0.human_to_bytes(filter_module_0)
    except BaseException:
        pass

def test_case_13():
    try:
        int_0 = 13
        filter_module_0 = module_0.FilterModule()
        list_0 = [filter_module_0, int_0]
        var_0 = module_0.rekey_on_member(int_0, list_0)
    except BaseException:
        pass

def test_case_14():
    try:
        int_0 = 13
        filter_module_0 = module_0.FilterModule()
        list_0 = [filter_module_0, int_0]
        var_0 = filter_module_0.filters()
        int_1 = None
        tuple_0 = (int_1,)
        var_1 = module_0.power(tuple_0, list_0)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = 'v4x'
        bool_0 = True
        list_0 = []
        var_0 = module_0.symmetric_difference(str_0, bool_0, list_0)
    except BaseException:
        pass

def test_case_16():
    try:
        tuple_0 = ()
        dict_0 = {tuple_0: tuple_0, tuple_0: tuple_0}
        var_0 = module_0.difference(dict_0, tuple_0, dict_0)
        filter_module_0 = module_0.FilterModule()
        float_0 = 483.177209
        filter_module_1 = module_0.FilterModule()
        str_0 = 'm!4N4'
        tuple_1 = (float_0, filter_module_0, filter_module_1, str_0)
        var_1 = module_0.logarithm(tuple_1)
    except BaseException:
        pass

def test_case_17():
    try:
        bytes_0 = None
        set_0 = {bytes_0, bytes_0, bytes_0}
        list_0 = [bytes_0]
        list_1 = [set_0, bytes_0, bytes_0]
        var_0 = module_0.difference(set_0, list_0, list_1)
        int_0 = -85
        filter_module_0 = module_0.FilterModule()
        var_1 = module_0.logarithm(int_0)
    except BaseException:
        pass

def test_case_18():
    try:
        str_0 = None
        float_0 = -5348.99
        dict_0 = {}
        filter_module_0 = module_0.FilterModule(**dict_0)
        var_0 = filter_module_0.filters()
        bytes_0 = b'\xc91@G\x91I\xdaXi\x80a'
        str_1 = '# The encrypted version of the string #%d from %s.)\n'
        str_2 = 's{Em'
        str_3 = 'j%1~dN7%\rijE3sX2'
        tuple_0 = ()
        dict_1 = {str_1: str_1, str_2: str_0, str_3: tuple_0}
        var_1 = module_0.union(float_0, bytes_0, dict_1)
    except BaseException:
        pass

def test_case_19():
    try:
        int_0 = -85
        var_0 = module_0.logarithm(int_0)
    except BaseException:
        pass

def test_case_20():
    try:
        filter_module_0 = module_0.FilterModule()
        bool_0 = False
        list_0 = [filter_module_0, filter_module_0, bool_0]
        var_0 = module_0.unique(filter_module_0, bool_0, list_0, filter_module_0)
    except BaseException:
        pass

def test_case_21():
    try:
        filter_module_0 = module_0.FilterModule()
        bool_0 = False
        list_0 = [filter_module_0, filter_module_0, bool_0]
        int_0 = 3323
        var_0 = module_0.rekey_on_member(list_0, int_0)
    except BaseException:
        pass

def test_case_22():
    try:
        bytes_0 = b'\x97\x1a\x81\xa1?>\xfd\xe8\xad\xe1\xedv'
        float_0 = 2.718281828459045
        var_0 = module_0.rekey_on_member(bytes_0, float_0)
    except BaseException:
        pass

def test_case_23():
    try:
        float_0 = 0.39929673430481616
        str_0 = 'pA&~SDkLOB04#t'
        dict_0 = {str_0: float_0, str_0: str_0}
        set_0 = {float_0}
        var_0 = module_0.min(dict_0, set_0)
        filter_module_0 = module_0.FilterModule()
        set_1 = set()
        list_0 = [set_1]
        str_1 = ',nSM/njIH\x0b-\t'
        var_1 = module_0.max(list_0, str_1)
        list_1 = [float_0, list_0]
        var_2 = module_0.unique(float_0, list_0, list_1)
        str_2 = '.IF5}yV3Xj(lO19'
        var_3 = module_0.logarithm(float_0)
        var_4 = module_0.symmetric_difference(set_0, dict_0, str_2)
    except BaseException:
        pass

def test_case_24():
    try:
        str_0 = ';'
        tuple_0 = (str_0,)
        str_1 = '\n        Find system executable in PATH.\n\n        :param arg: The executable to find.\n        :param required: if executable is not found and required is ``True``, ]ail_json\n       :parxm opt_dirs: optional list of directories to search in addition to ``PATH``\n        :returns: if found return full 6ath; otherwise return None\n        '
        var_0 = module_0.difference(str_0, tuple_0, str_1)
        dict_0 = {str_0: str_1}
        var_1 = module_0.intersect(dict_0, dict_0, dict_0)
        float_0 = 2.718281828459045
        str_2 = 'p\\5nM~i'
        dict_1 = {str_0: float_0, str_2: float_0}
        float_1 = 2.718281828459045
        var_2 = module_0.rekey_on_member(dict_1, float_1)
    except BaseException:
        pass

def test_case_25():
    try:
        float_0 = 0.2
        filter_module_0 = module_0.FilterModule()
        str_0 = '8OP6/%'
        str_1 = '{>7^c\x0bWA 0U.bCV'
        dict_0 = {str_0: filter_module_0, str_1: float_0, str_1: filter_module_0}
        dict_1 = {}
        bool_0 = False
        var_0 = filter_module_0.filters()
        var_1 = module_0.rekey_on_member(dict_0, dict_1, bool_0)
    except BaseException:
        pass

def test_case_26():
    try:
        str_0 = 'mH\n\x0b?.'
        filter_module_0 = module_0.FilterModule()
        var_0 = module_0.inversepower(str_0, filter_module_0)
    except BaseException:
        pass

def test_case_27():
    try:
        float_0 = 0.2
        str_0 = 'pA&~SDkLOB04#t'
        dict_0 = {str_0: float_0, str_0: str_0}
        set_0 = {float_0}
        var_0 = module_0.min(dict_0, set_0)
        filter_module_0 = module_0.FilterModule()
        list_0 = [set_0, var_0]
        var_1 = module_0.max(list_0, str_0)
        list_1 = [float_0, list_0]
        var_2 = module_0.unique(float_0, list_0, list_1)
        var_3 = module_0.logarithm(float_0)
        str_1 = ''
        var_4 = module_0.symmetric_difference(set_0, list_0, list_1)
        bytes_0 = b'\xabn'
        var_5 = module_0.max(str_1, bytes_0)
        var_6 = filter_module_0.filters()
        str_2 = '-&V-deph'
        var_7 = module_0.difference(float_0, str_2, dict_0)
        dict_1 = {str_2: dict_0}
        var_8 = module_0.rekey_on_member(dict_1, dict_0)
    except BaseException:
        pass

def test_case_28():
    try:
        float_0 = 0.2
        str_0 = 'pA&~SDkLOB04#t'
        dict_0 = {str_0: float_0, str_0: str_0}
        set_0 = {float_0}
        var_0 = module_0.min(dict_0, set_0)
        list_0 = [set_0, var_0]
        var_1 = module_0.max(list_0, str_0)
        list_1 = [float_0, list_0]
        var_2 = module_0.unique(float_0, list_0, list_1)
        var_3 = module_0.logarithm(float_0)
        str_1 = ''
        bytes_0 = b'\xabn'
        var_4 = module_0.max(str_1, bytes_0)
        str_2 = 'np_fact_cache'
        str_3 = '--depth'
        var_5 = module_0.difference(float_0, str_3, dict_0)
        dict_1 = {str_2: dict_0}
        var_6 = module_0.rekey_on_member(dict_1, dict_0)
    except BaseException:
        pass

def test_case_29():
    try:
        str_0 = ';'
        tuple_0 = (str_0,)
        str_1 = '\n        Find bystem executable in PATH.\n\n        :param arg: The executable to find.\n        :param required: if executable is not found and required is ``True``, fail_json\n        :param opt_dirs: optional list of directories to search in addition to ``PATH``\n        :returns: if found return full path; otherwise return None\n        '
        var_0 = module_0.difference(str_0, tuple_0, str_1)
        bool_0 = False
        float_0 = -660.38611
        var_1 = module_0.power(bool_0, float_0)
    except BaseException:
        pass

def test_case_30():
    try:
        str_0 = 'J?|O4'
        dict_0 = {str_0: str_0}
        bytes_0 = b'\xebk%\xf17\xc4\x00\xb6\xa3'
        int_0 = -1120
        var_0 = module_0.unique(dict_0, bytes_0, int_0, str_0)
    except BaseException:
        pass

def test_case_31():
    try:
        float_0 = 26.467054585287176
        str_0 = 'TI \x0bPl'
        dict_0 = {str_0: float_0, str_0: str_0}
        filter_module_0 = module_0.FilterModule()
        var_0 = module_0.logarithm(float_0)
        str_1 = 'np_fact_cache'
        dict_1 = {str_1: dict_0}
        var_1 = module_0.rekey_on_member(dict_1, dict_0)
    except BaseException:
        pass

def test_case_32():
    try:
        bool_0 = True
        bytes_0 = b'\xc9\xb1\x90\xd9\xdc\xec\x127\x86o\xd5\x96h\x04m\xb9@\x99\x19'
        var_0 = module_0.max(bool_0, bytes_0)
        str_0 = "k'sx#^<IX'b%"
        list_0 = []
        dict_0 = {str_0: bytes_0, var_0: var_0, str_0: list_0}
        filter_module_0 = module_0.FilterModule()
        dict_1 = {str_0: dict_0}
        tuple_0 = ()
        var_1 = module_0.rekey_on_member(dict_1, tuple_0)
    except BaseException:
        pass

def test_case_33():
    try:
        float_0 = 0.2
        str_0 = 'pA&~SDkLOB04#t'
        dict_0 = {str_0: float_0, str_0: str_0}
        set_0 = {float_0}
        var_0 = module_0.min(dict_0, set_0)
        filter_module_0 = module_0.FilterModule()
        list_0 = [set_0]
        str_1 = 'Q(,nSyM/HnjIH\x0b-\t'
        var_1 = module_0.max(list_0, str_1)
        list_1 = [float_0, list_0]
        float_1 = 2187.041614
        bool_0 = False
        var_2 = module_0.unique(float_1, list_1, bool_0)
    except BaseException:
        pass

def test_case_34():
    try:
        float_0 = 0.2
        str_0 = 'pA&~SDkLOB04#t'
        dict_0 = {str_0: float_0, str_0: str_0}
        set_0 = {float_0}
        var_0 = module_0.min(dict_0, set_0)
        list_0 = [set_0]
        str_1 = 'Q(,nSyM/HnjIH\x0b-\t'
        var_1 = module_0.max(list_0, str_1)
        list_1 = [float_0, list_0]
        var_2 = module_0.unique(float_0, list_0, list_1)
        str_2 = '\\9$fZtIVN'
        var_3 = module_0.logarithm(float_0)
        var_4 = module_0.unique(float_0, str_2, str_2)
        var_5 = module_0.symmetric_difference(set_0, list_0, list_1)
        str_3 = 'np_fact_cache'
        str_4 = '--depth'
        var_6 = module_0.difference(float_0, str_4, dict_0)
        dict_1 = {str_3: dict_0}
        var_7 = module_0.rekey_on_member(dict_1, dict_0)
    except BaseException:
        pass

def test_case_35():
    try:
        str_0 = 'Y'
        list_0 = [str_0, str_0, str_0]
        bool_0 = False
        var_0 = module_0.inversepower(list_0, bool_0)
    except BaseException:
        pass

def test_case_36():
    try:
        str_0 = 'O'
        int_0 = 29
        var_0 = {str_0: int_0, str_0: str_0}
        var_1 = [var_0, var_0, int_0]
        var_2 = module_0.rekey_on_member(var_1, str_0)
    except BaseException:
        pass

def test_case_37():
    try:
        int_0 = 2
        list_0 = []
        filter_module_0 = module_0.FilterModule(*list_0)
        var_0 = module_0.human_to_bytes(int_0, filter_module_0)
    except BaseException:
        pass