

---- 2024-03-18 03:20:35.239787
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:20:42.308322
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:20:48.188119
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:20:58.289958
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:21:03.605693
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:21:11.942541
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:21:19.082237
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:21:28.343562
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:21:30.764356
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:21:32.511251
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:01.620801
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:06.988152
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:13.306223
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:21.985143
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:29.127917
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:38.727935
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:43.762187
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:49.464685
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:22:54.696941
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:23:03.273692
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:23:58.170709
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:04.582210
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:10.959110
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:18.271334
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:21.117298
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:25.541386
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:32.582512
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:39.075845
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:44.738545
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:24:48.665692
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:26:27.228596
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:26:32.236526
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:26:34.533804
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:26:37.157112
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:26:42.515189
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:26:52.285048
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:26:58.137469
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:27:03.134392
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:27:04.634394
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for method run of class ActionModule\ndef test_ActionModule_run():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:27:15.729088
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# Copyright: (c) 2016, Allen Sanabria <asanabria@linuxdynasty.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom os import path, walk\nimport re\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native, to_text\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import combine_vars\n\n\nclass ActionModule(ActionBase):\n\n    TRANSFERS_FILES = False\n\n    VALID_FILE_EXTENSIONS = ['yaml', 'yml', 'json']\n    VALID_DIR_ARGUMENTS = ['dir', 'depth', 'files_matching', 'ignore_files', 'extensions', 'ignore_unknown_extensions']\n    VALID_FILE_ARGUMENTS = ['file', '_raw_params']\n    VALID_ALL = ['name', 'hash_behaviour']\n\n    def _set_dir_defaults(self):\n        if not self.depth:\n            self.depth = 0\n\n        if self.files_matching:\n            self.matcher = re.compile(r'{0}'.format(self.files_matching))\n        else:\n            self.matcher = None\n\n        if not self.ignore_files:\n            self.ignore_files = list()\n\n        if isinstance(self.ignore_files, string_types):\n            self.ignore_files = self.ignore_files.split()\n\n        elif isinstance(self.ignore_files, dict):\n            return {\n                'failed': True,\n                'message': '{0} must be a list'.format(self.ignore_files)\n            }\n\n    def _set_args(self):\n        \"\"\" Set instance variables based on the arguments that were passed \"\"\"\n\n        self.hash_behaviour = self._task.args.get('hash_behaviour', None)\n        self.return_results_as_name = self._task.args.get('name', None)\n        self.source_dir = self._task.args.get('dir', None)\n        self.source_file = self._task.args.get('file', None)\n        if not self.source_dir and not self.source_file:\n            self.source_file = self._task.args.get('_raw_params')\n            if self.source_file:\n                self.source_file = self.source_file.rstrip('\\n')\n\n        self.depth = self._task.args.get('depth', None)\n        self.files_matching = self._task.args.get('files_matching', None)\n        self.ignore_unknown_extensions = self._task.args.get('ignore_unknown_extensions', False)\n        self.ignore_files = self._task.args.get('ignore_files', None)\n        self.valid_extensions = self._task.args.get('extensions', self.VALID_FILE_EXTENSIONS)\n\n        # convert/validate extensions list\n        if isinstance(self.valid_extensions, string_types):\n            self.valid_extensions = list(self.valid_extensions)\n        if not isinstance(self.valid_extensions, list):\n            raise AnsibleError('Invalid type for \"extensions\" option, it must be a list')\n\n    def run(self, tmp=None, task_vars=None):\n        \"\"\" Load yml files recursively from a directory.\n        \"\"\"\n        del tmp  # tmp no longer has any effect\n\n        if task_vars is None:\n            task_vars = dict()\n\n        self.show_content = True\n        self.included_files = []\n\n        # Validate arguments\n        dirs = 0\n        files = 0\n        for arg in self._task.args:\n            if arg in self.VALID_DIR_ARGUMENTS:\n                dirs += 1\n            elif arg in self.VALID_FILE_ARGUMENTS:\n                files += 1\n            elif arg in self.VALID_ALL:\n                pass\n            else:\n                raise AnsibleError('{0} is not a valid option in include_vars'.format(to_native(arg)))\n\n        if dirs and files:\n            raise AnsibleError(\"You are mixing file only and dir only arguments, these are incompatible\")\n\n        # set internal vars from args\n        self._set_args()\n\n        results = dict()\n        if self.source_dir:\n            self._set_dir_defaults()\n            self._set_root_dir()\n            if not path.exists(self.source_dir):\n                failed = True\n                err_msg = ('{0} directory does not exist'.format(to_native(self.source_dir)))\n            elif not path.isdir(self.source_dir):\n                failed = True\n                err_msg = ('{0} is not a directory'.format(to_native(self.source_dir)))\n            else:\n                for root_dir, filenames in self._traverse_dir_depth():\n                    failed, err_msg, updated_results = (self._load_files_in_dir(root_dir, filenames))\n                    if failed:\n                        break\n                    results.update(updated_results)\n        else:\n            try:\n                self.source_file = self._find_needle('vars', self.source_file)\n                failed, err_msg, updated_results = (\n                    self._load_files(self.source_file)\n                )\n                if not failed:\n                    results.update(updated_results)\n\n            except AnsibleError as e:\n                failed = True\n                err_msg = to_native(e)\n\n        if self.return_results_as_name:\n            scope = dict()\n            scope[self.return_results_as_name] = results\n            results = scope\n\n        result = super(ActionModule, self).run(task_vars=task_vars)\n\n        if failed:\n            result['failed'] = failed\n            result['message'] = err_msg\n        elif self.hash_behaviour is not None and self.hash_behaviour != C.DEFAULT_HASH_BEHAVIOUR:\n            merge_hashes = self.hash_behaviour == 'merge'\n            for key, value in results.items():\n                old_value = task_vars.get(key, None)\n                results[key] = combine_vars(old_value, value, merge=merge_hashes)\n\n        result['ansible_included_var_files'] = self.included_files\n        result['ansible_facts'] = results\n        result['_ansible_no_log'] = not self.show_content\n\n        return result\n\n    def _set_root_dir(self):\n        if self._task._role:\n            if self.source_dir.split('/')[0] == 'vars':\n                path_to_use = (\n                    path.join(self._task._role._role_path, self.source_dir)\n                )\n                if path.exists(path_to_use):\n                    self.source_dir = path_to_use\n            else:\n                path_to_use = (\n                    path.join(\n                        self._task._role._role_path, 'vars', self.source_dir\n                    )\n                )\n                self.source_dir = path_to_use\n        else:\n            if hasattr(self._task._ds, '_data_source'):\n                current_dir = (\n                    \"/\".join(self._task._ds._data_source.split('/')[:-1])\n                )\n                self.source_dir = path.join(current_dir, self.source_dir)\n\n    def _traverse_dir_depth(self):\n        \"\"\" Recursively iterate over a directory and sort the files in\n            alphabetical order. Do not iterate pass the set depth.\n            The default depth is unlimited.\n        \"\"\"\n        current_depth = 0\n        sorted_walk = list(walk(self.source_dir))\n        sorted_walk.sort(key=lambda x: x[0])\n        for current_root, current_dir, current_files in sorted_walk:\n            current_depth += 1\n            if current_depth <= self.depth or self.depth == 0:\n                current_files.sort()\n                yield (current_root, current_files)\n            else:\n                break\n\n    def _ignore_file(self, filename):\n        \"\"\" Return True if a file matches the list of ignore_files.\n        Args:\n            filename (str): The filename that is being matched against.\n\n        Returns:\n            Boolean\n        \"\"\"\n        for file_type in self.ignore_files:\n            try:\n                if re.search(r'{0}$'.format(file_type), filename):\n                    return True\n            except Exception:\n                err_msg = 'Invalid regular expression: {0}'.format(file_type)\n                raise AnsibleError(err_msg)\n        return False\n\n    def _is_valid_file_ext(self, source_file):\n        \"\"\" Verify if source file has a valid extension\n        Args:\n            source_file (str): The full path of source file or source file.\n        Returns:\n            Bool\n        \"\"\"\n        file_ext = path.splitext(source_file)\n        return bool(len(file_ext) > 1 and file_ext[-1][1:] in self.valid_extensions)\n\n    def _load_files(self, filename, validate_extensions=False):\n        \"\"\" Loads a file and converts the output into a valid Python dict.\n        Args:\n            filename (str): The source file.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        if validate_extensions and not self._is_valid_file_ext(filename):\n            failed = True\n            err_msg = ('{0} does not have a valid extension: {1}'.format(to_native(filename), ', '.join(self.valid_extensions)))\n        else:\n            b_data, show_content = self._loader._get_file_contents(filename)\n            data = to_text(b_data, errors='surrogate_or_strict')\n\n            self.show_content = show_content\n            data = self._loader.load(data, file_name=filename, show_content=show_content)\n            if not data:\n                data = dict()\n            if not isinstance(data, dict):\n                failed = True\n                err_msg = ('{0} must be stored as a dictionary/hash'.format(to_native(filename)))\n            else:\n                self.included_files.append(filename)\n                results.update(data)\n\n        return failed, err_msg, results\n\n    def _load_files_in_dir(self, root_dir, var_files):\n        \"\"\" Load the found yml files and update/overwrite the dictionary.\n        Args:\n            root_dir (str): The base directory of the list of files that is being passed.\n            var_files: (list): List of files to iterate over and load into a dictionary.\n\n        Returns:\n            Tuple (bool, str, dict)\n        \"\"\"\n        results = dict()\n        failed = False\n        err_msg = ''\n        for filename in var_files:\n            stop_iter = False\n            # Never include main.yml from a role, as that is the default included by the role\n            if self._task._role:\n                if path.join(self._task._role._role_path, filename) == path.join(root_dir, 'vars', 'main.yml'):\n                    stop_iter = True\n                    continue\n\n            filepath = path.join(root_dir, filename)\n            if self.files_matching:\n                if not self.matcher.search(filename):\n                    stop_iter = True\n\n            if not stop_iter and not failed:\n                if self.ignore_unknown_extensions:\n                    if path.exists(filepath) and not self._ignore_file(filename) and self._is_valid_file_ext(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n                else:\n                    if path.exists(filepath) and not self._ignore_file(filename):\n                        failed, err_msg, loaded_data = self._load_files(filepath, validate_extensions=True)\n                        if not failed:\n                            results.update(loaded_data)\n\n        return failed, err_msg, results\n\n# Unit test for constructor of class ActionModule\ndef test_ActionModule():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}