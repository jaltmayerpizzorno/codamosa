

---- 2024-03-18 06:17:24.402640
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:17:31.771185
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:17:38.882177
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:17:48.373499
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:17:57.129119
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:18:03.644005
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:18:10.527144
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:18:17.943283
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:18:27.209599
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:18:36.011051
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:18:47.122143
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:18:54.223131
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:00.798806
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:09.845352
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:17.196243
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:26.252693
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:34.847855
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:40.820913
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:48.858149
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:19:54.654416
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Implements various helpers which are used in the various data providers.\n\nThis module contains custom ``Random()`` class where implemented a lot of\nmethods which are not included in standard ``random.Random()``,\nbut frequently used in this project.\n\nAlso there are implemented function ``get_random_item()`` which helps\nget a random item of the enum object.\n\n\"\"\"\n\nimport os\nimport random as random_module\nimport secrets\nimport string\nimport uuid\nfrom typing import Any, List, Optional\n\n__all__ = ['Random', 'get_random_item', 'random']\n\n\nclass Random(random_module.Random):\n    \"\"\"Custom class for the possibility of extending.\n\n    The class is a subclass of the class ``Random()`` from the module ``random``\n    of the standard library, which provides the custom methods.\n\n    \"\"\"\n\n    def randints(self, amount: int = 3,\n                 a: int = 1, b: int = 100) -> List[int]:\n        \"\"\"Generate list of random integers.\n\n        :param amount: Amount of elements.\n        :param a: Minimum value of range.\n        :param b: Maximum value of range.\n        :return: List of random integers.\n        :raises ValueError: if amount less or equal to zero.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError('Amount out of range.')\n\n        return [int(self.random() * (b - a)) + a\n                for _ in range(amount)]\n\n    @staticmethod\n    def urandom(*args: Any, **kwargs: Any) -> bytes:\n        \"\"\"Return a bytes object containing random bytes.\n\n        :return: Bytes.\n        \"\"\"\n        return os.urandom(*args, **kwargs)\n\n    def generate_string(self, str_seq: str, length: int = 10) -> str:\n        \"\"\"Generate random string created from string sequence.\n\n        :param str_seq: String sequence of letters or digits.\n        :param length: Max value.\n        :return: Single string.\n        \"\"\"\n        return ''.join(self.choice(str_seq) for _ in range(length))\n\n    def custom_code(self, mask: str = '@###',\n                    char: str = '@', digit: str = '#') -> str:\n        \"\"\"Generate custom code using ascii uppercase and random integers.\n\n        :param mask: Mask of code.\n        :param char: Placeholder for characters.\n        :param digit: Placeholder for digits.\n        :return: Custom code.\n        \"\"\"\n        char_code = ord(char)\n        digit_code = ord(digit)\n\n        if char_code == digit_code:\n            raise ValueError('You cannot use the same '\n                             'placeholder for digits and chars!')\n\n        def random_int(a: int, b: int) -> int:\n            b = b - a\n            return int(self.random() * b) + a\n\n        _mask = mask.encode()\n        code = bytearray(len(_mask))\n        for i, p in enumerate(_mask):\n            if p == char_code:\n                a = random_int(65, 91)  # A-Z\n            elif p == digit_code:\n                a = random_int(48, 58)  # 0-9\n            else:\n                a = p\n            code[i] = a\n        return code.decode()\n\n    def uniform(self, a: float, b: float, precision: int = 15) -> float:\n        \"\"\"Get a random number in the range [a, b) or [a, b] depending on rounding.\n\n        :param a: Minimum value.\n        :param b: Maximum value.\n        :param precision: Round a number to a given\n            precision in decimal digits, default is 15.\n        \"\"\"\n        return round(a + (b - a) * self.random(), precision)\n\n    def randstr(self, unique: bool = False,\n                length: Optional[int] = None) -> str:\n        \"\"\"Generate random string value.\n\n        This method can be especially useful when you need to generate\n        only unique values in your provider. Just pass parameter unique=True.\n\n        Basically, this method is just a simple wrapper around uuid.uuid4().\n\n        :param unique: Generate only unique values.\n        :param length: Length of string. Default range is (min=16, max=128).\n        :return: Random string.\n\n        \"\"\"\n        if unique:\n            return str(uuid.uuid4().hex)\n\n        if length is None:\n            length = self.randint(16, 128)\n\n        _string = string.ascii_letters + string.digits\n        _string = ''.join(\n            secrets.choice(_string) for _ in range(length)\n        )\n        return _string\n\n\ndef get_random_item(enum: Any, rnd: Optional[Random] = None) -> Any:\n    \"\"\"Get random item of enum object.\n\n    :param enum: Enum object.\n    :param rnd: Custom random object.\n    :return: Random item of enum.\n    \"\"\"\n    if rnd and isinstance(rnd, Random):\n        return rnd.choice(list(enum))\n    return random_module.choice(list(enum))\n\n\n# Compat\n# See: https://github.com/lk-geimfari/mimesis/issues/469\nrandom = Random()\n\n# Unit test for method custom_code of class Random\ndef test_Random_custom_code():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}