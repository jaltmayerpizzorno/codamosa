

---- 2024-03-18 04:56:09.103328
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:56:16.415887
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:56:24.716659
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:56:31.299056
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:56:40.813124
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:56:47.481475
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:56:55.277545
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:57:03.521921
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:57:09.211689
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:57:16.529226
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:58:17.324736
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:58:22.974679
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function walk_packages\ndef test_walk_packages():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:58:29.129112
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:58:36.181157
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:58:44.780561
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function walk_packages\ndef test_walk_packages():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:58:53.627472
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function walk_packages\ndef test_walk_packages():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:59:00.562137
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:59:07.751416
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:59:14.411765
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 04:59:21.681352
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function walk_packages\ndef test_walk_packages():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:00:57.407974
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:04.201572
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function walk_packages\ndef test_walk_packages():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:16.565352
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function walk_packages\ndef test_walk_packages():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:24.046216
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:30.537328
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:36.379667
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function walk_packages\ndef test_walk_packages():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:41.703652
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:48.287278
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:53.638992
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:01:58.306872
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Compiler functions.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import Optional\nfrom collections.abc import Sequence, Iterator\nfrom sys import path as sys_path\nfrom os import mkdir, walk\nfrom os.path import isdir, isfile, abspath, join, sep, dirname\nfrom importlib.abc import Loader\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import find_spec, spec_from_file_location, module_from_spec\nfrom .logger import logger\nfrom .parser import parent, Parser\n\nPEP561_SUFFIX = '-stubs'\n\n\ndef _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()\n\n\ndef _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)\n\n\ndef _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])\n\n\ndef walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path\n\n\ndef _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False\n\n\ndef loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()\n\n\ndef gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs\n\n# Unit test for function loader\ndef test_loader():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}