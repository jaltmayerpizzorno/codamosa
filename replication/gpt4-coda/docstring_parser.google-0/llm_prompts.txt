

---- 2024-03-18 05:17:59.685536
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:05.103185
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:14.095016
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:18.901119
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:24.205305
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:32.037591
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:38.451793
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:45.181576
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:50.853497
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:18:57.671790
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:19:13.944887
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:19:24.674397
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:19:30.215908
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:19:42.003355
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:19:47.409609
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:19:52.572197
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:02.101105
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:08.627035
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:16.683179
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:22.743348
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:35.826369
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:43.839945
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:51.946587
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:20:59.015494
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:05.608621
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:12.211079
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:17.806040
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:25.033398
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:31.737787
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:38.791639
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:53.285897
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:21:59.227237
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:22:08.055305
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:22:14.288827
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:22:26.451434
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:22:34.152193
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:22:42.159077
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:22:49.000060
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:22:55.363105
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:23:02.804887
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:23:16.093354
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:23:22.887364
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:23:29.841415
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:23:39.036836
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:23:45.761565
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:23:53.833163
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:24:00.446941
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:24:06.962149
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:24:13.186873
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:24:22.320323
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:24:40.998600
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:24:51.079856
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:24:57.068641
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:02.444384
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:10.078545
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:17.960367
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:22.748447
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:31.120074
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:37.037901
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:43.958344
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:25:57.866624
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:02.988974
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:07.704359
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:12.552254
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:19.166770
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:25.798855
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:30.865609
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:39.384153
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:47.893510
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:26:53.996996
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:27:27.408486
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 05:27:35.557767
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"Google-style docstring parsing.\"\"\"\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)\n\n# Unit test for method parse of class GoogleParser\ndef test_GoogleParser_parse():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}