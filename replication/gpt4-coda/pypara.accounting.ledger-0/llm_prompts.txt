

---- 2024-03-18 06:58:36.888890
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:58:43.899901
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:58:50.648792
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:58:58.964330
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:06.704155
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:08.034712
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:08.763377
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:09.672717
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:16.369979
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function compile_general_ledger_program\ndef test_compile_general_ledger_program():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:22.994307
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:44.188768
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:51.070388
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:51.795616
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 06:59:58.697012
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:09.961740
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:17.272119
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:18.177999
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:25.814452
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:26.558554
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:35.034896
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:51.834585
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:52.492448
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:53.540258
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:00:59.501942
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:01:00.783818
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:01:08.228714
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function compile_general_ledger_program\ndef test_compile_general_ledger_program():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:01:16.930655
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:01:18.395951
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:01:26.036723
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function compile_general_ledger_program\ndef test_compile_general_ledger_program():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:01:34.256684
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:20.356013
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:21.152328
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:31.518257
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:32.281202
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:33.284508
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:39.915702
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:46.263363
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function compile_general_ledger_program\ndef test_compile_general_ledger_program():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:53.531386
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:02:54.294745
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:03:02.034275
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:03:41.427525
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function compile_general_ledger_program\ndef test_compile_general_ledger_program():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:03:49.862355
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:00.809078
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:02.132412
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:03.238844
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:08.549038
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:09.534486
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:10.212565
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:11.022202
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:04:11.881944
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:17.009875
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:18.386319
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:19.288851
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:20.635275
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:21.363108
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:29.331494
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:30.157535
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:36.111144
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:37.590977
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:05:51.976548
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:07:49.189896
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:07:54.654029
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:07:56.029120
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:07:57.237607
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method add of class Ledger\ndef test_Ledger_add():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:08:05.084031
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class GeneralLedgerProgram\ndef test_GeneralLedgerProgram___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:08:15.739905
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function build_general_ledger\ndef test_build_general_ledger():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:08:23.162016
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for method __call__ of class ReadInitialBalances\ndef test_ReadInitialBalances___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 07:08:29.109072
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and related functionality for preparing general ledgers.\n\"\"\"\n\n__all__ = [\n    \"GeneralLedger\",\n    \"GeneralLedgerProgram\",\n    \"InitialBalances\",\n    \"Ledger\",\n    \"LedgerEntry\",\n    \"ReadInitialBalances\",\n    \"build_general_ledger\",\n    \"compile_general_ledger_program\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\n#: Defines a generic type variable.\n_T = TypeVar(\"_T\")\n\n\n#: Initial balances:\nInitialBalances = Dict[Account, Balance]\n\n\n@dataclass\nclass LedgerEntry(Generic[_T]):\n    \"\"\"\n    Provides a ledger entry model.\n    \"\"\"\n\n    #: Ledger the entry belongs to.\n    ledger: \"Ledger[_T]\"\n\n    #: Posting of the ledger entry.\n    posting: Posting[_T]\n\n    #: Balance of the ledger entry.\n    balance: Quantity\n\n    @property\n    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date\n\n    @property\n    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description\n\n    @property\n    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount\n\n    @property\n    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit\n\n    @property\n    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None\n\n    @property\n    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None\n\n\n@dataclass\nclass Ledger(Generic[_T]):\n    \"\"\"\n    Provides an account ledger model.\n    \"\"\"\n\n    #: Account of the ledger.\n    account: Account\n\n    #: Initial balance of the ledger.\n    initial: Balance\n\n    #: Ledger entries.\n    entries: List[LedgerEntry[_T]] = field(default_factory=list, init=False)\n\n    @property\n    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value\n\n    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry\n\n\n@dataclass\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\n    #: Accounting period.\n    period: DateRange\n\n    #: Individual account ledgers of the general ledger.\n    ledgers: Dict[Account, Ledger[_T]]\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)\n\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n        pass\n\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass\n\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program\n\n# Unit test for function compile_general_ledger_program\ndef test_compile_general_ledger_program():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}