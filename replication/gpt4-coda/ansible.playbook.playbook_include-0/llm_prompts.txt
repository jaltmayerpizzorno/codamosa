

---- 2024-03-18 02:56:56.771159
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:02.776384
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:10.040063
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:18.137498
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:27.067912
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:36.086120
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:41.429019
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:49.317271
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:57:56.352046
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:58:02.959948
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:58:16.358042
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:58:25.149563
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:58:32.604938
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:58:41.287382
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:58:48.047809
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:58:56.192412
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:59:05.751361
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:59:11.561964
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:59:21.306930
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:59:27.852365
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:59:40.769876
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 02:59:48.776817
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:00.231863
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:09.283558
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:15.605775
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:21.629023
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:26.784223
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:33.067714
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:41.362606
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:47.080021
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:00:58.857935
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:01:04.904914
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:01:16.527411
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:01:26.198099
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:01:31.626834
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:01:38.556974
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:01:44.715158
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:01:53.618172
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:02:01.323286
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:02:07.673851
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:02:17.899124
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:02:32.908175
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:02:41.736705
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:02:48.555285
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:01.095343
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:07.588862
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:13.327071
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:19.177419
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:26.404631
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:34.132348
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:45.287661
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:51.781399
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:03:58.131719
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:04:07.108869
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:04:13.677066
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:04:18.908671
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:04:26.279744
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:04:32.324583
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:04:37.368644
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:04:45.584308
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:01.777905
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:07.233446
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:14.174185
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:20.225579
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:26.020559
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:35.292130
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:41.525779
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:49.820256
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:05:58.226780
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:06:05.168566
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:06:29.202084
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:06:39.670466
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 03:06:45.905232
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}