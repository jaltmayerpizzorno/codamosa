

---- 2024-03-18 09:32:33.876146
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:32:34.960647
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:32:41.965965
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:32:46.461630
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:32:50.352617
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:32:52.223233
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:32:54.960132
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:32:59.377290
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:33:04.450790
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:33:05.460567
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:33:57.565491
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:02.740754
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:08.239890
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:09.132310
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:16.717102
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:18.431218
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:30.454230
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:39.070285
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:42.860280
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:34:48.670123
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:31.009986
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:32.323760
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:35.997857
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:44.314220
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:45.274365
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:48.483688
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:49.951177
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:56.862769
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:36:58.124639
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:37:04.103255
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:12.031061
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:15.324749
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:21.531916
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:25.472213
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:28.086891
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:35.868545
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:44.654132
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n# Unit test for constructor of class ZDFBaseIE\ndef test_ZDFBaseIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:48.801580
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:51.920350
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_mincount': 23,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_mincount': 50,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n\n# Unit test for constructor of class ZDFChannelIE\ndef test_ZDFChannelIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 09:40:55.013470
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    merge_dicts,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    url_or_none,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    _GEO_COUNTRIES = ['DE']\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh', 'hd')\n\n    def _call_api(self, url, video_id, item, api_token=None, referrer=None):\n        headers = {}\n        if api_token:\n            headers['Api-Auth'] = 'Bearer %s' % api_token\n        if referrer:\n            headers['Referer'] = referrer\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item, headers=headers)\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = url_or_none(caption.get('uri'))\n            if subtitle_url:\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = url_or_none(meta.get('url'))\n        if not format_url:\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_ptmd(self, ptmd_url, video_id, api_token, referrer):\n        ptmd = self._call_api(\n            ptmd_url, video_id, 'metadata', api_token, referrer)\n\n        content_id = ptmd.get('basename') or ptmd_url.split('/')[-1]\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            content_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            ptmd, lambda x: x['attributes']['duration']['value']), scale=1000)\n\n        return {\n            'extractor_key': ZDFIE.ie_key(),\n            'id': content_id,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(ptmd),\n        }\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)\\.html'\n    _TESTS = [{\n        # Same as https://www.phoenix.de/sendungen/ereignisse/corona-nachgehakt/wohin-fuehrt-der-protest-in-der-pandemie-a-2050630.html\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/wohin-fuehrt-der-protest-in-der-pandemie-100.html',\n        'md5': '34ec321e7eb34231fd88616c65c92db0',\n        'info_dict': {\n            'id': '210222_phx_nachgehakt_corona_protest',\n            'ext': 'mp4',\n            'title': 'Wohin f\u00fchrt der Protest in der Pandemie?',\n            'description': 'md5:7d643fe7f565e53a24aac036b2122fbd',\n            'duration': 1691,\n            'timestamp': 1613948400,\n            'upload_date': '20210221',\n        },\n    }, {\n        # Same as https://www.3sat.de/film/ab-18/10-wochen-sommer-108.html\n        'url': 'https://www.zdf.de/dokumentation/ab-18/10-wochen-sommer-102.html',\n        'md5': '0aff3e7bc72c8813f5e0fae333316a1d',\n        'info_dict': {\n            'id': '141007_ab18_10wochensommer_film',\n            'ext': 'mp4',\n            'title': 'Ab 18! - 10 Wochen Sommer',\n            'description': 'md5:8253f41dc99ce2c3ff892dac2d65fe26',\n            'duration': 2660,\n            'timestamp': 1608604200,\n            'upload_date': '20201222',\n        },\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': '151025_magie_farben2_tex',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        # Same as https://www.phoenix.de/sendungen/dokumentationen/gesten-der-maechtigen-i-a-89468.html?ref=suche\n        'url': 'https://www.zdf.de/politik/phoenix-sendungen/die-gesten-der-maechtigen-100.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/film/spielfilm/der-hauptmann-100.html\n        'url': 'https://www.zdf.de/filme/filme-sonstige/der-hauptmann-112.html',\n        'only_matching': True,\n    }, {\n        # Same as https://www.3sat.de/wissen/nano/nano-21-mai-2019-102.html, equal media ids\n        'url': 'https://www.zdf.de/wissen/nano/nano-21-mai-2019-102.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'ngplayer_2_4')\n\n        info = self._extract_ptmd(\n            urljoin(url, ptmd_path), video_id, player['apiToken'], url)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                layout_url = url_or_none(layout_url)\n                if not layout_url:\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return merge_dicts(info, {\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n        })\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], video_id, 'content', player['apiToken'], url)\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        video = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)\n\n        document = video['document']\n\n        title = document['titel']\n        content_id = document['basename']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(content_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': content_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(document.get('date')) or unified_timestamp(\n                try_get(video, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n# Unit test for constructor of class ZDFIE\ndef test_ZDFIE():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}