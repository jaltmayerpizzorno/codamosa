

---- 2024-03-18 08:48:03.257864
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:14.650619
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:21.424354
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Reference\ndef test_Reference():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:30.217688
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:36.515258
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __repr__ of class Schema\ndef test_Schema___repr__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:41.356134
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:47.814716
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:48:53.763570
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:00.081354
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:08.508680
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:49:56.450629
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:05.008456
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:09.772510
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:14.991217
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:26.739295
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:31.288329
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:38.186517
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:43.460218
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:49.481243
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:50:59.410762
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:51:24.581428
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:51:30.530356
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:51:40.881645
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:51:47.682488
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:51:55.162353
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:01.095076
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __repr__ of class Schema\ndef test_Schema___repr__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:07.058730
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:14.396865
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:23.002681
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:52:28.976395
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Reference\ndef test_Reference():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:11.082295
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:15.267649
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __repr__ of class Schema\ndef test_Schema___repr__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:20.429277
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:21.098315
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:26.805567
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:33.443511
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __getitem__ of class Schema\ndef test_Schema___getitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:38.504830
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:42.822272
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:49.759152
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:53:50.686742
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:34.546971
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:35.574825
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:36.792576
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:44.346549
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:50.833030
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:57.871441
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:54:58.802156
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:55:06.443486
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:55:11.821552
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:55:16.588348
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:56:33.957681
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:56:39.810718
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __getitem__ of class Schema\ndef test_Schema___getitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:56:44.292287
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:57:00.122528
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:57:06.797302
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:57:17.034773
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:57:23.402372
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:57:30.429022
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-03-18 08:57:37.389239
{"model": "gpt-4-1106-preview", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __repr__ of class Schema\ndef test_Schema___repr__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}