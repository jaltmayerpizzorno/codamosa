

# Generated at 2024-03-18 09:35:48.966919
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:35:53.601680
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Queen - Bohemian Rhapsody'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Queen'
    assert result_info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Queen'),
        mock.call('[fromtitle] parsed title: Bohemian Rhapsody')
    ])
```

# Generated at 2024-03-18 09:36:04.553491
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Queen - Bohemian Rhapsody'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Queen'
    assert result_info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Queen'),
        mock.call('[fromtitle] parsed title: Bohemian Rhapsody')
    ])
```

# Generated at 2024-03-18 09:36:14.268759
```python
    # Mock downloader object
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        ('%(title)s - %(artist)s', 'Awesome Song - Great Artist'),
        ('%(series)s S%(season_number)02dE%(episode_number)02d - %(episode)s', 'ShowName S03E05 - The Episode Title'),
        ('%(title)s', 'SingleTitle'),
        ('Just a static string', 'Just a static string'),
        ('%(title)s_%(id)s.%(ext)s', 'VideoTitle_12345.mp4')
    ]

    for titleformat, title in test_cases:
        pp = MetadataFromTitlePP(MockDownloader(), titleformat)
        assert pp._titleformat == titleformat, "Title format is not set correctly"
        if re.search(r'%\(\w+\)s', titleformat):
            assert isinstance(pp._tit

# Generated at 2024-03-18 09:36:19.766029
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:36:24.207911
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:36:30.148945
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Thriller (1982)',
            'expected': {'title': 'Thriller', 'year': '1982'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'In the End',
            'expected': {'title': 'In the End'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Unknown Format',
            'expected': None  # Should

# Generated at 2024-03-18 09:36:36.728923
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    
    # Test successful extraction
    info_dict = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info_dict)
    assert info_dict['artist'] == 'Queen'
    assert info_dict['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test unsuccessful extraction
    info_dict = {'title': 'Unknown Format'}
    pp.run(info_dict)
    assert 'artist' not in info_dict
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%(artist)s - %(title)s"'
    )
```

# Generated at 2024-03-18 09:36:41.241846
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:36:45.644071
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:36:54.307559
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    updated_info = pp.run(info.copy())[1]

    # Assert
    assert updated_info['artist'] == 'Coldplay'
    assert updated_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:36:59.641816
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:37:05.904067
    pp = MetadataFromTitlePP(None, '%(title)s - %(artist)s')
    regex = pp.format_to_regex(pp._titleformat)
    assert regex == r'(?P<title>.+)\ \-\ (?P<artist>.+)', 'Regex does not match expected pattern'

    pp = MetadataFromTitlePP(None, '%(series)s S%(season_number)02dE%(episode_number)02d - %(episode)s')
    regex = pp.format_to_regex(pp._titleformat)
    assert regex == r'(?P<series>.+) S(?P<season_number>\d\d)E(?P<episode_number>\d\d) - (?P<episode>.+)', 'Regex does not match expected pattern'

    pp = MetadataFromTitlePP(None, 'S%(season_number)02dE%(episode_number)02d - %(title)s')
    regex = pp.format_to_regex(pp._titleformat)
    assert regex == r'S(?P<

# Generated at 2024-03-18 09:37:12.975098
    pp = MetadataFromTitlePP(None, '%(artist)s - %(title)s')
    regex = pp.format_to_regex(pp._titleformat)
    assert regex == r'(?P<artist>.+)\ \-\ (?P<title>.+)', 'Regex did not match expected pattern'

    pp = MetadataFromTitlePP(None, 'FixedTitle - %(album)s')
    regex = pp.format_to_regex(pp._titleformat)
    assert regex == r'FixedTitle\ \-\ (?P<album>.+)', 'Regex did not match expected pattern'

    pp = MetadataFromTitlePP(None, '%(track_number)02d - %(title)s')
    regex = pp.format_to_regex(pp._titleformat)
    assert regex == r'(?P<track_number>02d)\ \-\ (?P<title>.+)', 'Regex did not match expected pattern'

    pp = MetadataFromTitlePP(None, 'NoPattern')
    regex = pp.format_to_regex(pp._title

# Generated at 2024-03-18 09:37:18.316870
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:37:25.196061
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Queen - Bohemian Rhapsody',
            'expected': {'artist': 'Queen', 'title': 'Bohemian Rhapsody'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Space Odyssey (1968)',
            'expected': {'title': 'Space Odyssey', 'year': '1968'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'Unknown Title Format',
            'expected': {'title': 'Unknown Title Format'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Invalid - Format

# Generated at 2024-03-18 09:37:31.882174
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:37:39.509464
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Queen - Bohemian Rhapsody'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Queen'
    assert result_info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed artist: Queen')
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed title: Bohemian Rhapsody')
```

# Generated at 2024-03-18 09:37:46.731750
    # Test cases for the format_to_regex method
    pp = MetadataFromTitlePP(None, '%(artist)s - %(title)s')
    assert pp.format_to_regex('%(artist)s - %(title)s') == r'(?P<artist>.+)\ \-\ (?P<title>.+)'
    assert pp.format_to_regex('%(series)s S%(season_number)02dE%(episode_number)02d - %(episode)s') == \
        r'(?P<series>.+)\ S(?P<season_number>\d\d)E(?P<episode_number>\d\d)\ \-\ (?P<episode>.+)'
    assert pp.format_to_regex('Season %(season_number)d - Episode %(episode_number)d: %(episode)s') == \
        r'Season\ (?P<season_number>\d+)\ \-\ Episode\ (?P<episode_number>\d+):\ (?P<episode>.+)'
    assert pp.format_to_regex('%(title)s')

# Generated at 2024-03-18 09:37:53.402481
    # Test cases for the format_to_regex method
    pp = MetadataFromTitlePP(None, '%(artist)s - %(title)s')
    assert pp.format_to_regex('%(artist)s - %(title)s') == r'(?P<artist>.+)\ \-\ (?P<title>.+)'
    assert pp.format_to_regex('%(series)s S%(season_number)02dE%(episode_number)02d - %(episode)s') == \
        r'(?P<series>.+) S(?P<season_number>\d\d)E(?P<episode_number>\d\d) - (?P<episode>.+)'
    assert pp.format_to_regex('Season %(season_number)d - %(episode_number)d - %(title)s') == \
        r'Season\ (?P<season_number>\d)\ \-\ (?P<episode_number>\d)\ \-\ (?P<title>.+)'
    assert pp.format_to_regex('%(title)s') == r'(?

# Generated at 2024-03-18 09:38:02.094578
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:38:09.968654
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test successful extraction
    info_dict = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info_dict)
    assert info_dict['artist'] == 'Queen'
    assert info_dict['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test unsuccessful extraction
    info_dict = {'title': 'Unknown Format'}
    pp.run(info_dict)
    assert 'artist' not in info_dict
    assert info_dict['title'] == 'Unknown Format'
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"' % title_format
    )
```

# Generated at 2024-03-18 09:38:16.469816
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    
    # Test successful extraction
    info_dict = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info_dict)
    assert info_dict['artist'] == 'Queen'
    assert info_dict['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test unsuccessful extraction
    info_dict = {'title': 'Unknown Format'}
    pp.run(info_dict)
    assert 'artist' not in info_dict
    assert info_dict['title'] == 'Unknown Format'
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"' % title_format
    )
```

# Generated at 2024-03-18 09:38:21.996009
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:38:27.354935
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:38:32.444938
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Queen - Bohemian Rhapsody'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Queen'
    assert result_info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Queen'),
        mock.call('[fromtitle] parsed title: Bohemian Rhapsody')
    ])
```

# Generated at 2024-03-18 09:38:39.501217
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Thriller (1982)',
            'expected': {'title': 'Thriller', 'year': '1982'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'In the End',
            'expected': {'title': 'In the End'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Unknown Artist - Unknown Title',
            'expected': {'

# Generated at 2024-03-18 09:38:46.876315
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test successful extraction
    info_dict = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info_dict)
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed artist: Queen')
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed title: Bohemian Rhapsody')
    assert info_dict['artist'] == 'Queen'
    assert info_dict['title'] == 'Bohemian Rhapsody'

    # Test failed extraction
    info_dict = {'title': 'Unknown Format'}
    pp.run(info_dict)
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"' % title_format)
    assert 'artist' not in info_dict
    assert info

# Generated at 2024-03-18 09:38:52.792776
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:38:58.997636
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:39:14.592777
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'In the End',
            'expected': {'title': 'In the End'}
        },
        {
            'titleformat': '%(artist)s - %(album)s - %(title)s',
            'title': 'Nirvana - Nevermind - Smells Like Teen Spirit',
            'expected': {'artist': 'Nirvana', 'album': 'Nevermind', 'title': 'Smells Like Teen Spirit'}
        },
        {
            'titleformat': '(%(

# Generated at 2024-03-18 09:39:21.235500
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Thriller (1982)',
            'expected': {'title': 'Thriller', 'year': '1982'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'In the End',
            'expected': {'title': 'In the End'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Invalid Format',
            'expected': None  # Should

# Generated at 2024-03-18 09:39:29.312267
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Correct title format
    info = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info)
    assert info['artist'] == 'Queen'
    assert info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test case: Incorrect title format
    info = {'title': 'Unknown Title Format'}
    result, info = pp.run(info)
    assert result == []
    assert 'artist' not in info
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"' % title_format
    )

    # Test case: Partially matching title

# Generated at 2024-03-18 09:39:35.889332
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Correct title format
    info = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info)
    assert info['artist'] == 'Queen'
    assert info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test case: Incorrect title format
    info = {'title': 'Unknown Title Format'}
    result, info = pp.run(info)
    assert result == []
    assert 'artist' not in info
    assert 'title' in info  # Original title should remain unchanged
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"'

# Generated at 2024-03-18 09:39:41.075626
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:39:48.602014
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Thriller (1982)',
            'expected': {'title': 'Thriller', 'year': '1982'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'In the End',
            'expected': {'title': 'In the End'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Unknown Format',
            'expected': None  # Should

# Generated at 2024-03-18 09:39:53.468432
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:39:58.734680
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:40:05.101848
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Correct title format
    info = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info)
    assert info['artist'] == 'Queen'
    assert info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test case: Incorrect title format
    info = {'title': 'Unknown Title Format'}
    result, info = pp.run(info)
    assert result == []
    assert 'artist' not in info
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"' % title_format
    )

    # Test case: Partially matching title

# Generated at 2024-03-18 09:40:09.110023
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:40:31.044372
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:40:35.897242
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Queen - Bohemian Rhapsody'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Queen'
    assert result_info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Queen'),
        mock.call('[fromtitle] parsed title: Bohemian Rhapsody')
    ])
```

# Generated at 2024-03-18 09:40:43.971727
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: successful extraction
    info_dict = {'title': 'Coldplay - Yellow'}
    expected_info = {'title': 'Yellow', 'artist': 'Coldplay'}
    pp.run(info_dict)
    assert info_dict == expected_info, "Metadata extraction from title failed"

    # Test case: unsuccessful extraction (no match)
    info_dict = {'title': 'Unknown Format'}
    pp.run(info_dict)
    assert 'artist' not in info_dict, "Metadata should not be extracted for unmatched format"
    assert 'title' in info_dict, "Original title should remain unchanged"

    # Test case: partial extraction (partial match)
    title_format = '%(artist)s - %(title)s - %(album)s'
    pp = MetadataFromTitlePP(down

# Generated at 2024-03-18 09:40:52.719158
```python
    # Mock objects and values
    mock_downloader = MagicMock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(mock_downloader, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Expected results
    expected_info = {
        'title': 'Yellow',
        'artist': 'Coldplay',
        'webpage_url': 'https://example.com/video'
    }

    # Run the method
    pp.run(info)

    # Assertions
    mock_downloader.to_screen.assert_any_call('[fromtitle] parsed artist: Coldplay')
    mock_downloader.to_screen.assert_any_call('[fromtitle] parsed title: Yellow')
    assert info['title'] == expected_info['title']
    assert info['artist'] == expected_info['artist']
```

# Generated at 2024-03-18 09:41:01.637944
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test successful extraction
    info_dict = {'title': 'Coldplay - Yellow'}
    pp.run(info_dict)
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed artist: Coldplay')
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed title: Yellow')
    assert info_dict['artist'] == 'Coldplay'
    assert info_dict['title'] == 'Yellow'

    # Test failed extraction
    info_dict = {'title': 'Unknown Format'}
    pp.run(info_dict)
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%(artist)s - %(title)s"'
    )
    assert 'artist' not in info_dict
    assert 'title' == 'Unknown Format'
```

# Generated at 2024-03-18 09:41:06.905817
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:41:14.601031
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Queen - Bohemian Rhapsody',
            'expected': {'artist': 'Queen', 'title': 'Bohemian Rhapsody'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Space Odyssey (1968)',
            'expected': {'title': 'Space Odyssey', 'year': '1968'}
        },
        {
            'titleformat': 'S01E%(episode)s - %(title)s',
            'title': 'S01E03 - The Episode',
            'expected': {'episode': '03', 'title': 'The Episode'}
        },
        {
            'titleformat': '%

# Generated at 2024-03-18 09:41:20.332042
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:41:27.688292
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'Everlong',
            'expected': {'title': 'Everlong'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Unknown Artist - Unknown Title',
            'expected': {'artist': 'Unknown Artist', 'title': 'Unknown Title'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'No Artist - Just a Title',
            'expected': {'title': 'No Artist

# Generated at 2024-03-18 09:41:33.610608
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:42:13.962634
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'Everlong',
            'expected': {'title': 'Everlong'}
        },
        {
            'titleformat': '%(title)s - %(album)s [%(year)s]',
            'title': 'Smells Like Teen Spirit - Nevermind [1991]',
            'expected': {'title': 'Smells Like Teen Spirit', 'album': 'Nevermind', 'year': '1991'}
        },
        {
            'titleformat': '%(track_number)d. %(

# Generated at 2024-03-18 09:42:21.241859
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Thriller (1982)',
            'expected': {'title': 'Thriller', 'year': '1982'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'In the End',
            'expected': {'title': 'In the End'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Unknown Format',
            'expected': None  # Should

# Generated at 2024-03-18 09:42:28.554835
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Correct title format
    info_dict = {'title': 'Queen - Bohemian Rhapsody'}
    expected_info = {'title': 'Bohemian Rhapsody', 'artist': 'Queen'}
    pp.run(info_dict)
    assert info_dict['title'] == expected_info['title']
    assert info_dict['artist'] == expected_info['artist']
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test case: Incorrect title format
    info_dict = {'title': 'Unknown Title Format'}
    result, info_dict = pp.run(info_dict)
    assert result == []
    assert 'artist' not in info_dict
    assert 'title' in info_dict
    downloader

# Generated at 2024-03-18 09:42:42.816824
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:42:48.205920


# Generated at 2024-03-18 09:42:54.066595
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:42:59.438702
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:43:07.668484
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```

# Generated at 2024-03-18 09:43:14.493546
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Correct title format
    info = {'title': 'Coldplay - Yellow'}
    expected_info = {'title': 'Yellow', 'artist': 'Coldplay'}
    pp.run(info)
    assert info == expected_info, "Expected info dictionary to be updated with title and artist"

    # Test case: Incorrect title format
    info = {'title': 'Just a single string'}
    pp.run(info)
    assert 'artist' not in info, "Expected info dictionary not to have an 'artist' key"
    assert 'title' in info, "Expected info dictionary to retain the 'title' key"

    # Test case: Empty title
    info = {'title': ''}
    pp.run(info)
    assert 'artist' not in info,

# Generated at 2024-03-18 09:43:21.260203
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test cases
    test_cases = [
        {'title': 'Artist Name - Song Title', 'expected': {'artist': 'Artist Name', 'title': 'Song Title'}},
        {'title': 'Another Artist - Another Song Title', 'expected': {'artist': 'Another Artist', 'title': 'Another Song Title'}},
        {'title': 'No delimiter', 'expected': None},
    ]

    for case in test_cases:
        info = {'title': case['title']}
        _, result_info = pp.run(info)

        if case['expected'] is None:
            assert 'artist' not in result_info and 'title' not in result_info, f"Metadata should not be extracted from title: {case['title']}"
        else:
            for

# Generated at 2024-03-18 09:44:39.051586
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Correct title format
    info = {'title': 'Coldplay - Yellow'}
    pp.run(info)
    assert info['artist'] == 'Coldplay'
    assert info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Yellow')

    # Test case: Incorrect title format
    info = {'title': 'Unknown Format'}
    pp.run(info)
    assert 'artist' not in info
    assert info['title'] == 'Unknown Format'
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"' % title_format
    )

    # Test case: Missing title part
    info = {'title': 'Adele - '}


# Generated at 2024-03-18 09:44:49.813928
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test cases
    test_cases = [
        {'title': 'Artist Name - Song Title', 'expected': {'artist': 'Artist Name', 'title': 'Song Title'}},
        {'title': 'Another Artist - Another Song Title', 'expected': {'artist': 'Another Artist', 'title': 'Another Song Title'}},
        {'title': 'No delimiter', 'expected': None},
    ]

    for case in test_cases:
        info = {'title': case['title']}
        expected = case['expected']
        output, info = pp.run(info)

        if expected is None:
            assert not output and 'artist' not in info and 'title' not in info, "Failed to ignore invalid title format"
        else:
            assert all(info.get

# Generated at 2024-03-18 09:44:56.306350
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Queen - Bohemian Rhapsody'}

    # Execute
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Queen'
    assert result_info['title'] == 'Bohemian Rhapsody'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Queen'),
        mock.call('[fromtitle] parsed title: Bohemian Rhapsody')
    ])
```

# Generated at 2024-03-18 09:45:02.264335
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'In the End (2001)',
            'expected': {'title': 'In the End', 'year': '2001'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'Everlong',
            'expected': {'title': 'Everlong'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'This Is Not A Valid Format',
            'expected':

# Generated at 2024-03-18 09:45:09.109617
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Successful extraction
    info_dict = {'title': 'Queen - Bohemian Rhapsody'}
    pp.run(info_dict)
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed artist: Queen')
    downloader_mock.to_screen.assert_any_call('[fromtitle] parsed title: Bohemian Rhapsody')
    assert info_dict['artist'] == 'Queen'
    assert info_dict['title'] == 'Bohemian Rhapsody'

    # Test case: Unsuccessful extraction
    info_dict = {'title': 'Unknown Format'}
    pp.run(info_dict)
    downloader_mock.to_screen.assert_called_with(
        '[fromtitle] Could not interpret title of video as "%s"' % title_format)
    assert 'artist' not in info

# Generated at 2024-03-18 09:45:21.772980
```python
    # Setup
    title_format = '%(artist)s - %(title)s'
    downloader_mock = mock.Mock()
    pp = MetadataFromTitlePP(downloader_mock, title_format)

    # Test case: Successful extraction
    info_dict = {'title': 'Queen - Bohemian Rhapsody'}
    expected_info = {'title': 'Bohemian Rhapsody', 'artist': 'Queen'}
    pp.run(info_dict)
    assert info_dict['title'] == expected_info['title']
    assert info_dict['artist'] == expected_info['artist']
    downloader_mock.to_screen.assert_called_with('[fromtitle] parsed title: Bohemian Rhapsody')

    # Test case: Unsuccessful extraction
    info_dict = {'title': 'Unknown Format'}
    result, info_dict = pp.run(info_dict)
    assert result == []
    assert info_dict['title'] == 'Unknown Format'
    downloader_mock.to_screen.assert_called_with(
        '[

# Generated at 2024-03-18 09:45:27.422829
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'Viva la Vida',
            'expected': {'title': 'Viva la Vida'}
        },
        {
            'titleformat': '%(title)s - %(artist)s - %(album)s',
            'title': 'Shape of You - Ed Sheeran - Divide',
            'expected': {'title': 'Shape of You', 'artist': 'Ed Sheeran', 'album': 'Divide'}
        },
        {
            'titleformat': '(%

# Generated at 2024-03-18 09:45:33.765294
```python
    # Mock downloader object with a to_screen method
    class MockDownloader:
        def to_screen(self, message):
            print(message)

    # Test cases
    test_cases = [
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Coldplay - Yellow',
            'expected': {'artist': 'Coldplay', 'title': 'Yellow'}
        },
        {
            'titleformat': '%(title)s (%(year)s)',
            'title': 'Thriller (1982)',
            'expected': {'title': 'Thriller', 'year': '1982'}
        },
        {
            'titleformat': '%(title)s',
            'title': 'In the End',
            'expected': {'title': 'In the End'}
        },
        {
            'titleformat': '%(artist)s - %(title)s',
            'title': 'Unknown Format',
            'expected': None  # Should

# Generated at 2024-03-18 09:45:38.613573
```python
    # Setup
    downloader_mock = mock.Mock()
    title_format = '%(artist)s - %(title)s'
    pp = MetadataFromTitlePP(downloader_mock, title_format)
    info = {'title': 'Coldplay - Yellow'}

    # Run
    _, result_info = pp.run(info)

    # Assert
    assert result_info['artist'] == 'Coldplay'
    assert result_info['title'] == 'Yellow'
    downloader_mock.to_screen.assert_has_calls([
        mock.call('[fromtitle] parsed artist: Coldplay'),
        mock.call('[fromtitle] parsed title: Yellow')
    ])
```