

# Generated at 2022-06-12 21:30:47.192182
# Unit test for method get_active_state of class PlayIterator
def test_PlayIterator_get_active_state():
    play = Play()
    iterator = PlayIterator(play)
    state = HostState(play=play)
    # currently, we expect get_active_state to return the state
    # you pass in, because there is no active state (yet)
    assert state == iterator.get_active_state(state)
    # a bit more of a complicated set of nested states, which we
    # expect should return the inner-most active state
    state = HostState(play=play)
    state.tasks_child_state = HostState(play=play)
    state.tasks_child_state.rescue_child_state = HostState(play=play)
    assert state.tasks_child_state.rescue_child_state == iterator.get_active_state(state)
    # what happens if we pass in a state which is currently
   

# Generated at 2022-06-12 21:30:55.781206
# Unit test for method get_host_state of class PlayIterator
def test_PlayIterator_get_host_state():
    def get_host_state_assert(blocks, host_state, host_name):
        ''' utility function for testing get_host_state method of class PlayIterator '''
        iterator = PlayIterator(play=get_play_for_blocks(blocks=blocks))
        assert iterator.get_host_state(host=Host(host_name)) == host_state, 'host state mismatch'
    get_host_state_assert(blocks=[[block(name='inner block')]], host_state=['inner block'], host_name='fake_host_name')


# Generated at 2022-06-12 21:30:59.172582
# Unit test for method add_tasks of class PlayIterator
def test_PlayIterator_add_tasks():
    '''
    Autogenerated unit tests for method
    ansible.executor.play_iterator.PlayIterator.add_tasks
    '''
    raise SkipTest

    # The actual test function is in test/unit/test_play_iterator.py.

# Generated at 2022-06-12 21:31:04.264237
# Unit test for method mark_host_failed of class PlayIterator
def test_PlayIterator_mark_host_failed():
    # PlayIterator.mark_host_failed() -> None


    # mark_host_failed() is tested indirectly in test_get_next_task_for_host, which
    # is the main interface to this method and the method that interacts with all of
    # the other methods.
    return None

# Generated at 2022-06-12 21:31:07.221257
# Unit test for method get_active_state of class PlayIterator
def test_PlayIterator_get_active_state():
    # AssertionError: assert <HostState failed_state: [1] run_state: 1> != <HostState failed_state: [1] run_state: 1>
    pass

# Generated at 2022-06-12 21:31:18.128611
# Unit test for method __str__ of class HostState
def test_HostState___str__():
    hoststate = HostState()
    hoststate.cur_block = 0
    hoststate.cur_regular_task = 0
    hoststate.cur_rescue_task = 0
    hoststate.cur_always_task = 0
    hoststate.run_state = PlayIterator.ITERATING_SETUP
    hoststate.fail_state = PlayIterator.FAILED_NONE
    hoststate.pending_setup = False
    hoststate.tasks_child_state = None
    hoststate.rescue_child_state = None
    hoststate.always_child_state = None
    hoststate.did_rescue = False
    hoststate.did_start_at_task = False

    hoststate_str = hoststate.__str__()

# Generated at 2022-06-12 21:31:27.587835
# Unit test for method get_failed_hosts of class PlayIterator
def test_PlayIterator_get_failed_hosts():
    ping = dict(
        name = 'ping',
        hosts = '127.0.0.1',
        gather_facts = 'no',
        tasks = [ dict(action=dict(module='ping', args='')) ]
    )
    play_source = dict(
        name = "Ansible Play",
        hosts = 'all',
        gather_facts = 'no',
        tasks = [ dict(action=dict(module='debug', args=dict(msg='{{foo}}'))) ]
    )
    play = Play().load(play_source, loader=DataLoader())
    tqm = None

# Generated at 2022-06-12 21:31:40.138771
# Unit test for method is_any_block_rescuing of class PlayIterator
def test_PlayIterator_is_any_block_rescuing():
    play = Play()
    play.name = 'test play'
    play.hosts = ['localhost']
    play.roles = ['common_role']

    play_iterator = PlayIterator(play, None)

    # setup a state to test with
    state = HostState()
    state.cur_block = 0
    state.cur_regular_task = 0
    state.cur_rescue_task = 0
    state.cur_always_task = 0

    # create a single block with all tasks/handlers filled with noops
    block = Block()
    block.block = [
        Task(), Task(), Task(), Task(), Task(), Task(),
        Handler(), Handler(), Handler(), Handler(), Handler(),
    ]

# Generated at 2022-06-12 21:31:45.237412
# Unit test for method get_active_state of class PlayIterator
def test_PlayIterator_get_active_state():
    pi = PlayIterator(None, None, [], [])
    block_list = []
    pi._tqm._failed_hosts = dict()
    pi._play = dict(play_hosts=dict(), play_hosts_all=dict())
    hosts = dict(host1=dict(name='host1'), host2=dict(name='host2'))
    pi._blocks = dict(
        block1=dict(
            block=dict(
                task1=dict(name='task1'),
                task2=dict(name='task2')
            ),
            rescue=dict(),
            always=dict(),
        ),
        block2=dict(
            block=dict(),
            rescue=dict(),
            always=dict(),
        )
    )
    # Before we move on to the host, we need to create a HostState

# Generated at 2022-06-12 21:31:46.549414
# Unit test for method add_tasks of class PlayIterator
def test_PlayIterator_add_tasks():
    __tracebackhide__ = True
    assert False, "No tests for this module yet"

# Generated at 2022-06-12 21:32:27.087102
# Unit test for method is_any_block_rescuing of class PlayIterator
def test_PlayIterator_is_any_block_rescuing():
    global host_state
    host_state = HostState()
    host_state.run_state = PlayIterator.ITERATING_RESCUE
    assert(PlayIterator().is_any_block_rescuing(host_state) is True)

    global host_state1
    host_state1 = HostState()
    host_state1.run_state = PlayIterator.ITERATING_TASKS
    host_state1.tasks_child_state = HostState()
    host_state1.tasks_child_state.run_state = PlayIterator.ITERATING_RESCUE
    assert(PlayIterator().is_any_block_rescuing(host_state1) is True)

    global host_state2
    host_state2 = HostState()
    host_state2.run_state = PlayIterator.ITER

# Generated at 2022-06-12 21:32:31.591035
# Unit test for method get_active_state of class PlayIterator
def test_PlayIterator_get_active_state():

    it = PlayIterator()

    # Create a flat task list
    task_list = [
        {'action': 'ok', 'name': 'task1', 'block': 0}
    ]

    # Run the unit test
    it.get_active_state(task_list)
    assert True



# Generated at 2022-06-12 21:32:33.043574
# Unit test for method get_active_state of class PlayIterator
def test_PlayIterator_get_active_state():
    assert 0 == 1

# Generated at 2022-06-12 21:32:34.504077
# Unit test for constructor of class PlayIterator
def test_PlayIterator():
    assert(PlayIterator(Play()) != None)


# Generated at 2022-06-12 21:32:44.477308
# Unit test for method get_host_state of class PlayIterator
def test_PlayIterator_get_host_state():
    "PlayIterator.get_host_state()"
    obj = PlayIterator()
    real_hosts = obj._inventory.get_hosts(pattern='foobar')
    fake_host = MagicMock()
    fake_host.name = 'foobar'
    obj._inventory = MagicMock()
    obj._inventory.get_host.return_value = fake_host
    obj._inventory.get_hosts.return_value = [fake_host]
    s = obj.get_host_state(fake_host)
    assert s == None

    obj._inventory.get_host.side_effect = lambda x: real_hosts.get(x)
    s = obj.get_host_state(fake_host)
    assert isinstance(s, HostState)


# Generated at 2022-06-12 21:32:53.209781
# Unit test for method add_tasks of class PlayIterator
def test_PlayIterator_add_tasks():
    '''
    Unit test for method add_tasks of class PlayIterator
    '''
    play = Play().load({
        "name": "test",
        "hosts": "all",
        "gather_facts": "no",
        "tasks": [{"action": {"module": "command", "args": "echo foo"}}]
    }, variable_manager=VariableManager(), loader=DictDataLoader())
    host = Host(name="test")
    pi = PlayIterator(play)
    pi.get_next_task_for_host(host)
    task = pi.get_next_task_for_host(host)[1]
    assert task.action == 'command'

# Generated at 2022-06-12 21:33:04.554283
# Unit test for method get_failed_hosts of class PlayIterator
def test_PlayIterator_get_failed_hosts():
    hc = MagicMock()
    hc.get_host.return_value = 'host'
    play = Play.load(dict(
    	name = 'test play',
    	hosts = 'all',
    	gather_facts = 'no',
    	tasks = [
    	    dict(action=dict(__ansible_module__='ping'))
    	]
    ))
    iterator = PlayIterator(play, hc)
    assert iterator.get_failed_hosts() == {}
    iterator.mark_host_failed('host')
    assert iterator.get_failed_hosts() == {'host': True}


# Generated at 2022-06-12 21:33:15.443664
# Unit test for method get_host_state of class PlayIterator
def test_PlayIterator_get_host_state():
    display.display = ""
    #test_PlayIterator_get_host_state_setup
    #setup
    fake_play = MagicMock()
    fake_play._play_context = None
    fake_play._post_validate = None
    fake_play._handler = None
    fake_play._block = None
    fake_play._dep_chain = None
    fake_play._variable_manager = None
    fake_play._loader = None
    fake_play._tqm = None
    fake_play._tags = {"test_host":"test_host"}
    fake_play._role_names = None
    fake_play._role_params = None
    fake_play._default_vars = None
    fake_play._handlers = None
    #Test
    fake_play_iterator = PlayIterator(fake_play)


# Generated at 2022-06-12 21:33:26.910729
# Unit test for method add_tasks of class PlayIterator
def test_PlayIterator_add_tasks():
    import __main__
    __main__.display = Display()

    host = FakeHost('host')
    play_context = PlayContext()
    play_context.network_os = 'ios'
    play_context.remote_addr = '192.168.1.1'
    play_context.port = 22
    play_context.remote_user = 'foo'
    play_context.connection = 'ssh'
    play_context.become = False
    play_context.become_method = 'sudo'
    play_context.become_user = 'root'
    play_context.check_mode = False
    play_context.diff = False


# Generated at 2022-06-12 21:33:30.822876
# Unit test for method get_active_state of class PlayIterator
def test_PlayIterator_get_active_state():

    # Setup test data
    my_iterator = PlayIterator()

    # Test the method
    result = my_iterator.get_active_state(my_iterator)

    # Verify the result
    assert result == my_iterator, "return value is not the same as the class instance"



# Generated at 2022-06-12 21:34:33.904306
# Unit test for method get_failed_hosts of class PlayIterator
def test_PlayIterator_get_failed_hosts():
    '''Test get_failed_hosts method of PlayIterator class'''

    # test the _host_states dict with no hosts in failed state
    play = Play()
    pi = PlayIterator(play)

    assert pi.get_failed_hosts() == {}


# Generated at 2022-06-12 21:34:44.598569
# Unit test for method add_tasks of class PlayIterator
def test_PlayIterator_add_tasks():
    '''
    Unit test for method add_tasks of class PlayIterator
    '''
    # Initializing test variables
    # Create a mock for 'Play()' class
    play_obj = mock.Mock(spec=Play)
    # Create a Mock object for test
    obj = mock.Mock(spec=PlayIterator,
                    _play={},
                    _host_states={},
                    get_host_state={},
                    _insert_tasks_into_state={},
                    )
    # Setting up return values for methods to be tested
    obj.get_host_state.return_value = {}
    obj._insert_tasks_into_state.return_value = {}
    obj.default = None
    obj.variables = {}
    # Call the method to be tested

# Generated at 2022-06-12 21:34:53.157304
# Unit test for constructor of class PlayIterator
def test_PlayIterator():
    play = Play().load(dict(
        name = "test play",
        hosts = 'all',
        gather_facts = 'no',
        tasks = [
            dict(action=dict(module='shell', args='ls'), register='shell_out'),
            dict(action=dict(module='debug', args=dict(msg='{{shell_out.stdout}}')))
        ]
    ), variable_manager=VariableManager(), loader=DictDataLoader())
    assert PlayIterator(play).play is play
    assert PlayIterator(play).play_context is play._play_context
    assert PlayIterator(play).variable_manager is play._variable_manager


# Generated at 2022-06-12 21:35:02.020684
# Unit test for method get_failed_hosts of class PlayIterator
def test_PlayIterator_get_failed_hosts():
    play_source = dict(
        name = "Ansible Play test",
        hosts = "localhost",
        gather_facts = "no",
        tasks = [
            dict(action="debug", msg="Debug task 1 executed"),
            dict(action="debug", msg="Debug task 2 executed"),
            dict(action="debug", msg="Debug task 3 executed"),
            dict(action="debug", msg="Debug task 4 executed"),
        ]
    )
    my_task_queue = TaskQueueManager(inventory=host_list)
    my_task_queue._inventory.hosts["localhost"] = Host("localhost")
    my_task_queue._inventory.hosts["localhost"].name = "localhost"

# Generated at 2022-06-12 21:35:09.491910
# Unit test for constructor of class PlayIterator
def test_PlayIterator():
    '''
    Unit test for constructor of class PlayIterator
    '''

    from ansible.playbook.play import Play

    # Setup Ansible options
    opts = Options()
    opts.connection = "local"

    # setup for test play
    pb = Playbook(loader=DataLoader(), hosts=['localhost'], variables={})
    pb._basedir = os.getcwd()
    pb._entries = [
        dict(
            name='test play',
            hosts='localhost',
            gather_facts='no',
            tasks=[
                dict(action=dict(module="shell", args="date")),
                dict(action=dict(module="shell", args="sleep 5")),
                dict(action=dict(module="shell", args="date")),
            ]
        )
    ]

    # make

# Generated at 2022-06-12 21:35:15.691090
# Unit test for method is_any_block_rescuing of class PlayIterator
def test_PlayIterator_is_any_block_rescuing():
    '''
    This is a unit test for the method is_any_block_rescuing of the class PlayIterator
    '''

    # test PlayIterator.is_any_block_rescuing without child states
    state = HostState()
    state.run_state = PlayIterator.ITERATING_TASKS
    assert(not PlayIterator.is_any_block_rescuing(state))

    # test PlayIterator.is_any_block_rescuing with a failed rescue state
    state = HostState()
    state.run_state = PlayIterator.ITERATING_RESCUE
    state.fail_state = PlayIterator.FAILED_RESCUE
    assert(PlayIterator.is_any_block_rescuing(state))

    # test PlayIterator.is_any_block_rescuing with a child rescue state

# Generated at 2022-06-12 21:35:20.480328
# Unit test for method get_failed_hosts of class PlayIterator
def test_PlayIterator_get_failed_hosts():
    # Test with no host state
    iterator = PlayIterator([])
    assert iterator.get_failed_hosts() == {}

    # Test with one failed host
    host_1 = Host('test_inventory.test_host_1')
    host_2 = Host('test_inventory.test_host_2')
    host_3 = Host('test_inventory.test_host_3')
    host_states = dict()
    host_states[host_1.name] = HostState(host_1)
    host_states[host_2.name] = HostState(host_2)
    host_states[host_3.name] = HostState(host_3)
    host_states[host_2.name].set_fail_state(HostState.FAILED_TASKS)

# Generated at 2022-06-12 21:35:29.459771
# Unit test for constructor of class PlayIterator
def test_PlayIterator():
    module_loader.add_directory(C.DEFAULT_MODULE_PATH)
    play = Play().load(dict(
        name = 'foobar play',
        hosts = 'all',
        gather_facts = 'no',
        tasks = [
            dict(action=dict(module='shell', args='ls')),
        ]
    ), variable_manager=VariableManager(), loader=DataLoader())
    play._included_roles=['test_role']
    play._role_names=['test_role']
    host_list = [Host(name='foo')]
    inventory = Inventory(loader=DataLoader())
    inventory.add_host(host=host_list[0])
    play_iterator = PlayIterator(inventory=inventory, play=play, play_context=PlayContext(), all_vars=dict())
    assert play_

# Generated at 2022-06-12 21:35:30.725669
# Unit test for method add_tasks of class PlayIterator
def test_PlayIterator_add_tasks():
  pass


# Generated at 2022-06-12 21:35:42.803148
# Unit test for method is_failed of class PlayIterator
def test_PlayIterator_is_failed():
    '''
    Unit test for method is_failed of class PlayIterator
    '''
    # Create the Ansible inventory
    # Create a simple inventory with one host and two groups
    inventory = Inventory(ssl_verify=False)
    host1 = Host('testserver1', groups=['localservers', 'all'])
    inventory.add_host(host1)
    group1 = Group('localservers')
    group1.add_host('testserver1')
    group2 = Group('all')
    group2.add_host('testserver1')
    inventory.add_group(group1)
    inventory.add_group(group2)
    # Create a simple task list so that we have something to iterate

# Generated at 2022-06-12 21:38:01.878490
# Unit test for method mark_host_failed of class PlayIterator

# Generated at 2022-06-12 21:38:02.873263
# Unit test for method get_host_state of class PlayIterator
def test_PlayIterator_get_host_state():
    pass


# Generated at 2022-06-12 21:38:10.768604
# Unit test for method is_any_block_rescuing of class PlayIterator
def test_PlayIterator_is_any_block_rescuing():
    p = Play().load('/dev/null', variable_manager=VariableManager(), loader=DictDataLoader())
    h = Host(name='foo')
    p_i = PlayIterator(p, None)
    p_i._host_states[h.name] = HostState(blocks=[])
    p_i._host_states[h.name]._blocks.append(Block(rescue=[], always=[]))
    p_i._host_states[h.name]._blocks[0].block = [
        CallbackModule(),
        CallbackModule(),
    ]
    assert False == p_i.is_any_block_rescuing(p_i.get_host_state(h))
    p_i._host_states[h.name].run_state = p_i.ITERATING_RESCUE

# Generated at 2022-06-12 21:38:19.569704
# Unit test for constructor of class PlayIterator
def test_PlayIterator():
    fake_play_source = dict(
        name = "foobar test play",
        hosts = "testhost",
        gather_facts = "no",
        pre_tasks = [],
        roles = [],
        post_tasks = [],
        tasks = [],
    )

    fake_play = Play().load(fake_play_source, variable_manager=VariableManager(), loader=DictDataLoader())
    assert fake_play

    fake_inventory = Inventory(loader=None, variable_manager=VariableManager(), host_list=['localhost', 'otherhost'])

    pi = PlayIterator(inventory=fake_inventory, play=fake_play, play_context=PlayContext(), all_vars=dict())

    host = fake_inventory.get_host("testhost")
    assert 'gather_facts' not in pi._dependent_

# Generated at 2022-06-12 21:38:22.397964
# Unit test for method add_tasks of class PlayIterator
def test_PlayIterator_add_tasks():
    host = MagicMock()
    task_list = []
    play_iterator = PlayIterator()
    play_iterator.add_tasks(host, task_list)

# Generated at 2022-06-12 21:38:31.700760
# Unit test for method get_host_state of class PlayIterator
def test_PlayIterator_get_host_state():
    '''
    Unit test for method get_host_state of class PlayIterator
    '''

    # create the Play
    play = Play()

    # create the PlayIterator and set the play
    play_iterator = PlayIterator()
    play_iterator._play = play

    # create the Host with a name
    host = Host(name="test_host")

    # initialize the host_states variable
    play_iterator._host_states = dict()

    # create a Block and append it to the play
    block1 = Block(play=play)
    play.block.block.append(block1)

    # create a Mock and append it to the Block
    task1 = Mock()
    block1.block.append(task1)

    # create a Mock and append it to the Block
    task2 = Mock()
    block1.block.append

# Generated at 2022-06-12 21:38:37.802362
# Unit test for method is_failed of class PlayIterator
def test_PlayIterator_is_failed():

    # Imports needed for the method
    import ansible.playbook
    import ansible.playbook.play
    import ansible.playbook.play_context
    import ansible.playbook.task
    import ansible.playbook.task_include
    import ansible.playbook.role
    import ansible.playbook.block
    import ansible.inventory.host
    import ansible.vars.manager


    # Create a new instance of the PlayIterator class
    play_iterator_obj = PlayIterator()

    # Testing if the instance created is an object of the correct class
    assert isinstance(play_iterator_obj, PlayIterator) is True, "Instance is not an object of class 'PlayIterator'"

    # Create a new instance of the PlayContext class
    play_context_obj = ansible.playbook.play_context.Play

# Generated at 2022-06-12 21:38:45.786987
# Unit test for method get_original_task of class PlayIterator
def test_PlayIterator_get_original_task():

    from ansible.playbook.play import Play
    from ansible.playbook.task import Task
    from ansible.playbook.hosts import Hosts

    my_play = Play()
    my_play.hosts = Hosts()
    my_play.hosts.pattern = 'all'
    my_play.name = 'Test Play'

    my_task_1 = Task()
    my_task_1.name = 'My first task'

    my_task_2 = Task()
    my_task_2.name = 'My second task'

    my_play.tasks = [my_task_1, my_task_2]

    my_play_iterator = my_play.iterator


# Generated at 2022-06-12 21:38:51.321136
# Unit test for method is_any_block_rescuing of class PlayIterator
def test_PlayIterator_is_any_block_rescuing():
    '''
    PlayIterator._check_failed_state unit test stub
    '''
    # all of the cases where this should return true are handled above,
    # so we just need to test the false cases.
    #
    # first, a case where there are no blocks to iterate over
    state = HostState()
    assert not PlayIterator(None, None).is_any_block_rescuing(state)
    #
    # Now a case where there is a block to iterate over, but we are in the regular
    # task phase, so the answer is false
    state = HostState(blocks=[Block()])
    assert not PlayIterator(None, None).is_any_block_rescuing(state)
    #
    # now a case where we're iterating rescue, so the answer should be true

# Generated at 2022-06-12 21:38:52.233117
# Unit test for method __str__ of class HostState
def test_HostState___str__():
    hs = HostState([])
    hs._blocks = [1,2]
    print(hs)