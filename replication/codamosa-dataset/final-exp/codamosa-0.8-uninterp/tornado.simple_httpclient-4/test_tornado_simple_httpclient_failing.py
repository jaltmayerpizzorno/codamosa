# Automatically generated by Pynguin.
import socket as module_0
import tornado.httpclient as module_1
import tornado.tcpclient as module_2
import tornado.simple_httpclient as module_3
import tornado.ioloop as module_4
import tornado.iostream as module_5
import tornado.http1connection as module_6
import tornado.httputil as module_7
import concurrent.futures._base as module_8
import tornado.netutil as module_9

def test_case_0():
    try:
        str_0 = 'Mp%&]:}P)h_B;Lx*'
        int_0 = -3610
        address_family_0 = module_0.AddressFamily.AF_VSOCK
        list_0 = [str_0, str_0, address_family_0, int_0]
        str_1 = 'hbQ:r23#^=RK5O,&8Pa'
        float_0 = -2042.865674
        bool_0 = None
        bool_1 = None
        s_s_l_context_0 = None
        h_t_t_p_request_0 = module_1.HTTPRequest(str_1, str_1, float_0, str_1, str_0, str_0, bool_0, bool_1, bool_0, bool_1, s_s_l_context_0)
        callable_0 = None
        str_2 = 'Gwur$'
        int_1 = 403
        t_c_p_client_0 = module_2.TCPClient()
        int_2 = 350
        h_t_t_p_connection_0 = module_3._HTTPConnection(list_0, h_t_t_p_request_0, callable_0, str_2, int_1, t_c_p_client_0, int_0, int_2)
    except BaseException:
        pass

def test_case_1():
    try:
        i_o_loop_0 = module_4.IOLoop()
        int_0 = 399
        tuple_0 = i_o_loop_0.split_fd(int_0)
        simple_async_h_t_t_p_client_0 = module_3.SimpleAsyncHTTPClient()
        var_0 = lambda response: print(response)
        str_0 = 'g1V[@|Qi5=ZEM'
        str_1 = '3WJ;'
        h_t_t_p_stream_closed_error_0 = module_3.HTTPStreamClosedError(str_1)
        str_2 = h_t_t_p_stream_closed_error_0.__str__()
        int_1 = -2525
        simple_async_h_t_t_p_client_0.initialize(int_1)
        str_3 = 'vaOQ0\t?Ns[Y'
        address_family_0 = module_0.AddressFamily.AF_WANPIPE
        i_o_loop_0.stop()
        h_t_t_p_request_0 = module_1.HTTPRequest(str_3, str_0, str_1, str_2, int_1, address_family_0, int_1, str_0)
        str_4 = 'Z4\n]U1(8KTNF@Lp-2>d9'
        bool_0 = True
        socket_0 = module_0.socket(bool_0)
        i_o_stream_0 = module_5.IOStream(socket_0)
        bool_1 = False
        h_t_t_p1_connection_0 = module_6.HTTP1Connection(i_o_stream_0, bool_1)
        t_c_p_client_0 = module_2.TCPClient()
        h_t_t_p_connection_0 = module_3._HTTPConnection(simple_async_h_t_t_p_client_0, h_t_t_p_request_0, str_4, h_t_t_p1_connection_0, int_1, t_c_p_client_0, int_1, int_1)
        h_t_t_p_connection_0.on_connection_close()
    except BaseException:
        pass

def test_case_2():
    try:
        i_o_loop_0 = module_4.IOLoop()
        simple_async_h_t_t_p_client_0 = module_3.SimpleAsyncHTTPClient()
        var_0 = lambda response: print(response)
        str_0 = 'g1[|Qi5=Z'
        h_t_t_p_stream_closed_error_0 = module_3.HTTPStreamClosedError(str_0)
        str_1 = 'vaOQ0\t?Ns[Y'
        str_2 = 'Z4\n]U1(8KTNF@Lp-2>d9'
        bool_0 = True
        socket_0 = module_0.socket(bool_0)
        str_3 = h_t_t_p_stream_closed_error_0.__str__()
        h_t_t_p_stream_closed_error_1 = module_3.HTTPStreamClosedError(str_3)
        h_t_t_p_stream_closed_error_2 = module_3.HTTPStreamClosedError(str_1)
        str_4 = "Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.\n\n        Implementation notes: Reads and writes have a fast path and a\n        slow path.  The fast path reads synchronously from socket\n        buffers, while the slow path uses `_add_io_state` to schedule\n        an IOLoop callback.\n\n        To detect closed connections, we must have called\n        `_add_io_state` at some point, but we want to delay this as\n        much as possible so we don't have to set an `IOLoop.ERROR`\n        listener that will be overwritten by the next slow-path\n        operation. If a sequence of fast-path ops do not end in a\n        slow-path op, (e.g. for an @asynchronous long-poll request),\n        we must add the error handler.\n\n        TODO: reevaluate this now that callbacks are gone.\n\n        "
        simple_async_h_t_t_p_client_0.close()
        h_t_t_p_request_0 = module_1.HTTPRequest(str_4, str_0, str_3, str_0, str_3, str_0, str_2, bool_0, bool_0)
        h_t_t_p_headers_0 = module_7.HTTPHeaders()
        iterator_0 = h_t_t_p_headers_0.__iter__()
        future_0 = module_8.Future()
        int_0 = -3343
        t_c_p_client_0 = module_2.TCPClient()
        h_t_t_p_connection_0 = module_3._HTTPConnection(simple_async_h_t_t_p_client_0, h_t_t_p_request_0, iterator_0, future_0, int_0, t_c_p_client_0, int_0, int_0)
        h_t_t_p_connection_0.finish()
    except BaseException:
        pass

def test_case_3():
    try:
        i_o_loop_0 = module_4.IOLoop()
        simple_async_h_t_t_p_client_0 = module_3.SimpleAsyncHTTPClient()
        simple_async_h_t_t_p_client_0.close()
        var_0 = lambda response: print(response)
        str_0 = '3WJ;'
        h_t_t_p_stream_closed_error_0 = module_3.HTTPStreamClosedError(str_0)
        str_1 = h_t_t_p_stream_closed_error_0.__str__()
        h_t_t_p_timeout_error_0 = module_3.HTTPTimeoutError(str_1)
        str_2 = h_t_t_p_stream_closed_error_0.__str__()
        str_3 = 'Ef\t@7h#g:Fpi\n'
        str_4 = 'tornado.simple_httpclient'
        h_t_t_p_stream_closed_error_1 = module_3.HTTPStreamClosedError(str_4)
        str_5 = 'dDh|0U7Zxd\npp]#{'
        bool_0 = False
        simple_async_h_t_t_p_client_0.close()
        h_t_t_p_request_0 = module_1.HTTPRequest(str_4, str_5, str_2, str_3, str_4, str_3, str_1, bool_0, bool_0)
        dict_0 = {}
        simple_async_h_t_t_p_client_0.fetch_impl(h_t_t_p_request_0, dict_0)
        int_0 = -2949
        resolver_0 = module_9.Resolver(**dict_0)
        t_c_p_client_0 = module_2.TCPClient()
        dict_1 = None
        simple_async_h_t_t_p_client_0.initialize(resolver_0, dict_1, int_0, int_0)
        callable_0 = None
        t_c_p_client_1 = None
        int_1 = 1566
        h_t_t_p_connection_0 = module_3._HTTPConnection(simple_async_h_t_t_p_client_0, h_t_t_p_request_0, callable_0, resolver_0, int_0, t_c_p_client_1, int_0, int_1)
        h_t_t_p_connection_0.finish()
    except BaseException:
        pass

def test_case_4():
    try:
        i_o_loop_0 = module_4.IOLoop()
        simple_async_h_t_t_p_client_0 = module_3.SimpleAsyncHTTPClient()
        simple_async_h_t_t_p_client_0.close()
        var_0 = lambda response: print(response)
        str_0 = 'Override to enable support for allowing alternate origins.\n\n        The ``origin`` argument is the value of the ``Origin`` HTTP\n        header, the url responsible for initiating this request.  This\n        method is not called for clients that do not send this header;\n        such requests are always allowed (because all browsers that\n        implement WebSockets support this header, and non-browser\n        clients do not have the same cross-site security concerns).\n\n        Should return ``True`` to accept the request or ``False`` to\n        reject it. By default, rejects all requests with an origin on\n        a host other than this one.\n\n        This is a security protection against cross site scripting attacks on\n        browsers, since WebSockets are allowed to bypass the usual same-origin\n        policies and don\'t use CORS headers.\n\n        .. warning::\n\n           This is an important security measure; don\'t disable it\n           without understanding the security implications. In\n           particular, if your authentication is cookie-based, you\n           must either restrict the origins allowed by\n           ``check_origin()`` or implement your own XSRF-like\n           protection for websocket connections. See `these\n           <https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html>`_\n           `articles\n           <https://devcenter.heroku.com/articles/websocket-security>`_\n           for more.\n\n        To accept all cross-origin traffic (which was the default prior to\n        Tornado 4.0), simply override this method to always return ``True``::\n\n            def check_origin(self, origin):\n                return True\n\n        To allow connections from any subdomain of your site, you might\n        do something like::\n\n            def check_origin(self, origin):\n                parsed_origin = urllib.parse.urlparse(origin)\n                return parsed_origin.netloc.endswith(".mydomain.com")\n\n        .. versionadded:: 4.0\n\n        '
        int_0 = -2002
        future_0 = module_8.Future()
        dict_0 = {str_0: int_0}
        simple_async_h_t_t_p_client_0.initialize(int_0, future_0, dict_0, int_0)
        str_1 = '3WJ;'
        h_t_t_p_stream_closed_error_0 = module_3.HTTPStreamClosedError(str_1)
        str_2 = h_t_t_p_stream_closed_error_0.__str__()
        h_t_t_p_timeout_error_0 = module_3.HTTPTimeoutError(str_2)
        str_3 = h_t_t_p_stream_closed_error_0.__str__()
        str_4 = 'tornado.simple_httpclient'
        str_5 = 'dDh|0U7Zxd\npp]#{'
        bool_0 = False
        simple_async_h_t_t_p_client_0.close()
        h_t_t_p_request_0 = module_1.HTTPRequest(str_4, str_5, str_3, str_0, str_4, str_0, str_2, bool_0, bool_0)
        dict_1 = {}
        simple_async_h_t_t_p_client_0.fetch_impl(h_t_t_p_request_0, dict_1)
        str_6 = 'tornado.simple_httpclient'
        int_1 = -2949
        address_family_0 = module_0.AddressFamily.AF_ALG
        resolver_0 = module_9.Resolver(**dict_1)
        awaitable_0 = resolver_0.resolve(str_6, int_1, address_family_0)
        future_1 = module_8.Future()
        int_2 = -3337
        callable_0 = None
        t_c_p_client_0 = None
        h_t_t_p_connection_0 = module_3._HTTPConnection(simple_async_h_t_t_p_client_0, h_t_t_p_request_0, callable_0, resolver_0, int_1, t_c_p_client_0, int_1, int_2)
        h_t_t_p_connection_0.finish()
    except BaseException:
        pass

def test_case_5():
    try:
        i_o_loop_0 = module_4.IOLoop()
        simple_async_h_t_t_p_client_0 = module_3.SimpleAsyncHTTPClient()
        simple_async_h_t_t_p_client_0.close()
        var_0 = lambda response: print(response)
        str_0 = 'Override to enable support for allowing alternate origins.\n\n        The ``origin`` argument is the value of the ``Origin`` HTTP\n        header, the url responsible for initiating this request.  This\n        method is not called for clients that do not send this header;\n        such requests are always allowed (because all browsers that\n        implement WebSockets support this header, and non-browser\n        clients do not have the same cross-site security concerns).\n\n        Should return ``True`` to accept the request or ``False`` to\n        reject it. By default, rejects all requests with an origin on\n        a host other than this one.\n\n        This is a security protection against cross site scripting attacks on\n        browsers, since WebSockets are allowed to bypass the usual same-origin\n        policies and don\'t use CORS headers.\n\n        .. warning::\n\n           This is an important security measure; don\'t disable it\n           without understanding the security implications. In\n           particular, if your authentication is cookie-based, you\n           must either restrict the origins allowed by\n           ``check_origin()`` or implement your own XSRF-like\n           protection for websocket connections. See `these\n           <https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html>`_\n           `articles\n           <https://devcenter.heroku.com/articles/websocket-security>`_\n           for more.\n\n        To accept all cross-origin traffic (which was the default prior to\n        Tornado 4.0), simply override this method to always return ``True``::\n\n            def check_origin(self, origin):\n                return True\n\n        To allow connections from any subdomain of your site, you might\n        do something like::\n\n            def check_origin(self, origin):\n                parsed_origin = urllib.parse.urlparse(origin)\n                return parsed_origin.netloc.endswith(".mydomain.com")\n\n        .. versionadded:: 4.0\n\n        '
        int_0 = -2002
        future_0 = module_8.Future()
        dict_0 = {str_0: int_0}
        simple_async_h_t_t_p_client_0.initialize(int_0, future_0, dict_0, int_0)
        str_1 = '3WJ;'
        h_t_t_p_stream_closed_error_0 = module_3.HTTPStreamClosedError(str_1)
        str_2 = h_t_t_p_stream_closed_error_0.__str__()
        h_t_t_p_timeout_error_0 = module_3.HTTPTimeoutError(str_2)
        str_3 = h_t_t_p_stream_closed_error_0.__str__()
        str_4 = 'tornado.simple_httpclient'
        str_5 = 'dDh|0U7Zxd\npp]#{'
        bool_0 = True
        simple_async_h_t_t_p_client_0.close()
        h_t_t_p_request_0 = module_1.HTTPRequest(str_4, str_5, str_3, str_0, str_4, str_0, str_2, bool_0, bool_0)
        dict_1 = {}
        simple_async_h_t_t_p_client_0.fetch_impl(h_t_t_p_request_0, dict_1)
        list_0 = []
        int_1 = -2949
        address_family_0 = module_0.AddressFamily.AF_ALG
        resolver_0 = module_9.Resolver(**dict_1)
        awaitable_0 = resolver_0.resolve(str_0, int_1, address_family_0)
        h_t_t_p_headers_0 = module_7.HTTPHeaders(*list_0)
        future_1 = module_8.Future()
        int_2 = -3337
        callable_0 = None
        t_c_p_client_0 = None
        h_t_t_p_connection_0 = module_3._HTTPConnection(simple_async_h_t_t_p_client_0, h_t_t_p_request_0, callable_0, resolver_0, int_1, t_c_p_client_0, int_1, int_2)
        h_t_t_p_connection_0.finish()
    except BaseException:
        pass