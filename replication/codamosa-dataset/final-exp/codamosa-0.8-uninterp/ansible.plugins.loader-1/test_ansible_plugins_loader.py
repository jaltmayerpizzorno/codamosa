# Automatically generated by Pynguin.
import ansible.plugins.loader as module_0

def test_case_0():
    pass

def test_case_1():
    str_0 = '\n---\nmodule: yum\nversion_added: historical\nshort_description: Manages packages with the I(yum) package manager\ndescription:\n     - Installs, upgrade, downgrades, removes, and lists packages and groups with the I(yum) package manager.\n     - This module only works on Python 2. If you require Python 3 support see the M(ansible.builtin.dnf) module.\noptions:\n  use_backend:\n    description:\n      - This module supports C(yum) (as it always has), this is known as C(yum3)/C(YUM3)/C(yum-deprecated) by\n        upstream yum developers. As of Ansible 2.7+, this module also supports C(YUM4), which is the\n        "new yum" and it has an C(dnf) backend.\n      - By default, this module will select the backend based on the C(ansible_pkg_mgr) fact.\n    default: "auto"\n    choices: [ auto, yum, yum4, dnf ]\n    type: str\n    version_added: "2.7"\n  name:\n    description:\n      - A package name or package specifier with version, like C(name-1.0).\n      - Comparison operators for package version are valid here C(>), C(<), C(>=), C(<=). Example - C(name>=1.0)\n      - If a previous version is specified, the task also needs to turn C(allow_downgrade) on.\n        See the C(allow_downgrade) documentation for caveats with downgrading packages.\n      - When using state=latest, this can be C(\'*\') which means run C(yum -y update).\n      - You can also pass a url or a local path to a rpm file (using state=present).\n        To operate on several packages this can accept a comma separated string of packages or (as of 2.0) a list of packages.\n    aliases: [ pkg ]\n    type: list\n    elements: str\n  exclude:\n    description:\n      - Package name(s) to exclude when state=present, or latest\n    type: list\n    elements: str\n    version_added: "2.0"\n  list:\n    description:\n      - "Package name to run the equivalent of yum list --show-duplicates <package> against. In addition to listing packages,\n        use can also list the following: C(installed), C(updates), C(available) and C(repos)."\n      - This parameter is mutually exclusive with C(name).\n    type: str\n  state:\n    description:\n      - Whether to install (C(present) or C(installed), C(latest)), or remove (C(absent) or C(removed)) a package.\n      - C(present) and C(installed) will simply ensure that a desired package is installed.\n      - C(latest) will update the specified package if it\'s not of the latest available version.\n      - C(absent) and C(removed) will remove the specified package.\n      - Default is C(None), however in effect the default action is C(present) unless the C(autoremove) option is\n        enabled for this module, then C(absent) is inferred.\n    type: str\n    choices: [ absent, installed, latest, present, removed ]\n  enablerepo:\n    description:\n      - I(Repoid) of repositories to enable for the install/update operation.\n        These repos will not persist beyond the transaction.\n        When specifying multiple repos, separate them with a C(",").\n      - As of Ansible 2.7, this can alternatively be a list instead of C(",")\n        separated string\n    type: list\n    elements: str\n    version_added: "0.9"\n  disablerepo:\n    description:\n      - I(Repoid) of repositories to disable for the install/update operation.\n        These repos will not persist beyond the transaction.\n        When specifying multiple repos, separate them with a C(",").\n      - As of Ansible 2.7, this can alternatively be a list instead of C(",")\n        separated string\n    type: list\n    elements: str\n    version_added: "0.9"\n  conf_file:\n    description:\n      - The remote yum configuration file to use for the transaction.\n    type: str\n    version_added: "0.6"\n  disable_gpg_check:\n    description:\n      - Whether to disable the GPG checking of signatures of packages being\n        installed. Has an effect only if state is I(present) or I(latest).\n    type: bool\n    default: "no"\n    version_added: "1.2"\n  skip_broken:\n    description:\n      - Skip all unavailable packages or packages with broken dependencies\n        without raising an error. Equivalent to passing the --skip-broken option.\n    type: bool\n    default: "no"\n    version_added: "2.3"\n  update_cache:\n    description:\n      - Force yum to check if cache is out of date and redownload if needed.\n        Has an effect only if state is I(present) or I(latest).\n    type: bool\n    default: "no"\n    aliases: [ expire-cache ]\n    version_added: "1.9"\n  validate_certs:\n    description:\n      - This only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to C(no), the SSL certificates will not be validated.\n      - This should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.\n      - Prior to 2.1 the code worked as if this was set to C(yes).\n    type: bool\n    default: "yes"\n    version_added: "2.1"\n\n  update_only:\n    description:\n      - When using latest, only update installed packages. Do not install packages.\n      - Has an effect only if state is I(latest)\n    default: "no"\n    type: bool\n    version_added: "2.5"\n\n  installroot:\n    description:\n      - Specifies an alternative installroot, relative to which all packages\n        will be installed.\n    default: "/"\n    type: str\n    version_added: "2.3"\n  security:\n    description:\n      - If set to C(yes), and C(state=latest) then only installs updates that have been marked security related.\n    type: bool\n    default: "no"\n    version_added: "2.4"\n  bugfix:\n    description:\n      - If set to C(yes), and C(state=latest) then only installs updates that have been marked bugfix related.\n    default: "no"\n    type: bool\n    version_added: "2.6"\n  allow_downgrade:\n    description:\n      - Specify if the named package and version is allowed to downgrade\n        a maybe already installed higher version of that package.\n        Note that setting allow_downgrade=True can make this module\n        behave in a non-idempotent way. The task could end up with a set\n        of packages that does not match the complete list of specified\n        packages to install (because dependencies between the downgraded\n        package and others can cause changes to the packages which were\n        in the earlier transaction).\n    type: bool\n    default: "no"\n    version_added: "2.4"\n  enable_plugin:\n    description:\n      - I(Plugin) name to enable for the install/update operation.\n        The enabled plugin will not persist beyond the transaction.\n    type: list\n    elements: str\n    version_added: "2.5"\n  disable_plugin:\n    description:\n      - I(Plugin) name to disable for the install/update operation.\n        The disabled plugins will not persist beyond the transaction.\n    type: list\n    elements: str\n    version_added: "2.5"\n  releasever:\n    description:\n      - Specifies an alternative release from which all packages will be\n        installed.\n    type: str\n    version_added: "2.7"\n  autoremove:\n    description:\n      - If C(yes), removes all "leaf" packages from the system that were originally\n        installed as dependencies of user-installed packages but which are no longer\n        required by any such package. Should be used alone or when state is I(absent)\n      - "NOTE: This feature requires yum >= 3.4.3 (RHEL/CentOS 7+)"\n    type: bool\n    default: "no"\n    version_added: "2.7"\n  disable_excludes:\n    description:\n      - Disable the excludes defined in YUM config files.\n      - If set to C(all), disables all excludes.\n      - If set to C(main), disable excludes defined in [main] in yum.conf.\n      - If set to C(repoid), disable excludes defined for given repo id.\n    type: str\n    version_added: "2.7"\n  download_only:\n    description:\n      - Only download the packages, do not install them.\n    default: "no"\n    type: bool\n    version_added: "2.7"\n  lock_timeout:\n    description:\n      - Amount of time to wait for the yum lockfile to be freed.\n    required: false\n    default: 30\n    type: int\n    version_added: "2.8"\n  install_weak_deps:\n    description:\n      - Will also install all packages linked by a weak dependency relation.\n      - "NOTE: This feature requires yum >= 4 (RHEL/CentOS 8+)"\n    type: bool\n    default: "yes"\n    version_added: "2.8"\n  download_dir:\n    description:\n      - Specifies an alternate directory to store packages.\n      - Has an effect only if I(download_only) is specified.\n    type: str\n    version_added: "2.8"\n  install_repoquery:\n    description:\n      - If repoquery is not available, install yum-utils. If the system is\n        registered to RHN or an RHN Satellite, repoquery allows for querying\n        all channels assigned to the system. It is also required to use the\n        \'list\' parameter.\n      - "NOTE: This will run and be logged as a separate yum transation which\n        takes place before any other installation or removal."\n      - "NOTE: This will use the system\'s default enabled repositories without\n        regard for disablerepo/enablerepo given to the module."\n    required: false\n    version_added: "1.5"\n    default: "yes"\n    type: bool\n  cacheonly:\n    description:\n      - Tells yum to run entirely from system cache; does not download or update metadata.\n    default: "no"\n    type: bool\n    version_added: "2.12"\nextends_documentation_fragment:\n- action_common_attributes\n- action_common_attributes.flow\nattributes:\n    action:\n        details: In the case of yum, it has 2 action plugins that use it under the hood, M(ansible.builtin.yum) and M(ansible.builtin.package).\n        support: partial\n    async:\n        support: none\n    bypass_host_loop:\n        support: none\n    check_mode:\n        support: full\n    diff_mode:\n        support: full\n    platform:\n        platforms: rhel\nnotes:\n  - When used with a `loop:` each package will be processed individually,\n    it is much more efficient to pass the list directly to the `name` option.\n  - In versions prior to 1.9.2 this module installed and removed each package\n    given to the yum module separately. This caused problems when packages\n    specified by filename or url had to be installed or removed together. In\n    1.9.2 this was fixed so that packages are installed in one yum\n    transaction. However, if one of the packages adds a new yum repository\n    that the other packages come from (such as epel-release) then that package\n    needs to be installed in a separate task. This mimics yum\'s command line\n    behaviour.\n  - \'Yum itself has two types of groups.  "Package groups" are specified in the\n    rpm itself while "environment groups" are specified in a separate file\n    (usually by the distribution).  Unfortunately, this division becomes\n    apparent to ansible users because ansible needs to operate on the group\n    of packages in a single transaction and yum requires groups to be specified\n    in different ways when used in that way.  Package groups are specified as\n    "@development-tools" and environment groups are "@^gnome-desktop-environment".\n    Use the "yum group list hidden ids" command to see which category of group the group\n    you want to install falls into.\'\n  - \'The yum module does not support clearing yum cache in an idempotent way, so it\n    was decided not to implement it, the only method is to use command and call the yum\n    command directly, namely "command: yum clean all"\n    https://github.com/ansible/ansible/pull/31450#issuecomment-352889579\'\n# informational: requirements for nodes\nrequirements:\n- yum\nauthor:\n    - Ansible Core Team\n    - Seth Vidal (@skvidal)\n    - Eduard Snesarev (@verm666)\n    - Berend De Schouwer (@berenddeschouwer)\n    - Abhijeet Kasurde (@Akasurde)\n    - Adam Miller (@maxamillion)\n'
    var_0 = module_0.add_all_plugin_dirs(str_0)

def test_case_2():
    dict_0 = {}
    bytes_0 = b'\x98\x0eT\x8e^'
    plugin_path_context_0 = module_0.PluginPathContext(dict_0, bytes_0)

def test_case_3():
    int_0 = 1527
    str_0 = 'hWz\noynx<\tTz)\tDJ49'
    plugin_load_context_0 = module_0.PluginLoadContext()
    plugin_path_context_0 = module_0.PluginPathContext(str_0, plugin_load_context_0)
    list_0 = []
    list_1 = [list_0]
    int_1 = 3264
    plugin_loader_0 = module_0.PluginLoader(plugin_path_context_0, list_0, str_0, list_1, int_1)
    var_0 = plugin_loader_0.has_plugin(int_0)

def test_case_4():
    bool_0 = True
    str_0 = 'L>\nn'
    str_1 = '^gEeLG'
    str_2 = 'Expected key=value host variable assignment, got: %s'
    plugin_load_context_0 = module_0.PluginLoadContext()
    bytes_0 = b''
    tuple_0 = (plugin_load_context_0, bytes_0)
    list_0 = [bytes_0]
    bool_1 = True
    plugin_loader_0 = module_0.PluginLoader(tuple_0, list_0, tuple_0, bool_1, tuple_0)
    plugin_path_context_0 = module_0.PluginPathContext(plugin_loader_0, bool_1)
    plugin_loader_1 = module_0.PluginLoader(str_0, str_1, str_2, plugin_path_context_0)
    var_0 = plugin_loader_1.has_plugin(bool_0, str_2)

def test_case_5():
    str_0 = '\tY5I%][xt"/M=d.PF,\n!'
    dict_0 = {}
    str_1 = 'yq8O;_'
    bool_0 = False
    plugin_loader_0 = module_0.PluginLoader(str_0, dict_0, str_1, bool_0, dict_0)
    var_0 = plugin_loader_0.print_paths()
    var_1 = module_0.get_all_plugin_loaders()

def test_case_6():
    str_0 = 'sh'
    var_0 = module_0.get_shell_plugin(str_0)
    var_1 = module_0.get_shell_plugin(str_0)
    var_2 = module_0.get_shell_plugin(str_0, str_0)

def test_case_7():
    plugin_load_context_0 = module_0.PluginLoadContext()
    var_0 = None
    str_0 = 'test_collection'
    var_1 = plugin_load_context_0.record_deprecation(str_0, var_0, str_0)
    str_1 = 'warning_text'
    str_2 = 'Test warning'
    str_3 = {str_1: str_2}
    var_2 = plugin_load_context_0.record_deprecation(str_1, str_3, str_0)
    var_3 = var_2.deprecated

def test_case_8():
    str_0 = ''
    str_1 = 'powerselloexe'
    var_0 = module_0.get_shell_plugin(str_0, str_1)

def test_case_9():
    str_0 = 'connection'
    var_0 = module_0.add_dirs_to_loader(str_0, str_0)

def test_case_10():
    str_0 = 'r#sNYMzfRXz\t;'
    str_1 = '1p:OJfwz'
    str_2 = 'KZ8,9fup.ug\x0bo'
    set_0 = {str_1, str_2}
    dict_0 = {str_0: str_0, str_1: set_0}
    float_0 = 486.42
    plugin_load_context_0 = module_0.PluginLoadContext()
    var_0 = plugin_load_context_0.resolve(str_0, str_1, dict_0, float_0)

def test_case_11():
    set_0 = None
    list_0 = [set_0, set_0, set_0]
    var_0 = module_0.get_all_plugin_loaders()
    str_0 = '>J,E#\x0b@Yh6K/]~D'
    float_0 = None
    bool_0 = False
    plugin_loader_0 = module_0.PluginLoader(float_0, set_0, bool_0, set_0, list_0)
    var_1 = plugin_loader_0.has_plugin(str_0)

def test_case_12():
    float_0 = 0.2
    float_1 = -789.745096
    float_2 = -314.98
    var_0 = module_0.get_all_plugin_loaders()
    str_0 = 't6)TV~$=XO;cnE<;'
    plugin_loader_0 = module_0.PluginLoader(float_0, float_1, float_2, str_0)
    str_1 = '>J,E#\x0b@Yh6K/]~D'
    var_1 = plugin_loader_0.has_plugin(str_1, str_1)

def test_case_13():
    set_0 = None
    str_0 = 'Searching %s for plugins'
    bytes_0 = b'\xf7\x05\x97\x9fQ<\xe1\xa57l-\xfcA\xa8t'
    bool_0 = True
    plugin_path_context_0 = module_0.PluginPathContext(str_0, bytes_0)
    bytes_1 = b'v\xf5\xea\x99\x14<W\xac\x89w\x16\xfd7\xee\xeb\xa9\xc3'
    dict_0 = {str_0: bool_0, bytes_1: set_0}
    var_0 = module_0.get_all_plugin_loaders()
    plugin_load_context_0 = module_0.PluginLoadContext()
    var_1 = module_0.add_all_plugin_dirs(plugin_path_context_0)
    var_2 = plugin_load_context_0.record_deprecation(plugin_load_context_0, dict_0, plugin_path_context_0)
    var_3 = module_0.add_all_plugin_dirs(bool_0)

def test_case_14():
    set_0 = None
    list_0 = [set_0, set_0, set_0]
    float_0 = None
    bool_0 = False
    str_0 = '1>r9H\tM/\nPto\n<'
    plugin_load_context_0 = module_0.PluginLoadContext()
    var_0 = module_0.add_all_plugin_dirs(str_0)
    int_0 = 44
    plugin_loader_0 = module_0.PluginLoader(float_0, set_0, bool_0, set_0, list_0)
    var_1 = plugin_loader_0.print_paths()
    str_1 = ';\nwbsC-'
    str_2 = '\\{eL4".mS\rAr'
    list_1 = [set_0]
    str_3 = 'V3LnO\tx3"7'
    plugin_loader_1 = module_0.PluginLoader(plugin_load_context_0, str_3, set_0, int_0)
    var_2 = plugin_loader_1.has_plugin(str_2, list_1)
    var_3 = plugin_loader_0.get(str_1)

def test_case_15():
    str_0 = ''
    set_0 = {str_0, str_0}
    float_0 = 100.0
    str_1 = 'Oracle Linux'
    dict_0 = {str_1: str_0, str_1: float_0, float_0: float_0, str_0: str_0}
    plugin_load_context_0 = module_0.PluginLoadContext()
    str_2 = '\nContext of the running Ansible.\n\nIn the future we *may* create Context objects to allow running multiple Ansible plays in parallel\nwith different contexts but that is currently out of scope as the Ansible library is just for\nrunning the ansible command line tools.\n\nThese APIs are still in flux so do not use them unless you are willing to update them with every Ansible release\n'
    dict_1 = {str_0: float_0, str_1: plugin_load_context_0, str_2: plugin_load_context_0}
    bool_0 = None
    tuple_0 = (str_1, dict_0, dict_1, bool_0)
    plugin_loader_0 = module_0.PluginLoader(float_0, float_0, tuple_0, float_0)
    var_0 = plugin_loader_0.has_plugin(set_0)
    str_3 = '/root/.ansible/plugins/doc_fragments/windows'
    var_1 = module_0.get_shell_plugin(str_0, str_3)

def test_case_16():
    str_0 = 'sh'
    var_0 = module_0.get_shell_plugin(str_0, str_0)

def test_case_17():
    str_0 = 'sh'
    var_0 = module_0.get_shell_plugin(str_0)

def test_case_18():
    str_0 = 'sh'
    var_0 = module_0.get_shell_plugin(str_0)
    str_1 = ''
    str_2 = 'powersell.exe'
    var_1 = module_0.get_shell_plugin(str_1, str_2)

def test_case_19():
    str_0 = 'sh'
    str_1 = ''
    var_0 = module_0.get_shell_plugin(str_1, str_0)

def test_case_20():
    str_0 = '/invalid/path'
    var_0 = module_0.add_all_plugin_dirs(str_0)
    str_1 = '.'
    var_1 = module_0.add_all_plugin_dirs(str_1)