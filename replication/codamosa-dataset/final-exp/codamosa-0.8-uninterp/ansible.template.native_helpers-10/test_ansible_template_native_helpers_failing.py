# Automatically generated by Pynguin.
import ansible.template.native_helpers as module_0
import jinja2.runtime as module_1
import ansible.utils.native_jinja as module_2

def test_case_0():
    try:
        dict_0 = {}
        var_0 = module_0.ansible_native_concat(dict_0)
        bool_0 = False
        bool_1 = True
        list_0 = [bool_1, dict_0]
        var_1 = module_0.ansible_native_concat(list_0)
        var_2 = module_0.ansible_native_concat(bool_0)
    except BaseException:
        pass

def test_case_1():
    try:
        tuple_0 = ()
        tuple_1 = (tuple_0,)
        var_0 = module_0.ansible_native_concat(tuple_1)
        str_0 = "\n    Walk a filesystem tree returning enough information to copy the files\n\n    :arg topdir: The directory that the filesystem tree is rooted at\n    :kwarg base_path: The initial directory structure to strip off of the\n        files for the destination directory.  If this is None (the default),\n        the base_path is set to ``top_dir``.\n    :kwarg local_follow: Whether to follow symlinks on the source.  When set\n        to False, no symlinks are dereferenced.  When set to True (the\n        default), the code will dereference most symlinks.  However, symlinks\n        can still be present if needed to break a circular link.\n    :kwarg trailing_slash_detector: Function to determine if a path has\n        a trailing directory separator. Only needed when dealing with paths on\n        a remote machine (in which case, pass in a function that is aware of the\n        directory separator conventions on the remote machine).\n    :returns: dictionary of tuples.  All of the path elements in the structure are text strings.\n            This separates all the files, directories, and symlinks along with\n            important information about each::\n\n                { 'files': [('/absolute/path/to/copy/from', 'relative/path/to/copy/to'), ...],\n                  'directories': [('/absolute/path/to/copy/from', 'relative/path/to/copy/to'), ...],\n                  'symlinks': [('/symlink/target/path', 'relative/path/to/copy/to'), ...],\n                }\n\n        The ``symlinks`` field is only populated if ``local_follow`` is set to False\n        *or* a circular symlink cannot be dereferenced.\n\n    "
        str_1 = ':~;uB"$'
        var_1 = module_0.ansible_native_concat(str_1)
        set_0 = {str_0, str_0, str_0, str_0}
        var_2 = module_0.ansible_native_concat(set_0)
        set_1 = None
        var_3 = module_0.ansible_native_concat(set_1)
    except BaseException:
        pass

def test_case_2():
    try:
        int_0 = None
        list_0 = [int_0]
        str_0 = 'pV\\PBsyi`#.\x0bEf?N]VUI'
        tuple_0 = (list_0, str_0)
        var_0 = module_0.ansible_native_concat(tuple_0)
    except BaseException:
        pass

def test_case_3():
    try:
        int_0 = None
        dict_0 = {int_0: int_0, int_0: int_0}
        var_0 = module_0.ansible_native_concat(dict_0)
        dict_1 = {int_0: int_0, int_0: int_0}
        bytes_0 = b'\xbb\xb65\r\xf3\x1d\x8e\x8b\x87\t\xc6x \xbe\xe5\xaf=7\x0bQ'
        tuple_0 = (bytes_0, dict_1)
        var_1 = module_0.ansible_native_concat(tuple_0)
        float_0 = 598.9668
        var_2 = module_0.ansible_native_concat(float_0)
    except BaseException:
        pass

def test_case_4():
    try:
        float_0 = 2870.601041
        var_0 = module_0.ansible_native_concat(float_0)
    except BaseException:
        pass

def test_case_5():
    try:
        set_0 = set()
        var_0 = module_0.ansible_native_concat(set_0)
        str_0 = '!`s>lpM'
        bytes_0 = b'\xd8}\xd1\xbf'
        var_1 = module_0.ansible_native_concat(bytes_0)
        var_2 = module_0.ansible_native_concat(str_0)
        list_0 = []
        var_3 = module_0.ansible_native_concat(list_0)
        var_4 = module_0.ansible_native_concat(set_0)
        int_0 = -1852
        var_5 = module_0.ansible_native_concat(int_0)
    except BaseException:
        pass

def test_case_6():
    try:
        str_0 = 'a'
        str_1 = 'b'
        str_2 = 'c'
        str_3 = [str_0, str_1, str_2]
        var_0 = module_0.ansible_native_concat(str_3)
        int_0 = 100
        var_1 = [int_0, str_1, str_2]
        var_2 = module_0.ansible_native_concat(var_1)
        bool_0 = True
        var_3 = [int_0, bool_0, str_2]
        var_4 = module_0.ansible_native_concat(var_3)
        var_5 = [int_0, bool_0, str_2]
        var_6 = module_0.ansible_native_concat(var_5)
        int_1 = [int_0]
        var_7 = module_0.ansible_native_concat(int_1)
        str_4 = [str_0]
        var_8 = module_0.ansible_native_concat(str_4)
        bool_1 = [bool_0]
        var_9 = module_0.ansible_native_concat(bool_1)
        float_0 = 1.1
        float_1 = [float_0]
        var_10 = module_0.ansible_native_concat(float_1)
        strict_undefined_0 = module_1.StrictUndefined()
        strict_undefined_1 = [strict_undefined_0]
        var_11 = module_0.ansible_native_concat(strict_undefined_1)
    except BaseException:
        pass

def test_case_7():
    try:
        native_jinja_text_0 = module_2.NativeJinjaText()
        set_0 = {native_jinja_text_0, native_jinja_text_0, native_jinja_text_0, native_jinja_text_0}
        var_0 = module_0.ansible_native_concat(set_0)
        str_0 = "P 7vr|'i\r5d"
        str_1 = "<D='4j9)=j"
        dict_0 = {str_0: set_0, str_1: var_0, str_0: set_0, str_0: str_1}
        var_1 = module_0.ansible_native_concat(dict_0)
        strict_undefined_0 = module_1.StrictUndefined(native_jinja_text_0)
        async_iterator_0 = strict_undefined_0.__aiter__()
        var_2 = module_0.ansible_native_concat(async_iterator_0)
    except BaseException:
        pass