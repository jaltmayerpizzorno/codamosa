# Automatically generated by Pynguin.
import ansible.parsing.yaml.objects as module_0

def test_case_0():
    pass

def test_case_1():
    bytes_0 = b'VR\x99Z\x98\xd9\x985~\x05\x99U\xf8\x01\xc1='
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)

def test_case_2():
    ansible_sequence_0 = module_0.AnsibleSequence()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_sequence_0)
    var_0 = ansible_vault_encrypted_unicode_0.isspace()

def test_case_3():
    bytes_0 = b'\xe5\xb3,\xa97_ \xaa<\xc5?\x80\x03\xe5D\xed\x98\xc0\xfe'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_0 = ansible_vault_encrypted_unicode_0.is_encrypted()

def test_case_4():
    str_0 = 'dJ.LlB]gJ'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.__eq__(ansible_vault_encrypted_unicode_0)

def test_case_5():
    float_0 = 739.863785616868
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(float_0)
    var_0 = ansible_vault_encrypted_unicode_0.__ne__(float_0)

def test_case_6():
    list_0 = []
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(list_0)
    var_0 = ansible_vault_encrypted_unicode_0.__reversed__()

def test_case_7():
    dict_0 = {}
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(dict_0)
    var_0 = ansible_vault_encrypted_unicode_0.__str__()

def test_case_8():
    ansible_mapping_0 = module_0.AnsibleMapping()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_mapping_0)
    var_0 = ansible_vault_encrypted_unicode_0.__repr__()

def test_case_9():
    float_0 = -398.27527
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(float_0)
    var_0 = ansible_vault_encrypted_unicode_0.__float__()

def test_case_10():
    bool_0 = True
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bool_0)
    var_0 = ansible_vault_encrypted_unicode_0.__hash__()

def test_case_11():
    int_0 = -283
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(int_0)
    var_0 = ansible_vault_encrypted_unicode_0.__len__()

def test_case_12():
    bytes_0 = b'\x02\xc7\xa7-\xd6dd\x1b\xc4\xad\xf2=\x84\x8bJ\x1a\x0b\xf7\x87'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_0 = bytes_0 + ansible_vault_encrypted_unicode_0

def test_case_13():
    dict_0 = {}
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(dict_0)
    var_0 = ansible_vault_encrypted_unicode_0.capitalize()

def test_case_14():
    str_0 = "['-3176.186', {'r:x\\rc7\\r': b'\\x9e\\xb8\\x99', 's': b'\\x9e\\xb8\\x99', '\\n&*': '\\n&*'}]"
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.casefold()

def test_case_15():
    list_0 = []
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(list_0)
    var_0 = ansible_vault_encrypted_unicode_0.expandtabs()

def test_case_16():
    str_0 = '.6Tr(Vy<U?O]qc'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.isascii()

def test_case_17():
    bytes_0 = b'\xa3Xj\x9f\x8et\xf6\x16\xd1G,N\x04\x9eNA'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_0 = ansible_vault_encrypted_unicode_0.isdecimal()

def test_case_18():
    bool_0 = True
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bool_0)
    var_0 = ansible_vault_encrypted_unicode_0.isdigit()

def test_case_19():
    str_0 = ':S-\x0cXx=yc=4#`D,<:'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.islower()

def test_case_20():
    ansible_unicode_0 = module_0.AnsibleUnicode()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_unicode_0)
    var_0 = ansible_vault_encrypted_unicode_0.isnumeric()

def test_case_21():
    dict_0 = {}
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(dict_0)
    var_0 = ansible_vault_encrypted_unicode_0.isupper()

def test_case_22():
    float_0 = -1815.7
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(float_0)
    var_0 = ansible_vault_encrypted_unicode_0.lower()

def test_case_23():
    bytes_0 = b'6\xfc\xccn\x03l5E\t\xe30'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    bool_0 = False
    var_0 = ansible_vault_encrypted_unicode_0.__add__(bool_0)
    bytes_1 = b'VR\x99Z\x98\xd9\x985~\x05\x99U\xf8\x01\xc1='
    ansible_vault_encrypted_unicode_1 = module_0.AnsibleVaultEncryptedUnicode(bytes_1)
    var_1 = ansible_vault_encrypted_unicode_0.replace(ansible_vault_encrypted_unicode_0, ansible_vault_encrypted_unicode_1)

def test_case_24():
    str_0 = ')k e>b'
    bytes_0 = b'\xca\x8a\xdd\xfa5\x88\x80\xa9\xcep\xae=;h'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_0 = ansible_vault_encrypted_unicode_0.rfind(str_0)

def test_case_25():
    str_0 = "8#t4]U*q'\t\x0b&az-5"
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.split()

def test_case_26():
    list_0 = []
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(list_0)
    var_0 = ansible_vault_encrypted_unicode_0.rsplit()

def test_case_27():
    bytes_0 = b'\xc3l\xd4\x10*\xa9\x8d\xb2?\xb2Ey\x04=L\x13\xdd\xe2Q'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_0 = ansible_vault_encrypted_unicode_0.splitlines()

def test_case_28():
    dict_0 = {}
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(dict_0)
    var_0 = ansible_vault_encrypted_unicode_0.strip()

def test_case_29():
    list_0 = []
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(list_0)
    var_0 = ansible_vault_encrypted_unicode_0.swapcase()

def test_case_30():
    float_0 = -434.570607
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(float_0)
    var_0 = ansible_vault_encrypted_unicode_0.title()

def test_case_31():
    ansible_sequence_0 = module_0.AnsibleSequence()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_sequence_0)
    var_0 = ansible_vault_encrypted_unicode_0.upper()

def test_case_32():
    bytes_0 = b'O\x07n\xa8\x0b8THJc\tH\xda\x03\x80z\xb1\x9c'
    str_0 = '%(shebang)s\n%(coding)s\n_ANSIBALLZ_WRAPPER = True # For test-module.py script to tell this is a ANSIBALLZ_WRAPPER\n# This code is part of Ansible, but is an independent component.\n# The code in this particular templatable string, and this templatable string\n# only, is BSD licensed.  Modules which end up using this snippet, which is\n# dynamically combined together by Ansible still belong to the author of the\n# module, and they may assign their own license to the complete work.\n#\n# Copyright (c), James Cammarata, 2016\n# Copyright (c), Toshio Kuratomi, 2016\n#\n# Redistribution and use in source and binary forms, with or without modification,\n# are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above copyright notice,\n#      this list of conditions and the following disclaimer in the documentation\n#      and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\ndef _ansiballz_main():\n    import os\n    import os.path\n\n    # Access to the working directory is required by Python when using pipelining, as well as for the coverage module.\n    # Some platforms, such as macOS, may not allow querying the working directory when using become to drop privileges.\n    try:\n        os.getcwd()\n    except OSError:\n        try:\n            os.chdir(os.path.expanduser(\'~\'))\n        except OSError:\n            os.chdir(\'/\')\n\n%(rlimit)s\n\n    import sys\n    import __main__\n\n    # For some distros and python versions we pick up this script in the temporary\n    # directory.  This leads to problems when the ansible module masks a python\n    # library that another import needs.  We have not figured out what about the\n    # specific distros and python versions causes this to behave differently.\n    #\n    # Tested distros:\n    # Fedora23 with python3.4  Works\n    # Ubuntu15.10 with python2.7  Works\n    # Ubuntu15.10 with python3.4  Fails without this\n    # Ubuntu16.04.1 with python3.5  Fails without this\n    # To test on another platform:\n    # * use the copy module (since this shadows the stdlib copy module)\n    # * Turn off pipelining\n    # * Make sure that the destination file does not exist\n    # * ansible ubuntu16-test -m copy -a \'src=/etc/motd dest=/var/tmp/m\'\n    # This will traceback in shutil.  Looking at the complete traceback will show\n    # that shutil is importing copy which finds the ansible module instead of the\n    # stdlib module\n    scriptdir = None\n    try:\n        scriptdir = os.path.dirname(os.path.realpath(__main__.__file__))\n    except (AttributeError, OSError):\n        # Some platforms don\'t set __file__ when reading from stdin\n        # OSX raises OSError if using abspath() in a directory we don\'t have\n        # permission to read (realpath calls abspath)\n        pass\n\n    # Strip cwd from sys.path to avoid potential permissions issues\n    excludes = set((\'\', \'.\', scriptdir))\n    sys.path = [p for p in sys.path if p not in excludes]\n\n    import base64\n    import runpy\n    import shutil\n    import tempfile\n    import zipfile\n\n    if sys.version_info < (3,):\n        PY3 = False\n    else:\n        PY3 = True\n\n    ZIPDATA = """%(zipdata)s"""\n\n    # Note: temp_path isn\'t needed once we switch to zipimport\n    def invoke_module(modlib_path, temp_path, json_params):\n        # When installed via setuptools (including python setup.py install),\n        # ansible may be installed with an easy-install.pth file.  That file\n        # may load the system-wide install of ansible rather than the one in\n        # the module.  sitecustomize is the only way to override that setting.\n        z = zipfile.ZipFile(modlib_path, mode=\'a\')\n\n        # py3: modlib_path will be text, py2: it\'s bytes.  Need bytes at the end\n        sitecustomize = u\'import sys\\nsys.path.insert(0,"%%s")\\n\' %%  modlib_path\n        sitecustomize = sitecustomize.encode(\'utf-8\')\n        # Use a ZipInfo to work around zipfile limitation on hosts with\n        # clocks set to a pre-1980 year (for instance, Raspberry Pi)\n        zinfo = zipfile.ZipInfo()\n        zinfo.filename = \'sitecustomize.py\'\n        zinfo.date_time = ( %(year)i, %(month)i, %(day)i, %(hour)i, %(minute)i, %(second)i)\n        z.writestr(zinfo, sitecustomize)\n        z.close()\n\n        # Put the zipped up module_utils we got from the controller first in the python path so that we\n        # can monkeypatch the right basic\n        sys.path.insert(0, modlib_path)\n\n        # Monkeypatch the parameters into basic\n        from ansible.module_utils import basic\n        basic._ANSIBLE_ARGS = json_params\n%(coverage)s\n        # Run the module!  By importing it as \'__main__\', it thinks it is executing as a script\n        runpy.run_module(mod_name=\'%(module_fqn)s\', init_globals=dict(_module_fqn=\'%(module_fqn)s\', _modlib_path=modlib_path),\n                         run_name=\'__main__\', alter_sys=True)\n\n        # Ansible modules must exit themselves\n        print(\'{"msg": "New-style module did not handle its own exit", "failed": true}\')\n        sys.exit(1)\n\n    def debug(command, zipped_mod, json_params):\n        # The code here normally doesn\'t run.  It\'s only used for debugging on the\n        # remote machine.\n        #\n        # The subcommands in this function make it easier to debug ansiballz\n        # modules.  Here\'s the basic steps:\n        #\n        # Run ansible with the environment variable: ANSIBLE_KEEP_REMOTE_FILES=1 and -vvv\n        # to save the module file remotely::\n        #   $ ANSIBLE_KEEP_REMOTE_FILES=1 ansible host1 -m ping -a \'data=october\' -vvv\n        #\n        # Part of the verbose output will tell you where on the remote machine the\n        # module was written to::\n        #   [...]\n        #   <host1> SSH: EXEC ssh -C -q -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o\n        #   PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o\n        #   ControlPath=/home/badger/.ansible/cp/ansible-ssh-%%h-%%p-%%r -tt rhel7 \'/bin/sh -c \'"\'"\'LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8\n        #   LC_MESSAGES=en_US.UTF-8 /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping\'"\'"\'\'\n        #   [...]\n        #\n        # Login to the remote machine and run the module file via from the previous\n        # step with the explode subcommand to extract the module payload into\n        # source files::\n        #   $ ssh host1\n        #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping explode\n        #   Module expanded into:\n        #   /home/badger/.ansible/tmp/ansible-tmp-1461173408.08-279692652635227/ansible\n        #\n        # You can now edit the source files to instrument the code or experiment with\n        # different parameter values.  When you\'re ready to run the code you\'ve modified\n        # (instead of the code from the actual zipped module), use the execute subcommand like this::\n        #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping execute\n\n        # Okay to use __file__ here because we\'re running from a kept file\n        basedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), \'debug_dir\')\n        args_path = os.path.join(basedir, \'args\')\n\n        if command == \'explode\':\n            # transform the ZIPDATA into an exploded directory of code and then\n            # print the path to the code.  This is an easy way for people to look\n            # at the code on the remote machine for debugging it in that\n            # environment\n            z = zipfile.ZipFile(zipped_mod)\n            for filename in z.namelist():\n                if filename.startswith(\'/\'):\n                    raise Exception(\'Something wrong with this module zip file: should not contain absolute paths\')\n\n                dest_filename = os.path.join(basedir, filename)\n                if dest_filename.endswith(os.path.sep) and not os.path.exists(dest_filename):\n                    os.makedirs(dest_filename)\n                else:\n                    directory = os.path.dirname(dest_filename)\n                    if not os.path.exists(directory):\n                        os.makedirs(directory)\n                    f = open(dest_filename, \'wb\')\n                    f.write(z.read(filename))\n                    f.close()\n\n            # write the args file\n            f = open(args_path, \'wb\')\n            f.write(json_params)\n            f.close()\n\n            print(\'Module expanded into:\')\n            print(\'%%s\' %% basedir)\n            exitcode = 0\n\n        elif command == \'execute\':\n            # Execute the exploded code instead of executing the module from the\n            # embedded ZIPDATA.  This allows people to easily run their modified\n            # code on the remote machine to see how changes will affect it.\n\n            # Set pythonpath to the debug dir\n            sys.path.insert(0, basedir)\n\n            # read in the args file which the user may have modified\n            with open(args_path, \'rb\') as f:\n                json_params = f.read()\n\n            # Monkeypatch the parameters into basic\n            from ansible.module_utils import basic\n            basic._ANSIBLE_ARGS = json_params\n\n            # Run the module!  By importing it as \'__main__\', it thinks it is executing as a script\n            runpy.run_module(mod_name=\'%(module_fqn)s\', init_globals=None, run_name=\'__main__\', alter_sys=True)\n\n            # Ansible modules must exit themselves\n            print(\'{"msg": "New-style module did not handle its own exit", "failed": true}\')\n            sys.exit(1)\n\n        else:\n            print(\'WARNING: Unknown debug command.  Doing nothing.\')\n            exitcode = 0\n\n        return exitcode\n\n    #\n    # See comments in the debug() method for information on debugging\n    #\n\n    ANSIBALLZ_PARAMS = %(params)s\n    if PY3:\n        ANSIBALLZ_PARAMS = ANSIBALLZ_PARAMS.encode(\'utf-8\')\n    try:\n        # There\'s a race condition with the controller removing the\n        # remote_tmpdir and this module executing under async.  So we cannot\n        # store this in remote_tmpdir (use system tempdir instead)\n        # Only need to use [ansible_module]_payload_ in the temp_path until we move to zipimport\n        # (this helps ansible-test produce coverage stats)\n        temp_path = tempfile.mkdtemp(prefix=\'ansible_%(ansible_module)s_payload_\')\n\n        zipped_mod = os.path.join(temp_path, \'ansible_%(ansible_module)s_payload.zip\')\n\n        with open(zipped_mod, \'wb\') as modlib:\n            modlib.write(base64.b64decode(ZIPDATA))\n\n        if len(sys.argv) == 2:\n            exitcode = debug(sys.argv[1], zipped_mod, ANSIBALLZ_PARAMS)\n        else:\n            # Note: temp_path isn\'t needed once we switch to zipimport\n            invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS)\n    finally:\n        try:\n            shutil.rmtree(temp_path)\n        except (NameError, OSError):\n            # tempdir creation probably failed\n            pass\n    sys.exit(exitcode)\n\nif __name__ == \'__main__\':\n    _ansiballz_main()\n'
    dict_0 = {str_0: bytes_0, str_0: bytes_0}
    ansible_sequence_0 = module_0.AnsibleSequence(**dict_0)
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_sequence_0)
    var_0 = ansible_vault_encrypted_unicode_0.rsplit()
    bool_0 = True
    var_1 = ansible_vault_encrypted_unicode_0.is_encrypted()
    ansible_vault_encrypted_unicode_1 = module_0.AnsibleVaultEncryptedUnicode(bool_0)
    ansible_vault_encrypted_unicode_2 = module_0.AnsibleVaultEncryptedUnicode(ansible_vault_encrypted_unicode_1)
    var_2 = ansible_vault_encrypted_unicode_1.is_encrypted()
    var_3 = ansible_vault_encrypted_unicode_0.__gt__(ansible_vault_encrypted_unicode_0)

def test_case_33():
    set_0 = set()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(set_0)
    var_0 = ansible_vault_encrypted_unicode_0.__unicode__()

def test_case_34():
    str_0 = 'dJ.LlB]gJ'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.count(str_0)

def test_case_35():
    bytes_0 = b'foo'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_0 = ansible_vault_encrypted_unicode_0 + bytes_0

def test_case_36():
    bytes_0 = b'foo'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_0 = ansible_vault_encrypted_unicode_0 + ansible_vault_encrypted_unicode_0

def test_case_37():
    str_0 = '88p}9f6?T_!~7y\x0cs'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.isalnum()

def test_case_38():
    ansible_mapping_0 = module_0.AnsibleMapping()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_mapping_0)
    var_0 = ansible_vault_encrypted_unicode_0.isprintable()

def test_case_39():
    float_0 = -1692.82
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(float_0)
    var_0 = ansible_vault_encrypted_unicode_0.istitle()

def test_case_40():
    tuple_0 = ()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(tuple_0)
    var_0 = ansible_vault_encrypted_unicode_0.format()

def test_case_41():
    ansible_mapping_0 = module_0.AnsibleMapping()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_mapping_0)
    var_0 = ansible_vault_encrypted_unicode_0.isalpha()

def test_case_42():
    ansible_base_y_a_m_l_object_0 = module_0.AnsibleBaseYAMLObject()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_base_y_a_m_l_object_0)
    var_0 = ansible_vault_encrypted_unicode_0.rstrip()

def test_case_43():
    str_0 = "roleK'%s' params"
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.__le__(str_0)

def test_case_44():
    bytes_0 = b'6\xfc\xccn\x03l5E\t\xe30'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    bool_0 = False
    var_0 = ansible_vault_encrypted_unicode_0.__hash__()
    var_1 = ansible_vault_encrypted_unicode_0.__add__(bool_0)
    bytes_1 = b"'\xee\x88\x13m()"
    var_2 = ansible_vault_encrypted_unicode_0.__repr__()
    ansible_vault_encrypted_unicode_1 = module_0.AnsibleVaultEncryptedUnicode(bytes_1)
    tuple_0 = (bool_0,)
    ansible_vault_encrypted_unicode_2 = module_0.AnsibleVaultEncryptedUnicode(tuple_0)
    var_3 = ansible_vault_encrypted_unicode_2.__le__(ansible_vault_encrypted_unicode_1)
    bool_1 = False
    var_4 = ansible_vault_encrypted_unicode_1.__ne__(bool_1)

def test_case_45():
    str_0 = 'AVEC'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    str_1 = 'AVEC2'
    ansible_vault_encrypted_unicode_1 = module_0.AnsibleVaultEncryptedUnicode(str_1)
    var_0 = ansible_vault_encrypted_unicode_0 + ansible_vault_encrypted_unicode_1
    var_1 = ansible_vault_encrypted_unicode_1 + ansible_vault_encrypted_unicode_0
    var_2 = ansible_vault_encrypted_unicode_0 + str_1

def test_case_46():
    ansible_base_y_a_m_l_object_0 = module_0.AnsibleBaseYAMLObject()
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_base_y_a_m_l_object_0)
    ansible_vault_encrypted_unicode_1 = module_0.AnsibleVaultEncryptedUnicode(ansible_vault_encrypted_unicode_0)
    ansible_mapping_0 = module_0.AnsibleMapping()
    list_0 = [ansible_mapping_0, ansible_mapping_0, ansible_mapping_0]
    ansible_vault_encrypted_unicode_2 = module_0.AnsibleVaultEncryptedUnicode(list_0)
    var_0 = ansible_vault_encrypted_unicode_2.find(ansible_vault_encrypted_unicode_1)
    var_1 = ansible_vault_encrypted_unicode_2.__eq__(ansible_vault_encrypted_unicode_2)
    str_0 = 'dJ.LlB]gJ'
    ansible_vault_encrypted_unicode_3 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_2 = ansible_vault_encrypted_unicode_3.count(str_0)

def test_case_47():
    bytes_0 = b'6\xfc\x8cn\x03l5E\t\xe30'
    str_0 = '5xYV'
    dict_0 = {str_0: bytes_0}
    ansible_mapping_0 = module_0.AnsibleMapping(**dict_0)
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(ansible_mapping_0)
    var_0 = ansible_vault_encrypted_unicode_0.rstrip()
    ansible_vault_encrypted_unicode_1 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    list_0 = [bytes_0]
    var_1 = ansible_vault_encrypted_unicode_1.isupper()
    var_2 = ansible_vault_encrypted_unicode_1.__eq__(bytes_0)
    ansible_vault_encrypted_unicode_2 = module_0.AnsibleVaultEncryptedUnicode(list_0)
    var_3 = ansible_vault_encrypted_unicode_2.splitlines()
    bool_0 = False
    var_4 = ansible_vault_encrypted_unicode_0.isascii()
    var_5 = ansible_vault_encrypted_unicode_1.__add__(bool_0)
    int_0 = -286
    ansible_mapping_1 = module_0.AnsibleMapping()
    ansible_vault_encrypted_unicode_3 = module_0.AnsibleVaultEncryptedUnicode(ansible_vault_encrypted_unicode_1)
    var_6 = ansible_vault_encrypted_unicode_3.__ne__(int_0)
    ansible_vault_encrypted_unicode_4 = module_0.AnsibleVaultEncryptedUnicode(bytes_0)
    var_7 = ansible_vault_encrypted_unicode_3.is_encrypted()
    var_8 = ansible_vault_encrypted_unicode_4.lower()
    ansible_sequence_0 = module_0.AnsibleSequence(*list_0)
    ansible_unicode_0 = module_0.AnsibleUnicode(*list_0)
    var_9 = ansible_vault_encrypted_unicode_2.rfind(ansible_vault_encrypted_unicode_1)

def test_case_48():
    str_0 = 'dJ.LlBgJ'
    ansible_vault_encrypted_unicode_0 = module_0.AnsibleVaultEncryptedUnicode(str_0)
    var_0 = ansible_vault_encrypted_unicode_0.count(ansible_vault_encrypted_unicode_0)