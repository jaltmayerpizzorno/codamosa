# Automatically generated by Pynguin.
import flutils.namedtupleutils as module_0
import collections as module_1
import types as module_2
import collections.abc as module_3

def test_case_0():
    try:
        var_0 = None
        var_1 = module_0.to_namedtuple(var_0)
    except BaseException:
        pass

def test_case_1():
    try:
        ordered_dict_0 = module_1.OrderedDict()
        var_0 = module_0.to_namedtuple(ordered_dict_0)
        str_0 = '\x0bzyC?\rW'
        var_1 = module_0.to_namedtuple(str_0)
    except BaseException:
        pass

def test_case_2():
    try:
        int_0 = 2925
        bool_0 = False
        tuple_0 = (bool_0,)
        var_0 = module_0.to_namedtuple(tuple_0)
        str_0 = 'Zr:/'
        list_0 = [int_0, str_0, str_0, int_0]
        dict_0 = {}
        simple_namespace_0 = module_2.SimpleNamespace(*list_0, **dict_0)
    except BaseException:
        pass

def test_case_3():
    try:
        int_0 = -1510
        list_0 = [int_0, int_0, int_0, int_0]
        var_0 = module_0.to_namedtuple(list_0)
        list_1 = [int_0]
        bytes_0 = b'\xc13'
        str_0 = None
        tuple_0 = (int_0, list_1, bytes_0, str_0)
        var_1 = module_0.to_namedtuple(tuple_0)
        list_2 = [bytes_0, bytes_0, bytes_0, bytes_0]
        var_2 = module_0.to_namedtuple(list_2)
        mapping_0 = module_3.Mapping()
    except BaseException:
        pass

def test_case_4():
    try:
        bytes_0 = b"-'\xbb\xd2"
        dict_0 = {bytes_0: bytes_0, bytes_0: bytes_0, bytes_0: bytes_0, bytes_0: bytes_0}
        dict_1 = {}
        str_0 = 'Using the passed in file descriptor (of tty), set the terminal\n    size to that of the current terminal size.  If the current\n    terminal size cannot be found the given defaults will be used.\n    '
        list_0 = []
        simple_namespace_0 = module_2.SimpleNamespace(*list_0)
        var_0 = module_0.to_namedtuple(simple_namespace_0)
        simple_namespace_1 = module_2.SimpleNamespace()
        ordered_dict_0 = module_1.OrderedDict(**dict_1)
        bool_0 = False
        bytes_1 = None
        tuple_0 = (simple_namespace_1, ordered_dict_0, bool_0, bytes_1)
        tuple_1 = (tuple_0,)
        tuple_2 = (dict_0, dict_1, str_0, tuple_1)
        var_1 = module_0.to_namedtuple(tuple_2)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = 'G50~\nS[LPG3?X\x0b=jE`d'
        dict_0 = {str_0: str_0}
        list_0 = [str_0]
        str_1 = 'chown'
        str_2 = '\rP7veUTNphD'
        dict_1 = {str_0: list_0, str_2: str_1}
        list_1 = [str_0, dict_1, str_1]
        var_0 = module_0.to_namedtuple(list_1)
        tuple_0 = (dict_0, list_0, str_1, dict_1)
        var_1 = module_0.to_namedtuple(tuple_0)
        set_0 = None
        set_1 = {set_0, set_0}
        float_0 = 1390.851
        str_3 = 'A simple callable that simplifies many calls to :obj:`subprocess.run`.\n\n    Args:\n        raise_error (bool, optional): A value of :obj:`True` will raise\n            a :obj:`ChildProcessError` if the process,\n            exits with a non-zero return code. Default: :obj:`True`\n        output_encoding (str, optional): If set, the returned ``stdout``\n            and ``stderr`` will be converted to from bytes to a Python\n            string using this given ``encoding``.  Defaults to:\n            :obj:`None` which will use the value from\n            :obj:`locale.getpreferredencoding` or, if not set, the value\n            from :obj:`sys.getdefaultencoding` will be used. If the given\n            encoding does NOT exist the default will be used.\n        **default_kwargs: Any :obj:`subprocess.Popen` keyword argument.\n\n    Attributes:\n        default_kwargs (:obj:`NamedTuple <typing.NamedTuple>`): The\n            ``default_kwargs`` passed into the constructor which may be\n            passed on to :obj:`subprocess.run`.\n        output_encoding (str): The encoding used to decode the process\n            output\n\n    '
        str_4 = '__attr_map__ must be a tuple not %r'
        str_5 = 'char device'
        list_2 = [str_5]
        var_2 = module_0.to_namedtuple(list_2)
        tuple_1 = ()
        var_3 = module_0.to_namedtuple(tuple_1)
        var_4 = module_0.to_namedtuple(tuple_1)
        dict_2 = {str_4: set_1, str_3: str_3, str_3: str_3, str_5: str_4}
        dict_3 = {str_3: str_4, set_0: str_5}
        tuple_2 = (float_0, str_3, dict_2, dict_3)
        var_5 = module_0.to_namedtuple(tuple_2)
    except BaseException:
        pass