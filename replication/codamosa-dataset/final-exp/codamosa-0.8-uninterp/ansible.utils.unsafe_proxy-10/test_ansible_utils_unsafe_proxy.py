# Automatically generated by Pynguin.
import ansible.utils.unsafe_proxy as module_0
import ansible.utils.native_jinja as module_1

def test_case_0():
    pass

def test_case_1():
    int_0 = -450
    set_0 = {int_0, int_0}
    list_0 = [set_0, int_0]
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0)

def test_case_2():
    set_0 = None
    var_0 = module_0.wrap_var(set_0)

def test_case_3():
    int_0 = -450
    var_0 = module_0.wrap_var(int_0)

def test_case_4():
    int_0 = -450
    set_0 = {int_0, int_0}
    list_0 = [set_0, int_0]
    var_0 = module_0.to_unsafe_text(*list_0)
    str_0 = '\n---\nmodule: package\nversion_added: 2.0\nauthor:\n    - Ansible Core Team\nshort_description: Generic OS package manager\ndescription:\n    - This modules manages packages on a target without specifying a package manager module (like M(ansible.builtin.yum), M(ansible.builtin.apt), ...).\n      It is convenient to use in an heterogeneous environment of machines without having to create a specific task for\n      each package manager. `package` calls behind the module for the package manager used by the operating system\n      discovered by the module M(ansible.builtin.setup).  If `setup` was not yet run, `package` will run it.\n    - This module acts as a proxy to the underlying package manager module. While all arguments will be passed to the\n      underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection\n      of module arguments that all packaging modules support.\n    - For Windows targets, use the M(ansible.windows.win_package) module instead.\noptions:\n  name:\n    description:\n      - Package name, or package specifier with version.\n      - Syntax varies with package manager. For example C(name-1.0) or C(name=1.0).\n      - Package names also vary with package manager; this module will not "translate" them per distro. For example C(libyaml-dev), C(libyaml-devel).\n    required: true\n  state:\n    description:\n      - Whether to install (C(present)), or remove (C(absent)) a package.\n      - You can use other states like C(latest) ONLY if they are supported by the underlying package module(s) executed.\n    required: true\n  use:\n    description:\n      - The required package manager module to use (`yum`, `apt`, and so on). The default \'auto\' will use existing facts or try to autodetect it.\n      - You should only use this field if the automatic selection is not working for some reason.\n    default: auto\nrequirements:\n    - Whatever is required for the package plugins specific for each system.\nextends_documentation_fragment:\n  -  action_common_attributes\n  -  action_common_attributes.flow\nattributes:\n    action:\n        support: full\n    async:\n        support: full\n    bypass_host_loop:\n        support: none\n    check_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    diff_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    platform:\n        details: The support depends on the availability for the specific plugin for each platform and if fact gathering is able to detect it\n        platforms: all\nnotes:\n    - While `package` abstracts package managers to ease dealing with multiple distributions, package name often differs for the same software.\n\n'
    dict_0 = {str_0: set_0, str_0: str_0, str_0: str_0}
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0, **dict_0)
    ansible_unsafe_0 = module_0.AnsibleUnsafe()
    bytes_0 = b'\x1b\xd8\x06i4\x99\xdc\x96'
    var_1 = module_0.wrap_var(bytes_0)

def test_case_5():
    bool_0 = True
    var_0 = module_0.wrap_var(bool_0)
    list_0 = [var_0, bool_0, var_0]
    var_1 = module_0.to_unsafe_text(*list_0)

def test_case_6():
    ansible_unsafe_0 = module_0.AnsibleUnsafe()
    var_0 = module_0.wrap_var(ansible_unsafe_0)

def test_case_7():
    int_0 = -450
    set_0 = {int_0, int_0}
    list_0 = [set_0, int_0]
    str_0 = '\n---\nmodule: package\nversion_added: 2.0\nauthor:\n    - Ansible Core Team\nshort_description: Generic OS package manager\ndescription:\n    - This modules manages packages on a target without specifying a package manager module (like M(ansible.builtin.yum), M(ansible.builtin.apt), ...).\n      It is convenient to use in an heterogeneous environment of machines without having to create a specific task for\n      each package manager. `package` calls behind the module for the package manager used by the operating system\n      discovered by the module M(ansible.builtin.setup).  If `setup` was not yet run, `package` will run it.\n    - This module acts as a proxy to the underlying package manager module. While all arguments will be passed to the\n      underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection\n      of module arguments that all packaging modules support.\n    - For Windows targets, use the M(ansible.windows.win_package) module instead.\noptions:\n  name:\n    description:\n      - Package name, or package specifier with version.\n      - Syntax varies with package manager. For example C(name-1.0) or C(name=1.0).\n      - Package names also vary with package manager; this module will not "translate" them per distro. For example C(libyaml-dev), C(libyaml-devel).\n    required: true\n  state:\n    description:\n      - Whether to install (C(present)), or remove (C(absent)) a package.\n      - You can use other states like C(latest) ONLY if they are supported by the underlying package module(s) executed.\n    required: true\n  use:\n    description:\n      - The required package manager module to use (`yum`, `apt`, and so on). The default \'auto\' will use existing facts or try to autodetect it.\n      - You should only use this field if the automatic selection is not working for some reason.\n    default: auto\nrequirements:\n    - Whatever is required for the package plugins specific for each system.\nextends_documentation_fragment:\n  -  action_common_attributes\n  -  action_common_attributes.flow\nattributes:\n    action:\n        support: full\n    async:\n        support: full\n    bypass_host_loop:\n        support: none\n    check_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    diff_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    platform:\n        details: The support depends on the availability for the specific plugin for each platform and if fact gathering is able to detect it\n        platforms: all\nnotes:\n    - While `package` abstracts package managers to ease dealing with multiple distributions, package name often differs for the same software.\n\n'
    dict_0 = {str_0: str_0}
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0, **dict_0)
    str_1 = ';}\rR_N=DeDh2'
    ansible_unsafe_0 = module_0.AnsibleUnsafe()
    tuple_0 = (unsafe_proxy_0, str_1, set_0, ansible_unsafe_0)
    var_0 = module_0.wrap_var(tuple_0)

def test_case_8():
    ansible_unsafe_text_0 = module_0.AnsibleUnsafeText()
    set_0 = set()
    native_jinja_unsafe_text_0 = module_0.NativeJinjaUnsafeText()
    var_0 = module_0.wrap_var(set_0)

def test_case_9():
    dict_0 = {}
    var_0 = module_0.wrap_var(dict_0)

def test_case_10():
    int_0 = -450
    set_0 = {int_0, int_0}
    list_0 = [set_0, int_0]
    str_0 = '\n---\nmodule: package\nversion_added: 2.0\nauthor:\n    - Ansible Core Team\nshort_description: Generic OS package manager\ndescription:\n    - This modules manages packages on a target without specifying a package manager module (like M(ansible.builtin.yum), M(ansible.builtin.apt), ...).\n      It is convenient to use in an heterogeneous environment of machines without having to create a specific task for\n      each package manager. `package` calls behind the module for the package manager used by the operating system\n      discovered by the module M(ansible.builtin.setup).  If `setup` was not yet run, `package` will run it.\n    - This module acts as a proxy to the underlying package manager module. While all arguments will be passed to the\n      underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection\n      of module arguments that all packaging modules support.\n    - For Windows targets, use the M(ansible.windows.win_package) module instead.\noptions:\n  name:\n    description:\n      - Package name, or package specifier with version.\n      - Syntax varies with package manager. For example C(name-1.0) or C(name=1.0).\n      - Package names also vary with package manager; this module will not "translate" them per distro. For example C(libyaml-dev), C(libyaml-devel).\n    required: true\n  state:\n    description:\n      - Whether to install (C(present)), or remove (C(absent)) a package.\n      - You can use other states like C(latest) ONLY if they are supported by the underlying package module(s) executed.\n    required: true\n  use:\n    description:\n      - The required package manager module to use (`yum`, `apt`, and so on). The default \'auto\' will use existing facts or try to autodetect it.\n      - You should only use this field if the automatic selection is not working for some reason.\n    default: auto\nrequirements:\n    - Whatever is required for the package plugins specific for each system.\nextends_documentation_fragment:\n  -  action_common_attributes\n  -  action_common_attributes.flow\nattributes:\n    action:\n        support: full\n    async:\n        support: full\n    bypass_host_loop:\n        support: none\n    check_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    diff_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    platform:\n        details: The support depends on the availability for the specific plugin for each platform and if fact gathering is able to detect it\n        platforms: all\nnotes:\n    - While `package` abstracts package managers to ease dealing with multiple distributions, package name often differs for the same software.\n\n'
    dict_0 = {str_0: str_0}
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0, **dict_0)
    ansible_unsafe_0 = module_0.AnsibleUnsafe()
    ansible_unsafe_1 = module_0.AnsibleUnsafe()
    var_0 = module_0.wrap_var(dict_0)

def test_case_11():
    int_0 = 1930
    list_0 = [int_0]
    var_0 = module_0.to_unsafe_text(*list_0)
    str_0 = '\n---\nmodule: package\nversion_added: 2.0\nauthor:\n    - Ansible Core Team\nshort_description: Generic OS package manager\ndescription:\n    - This modules manages packages on a target without specifying a package manager module (like M(ansible.builtin.yum), M(ansible.builtin.apt), ...).\n      It is convenient to use in an heterogeneous environment of machines without having to create a specific task for\n      each package manager. `package` calls behind the module for the package manager used by the operating system\n      discovered by the module M(ansible.builtin.setup).  If `setup` was not yet run, `package` will run it.\n    - This module acts as a proxy to the underlying package manager module. While all arguments will be passed to the\n      underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection\n      of module arguments that all packaging modules support.\n    - For Windows targets, use the M(ansible.windows.win_package) module instead.\noptions:\n  name:\n    description:\n      - Package name, or package specifier with version.\n      - Syntax varies with package manager. For example C(name-1.0) or C(name=1.0).\n      - Package names also vary with package manager; this module will not "translate" them per distro. For example C(libyaml-dev), C(libyaml-devel).\n    required: true\n  state:\n    description:\n      - Whether to install (C(present)), or remove (C(absent)) a package.\n      - You can use other states like C(latest) ONLY if they are supported by the underlying package module(s) executed.\n    required: true\n  use:\n    description:\n      - The required package manager module to use (`yum`, `apt`, and so on). The default \'auto\' will use existing facts or try to autodetect it.\n      - You should only use this field if the automatic selection is not working for some reason.\n    default: auto\nrequirements:\n    - Whatever is required for the package plugins specific for each system.\nextends_documentation_fragment:\n  -  action_common_attributes\n  -  action_common_attributes.flow\nattributes:\n    action:\n        support: full\n    async:\n        support: full\n    bypass_host_loop:\n        support: none\n    check_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    diff_mode:\n        details: support depends on the underlying plugin invoked\n        support: N/A\n    platform:\n        details: The support depends on the availability for the specific plugin for each platform and if fact gathering is able to detect it\n        platforms: all\nnotes:\n    - While `package` abstracts package managers to ease dealing with multiple distributions, package name often differs for the same software.\n\n'
    dict_0 = {str_0: str_0}
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0, **dict_0)
    ansible_unsafe_0 = module_0.AnsibleUnsafe()
    native_jinja_text_0 = module_1.NativeJinjaText()
    var_1 = module_0.wrap_var(native_jinja_text_0)