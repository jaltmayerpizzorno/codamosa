# Automatically generated by Pynguin.
import tornado.locale as module_0
import gettext as module_1

def test_case_0():
    try:
        str_0 = None
        module_0.load_gettext_translations(str_0, str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = 'ql8RXBZ\x0b@"X6\\+DPb'
        str_1 = None
        int_0 = -1486
        dict_0 = {}
        null_translations_0 = module_1.NullTranslations(dict_0)
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_2 = gettext_locale_0.translate(str_1, str_0, int_0)
        gettext_locale_1 = module_0.GettextLocale(str_0, null_translations_0)
        str_3 = gettext_locale_1.pgettext(str_1, str_1)
        str_4 = 'j64W\x0b'
        str_5 = '"\rhLw('
        str_6 = None
        list_0 = [str_0, str_4, str_5, str_6]
        locale_0 = module_0.get(*list_0)
        module_0.load_gettext_translations(str_3, str_3)
    except BaseException:
        pass

def test_case_2():
    try:
        float_0 = -3530.22
        str_0 = 'ql8RXBZ\x0b@"X6\\+DPb'
        str_1 = None
        int_0 = -1486
        dict_0 = {}
        null_translations_0 = module_1.NullTranslations(dict_0)
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_2 = gettext_locale_0.translate(str_1, str_0, int_0)
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_1 = module_0.GettextLocale(str_0, null_translations_1)
        bool_0 = False
        str_3 = gettext_locale_1.pgettext(str_1, str_1)
        str_4 = 'log_function'
        str_5 = 'errback called without error'
        list_0 = [str_4, str_4, str_5, str_3]
        locale_0 = module_0.get(*list_0)
        str_6 = locale_0.format_date(float_0, bool_0)
        str_7 = 'Awaitable[None]'
        str_8 = locale_0.translate(str_7, str_7)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = 'k3T*:Mj1CK/AB'
        locale_0 = module_0.Locale(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = '-[72rK'
        datetime_0 = None
        str_1 = '%Y-%m-%dT%H:%M'
        list_0 = [str_0, str_0, str_1]
        locale_0 = module_0.get(*list_0)
        bool_0 = locale_0.format_day(datetime_0)
    except BaseException:
        pass

def test_case_5():
    try:
        bytes_0 = b'2\x97\x8c\xfc\x9f\xbb'
        locale_0 = module_0.get()
        str_0 = locale_0.list(bytes_0)
    except BaseException:
        pass

def test_case_6():
    try:
        int_0 = 2019
        iterable_0 = module_0.get_supported_locales()
        locale_0 = module_0.get()
        str_0 = locale_0.friendly_number(int_0)
        str_1 = 'Expires'
        module_0.set_default_locale(str_1)
        int_1 = 86400
        str_2 = locale_0.translate(str_1, int_1)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = None
        str_1 = 'Z@c.ak~8Fi1m<@C'
        str_2 = '%(weekday)s, %(month_name)s %(day)s'
        str_3 = 'Bridges between the `asyncio` module and Tornado IOLoop.\n\n.. versionadded:: 3.2\n\nThis module integrates Tornado with the ``asyncio`` module introduced\nin Python 3.4. This makes it possible to combine the two libraries on\nthe same event loop.\n\n.. deprecated:: 5.0\n\n   While the code in this module is still used, it is now enabled\n   automatically when `asyncio` is available, so applications should\n   no longer need to refer to this module directly.\n\n.. note::\n\n   Tornado is designed to use a selector-based event loop. On Windows,\n   where a proactor-based event loop has been the default since Python 3.8,\n   a selector event loop is emulated by running ``select`` on a separate thread.\n   Configuring ``asyncio`` to use a selector event loop may improve performance\n   of Tornado (but may reduce performance of other ``asyncio``-based libraries\n   in the same process).\n'
        str_4 = "$f'>>\nAEBqi_%Y;G"
        dict_0 = {str_2: str_3, str_2: str_2, str_2: str_4}
        dict_1 = {str_2: dict_0}
        c_s_v_locale_0 = module_0.CSVLocale(str_2, dict_1)
        str_5 = c_s_v_locale_0.pgettext(str_0, str_1)
        str_6 = "mW'Rq!W|g|Zd:T)-C"
        module_0.load_gettext_translations(str_6, str_6)
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = 'ql8RXBZ\x0b@"X6\\+DPb'
        str_1 = None
        int_0 = -1486
        dict_0 = {}
        null_translations_0 = module_1.NullTranslations(dict_0)
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_2 = gettext_locale_0.translate(str_1, str_0, int_0)
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_1 = module_0.GettextLocale(str_0, null_translations_1)
        str_3 = 'openid.'
        str_4 = gettext_locale_1.pgettext(str_3, str_3)
        locale_0 = module_0.get()
        str_5 = locale_0.translate(str_4, str_4)
    except BaseException:
        pass

def test_case_9():
    try:
        float_0 = -3530.22
        str_0 = 'ql8RXBZ\x0b@"X6\\+DPb'
        dict_0 = {}
        null_translations_0 = module_1.NullTranslations(dict_0)
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_1)
        bool_0 = False
        str_1 = gettext_locale_0.pgettext(str_0, str_0)
        locale_0 = module_0.get()
        str_2 = locale_0.format_date(float_0, bool_0, bool_0)
        str_3 = locale_0.translate(str_2, str_2)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = ' 5&4ns"^[\x0b'
        str_1 = '0'
        dict_0 = {}
        c_s_v_locale_0 = module_0.CSVLocale(str_0, dict_0)
        str_2 = 'Returns ``True`` if the given string is a well-formed IP address.\n\n    Supports IPv4 and IPv6.\n    '
        int_0 = 127
        str_3 = c_s_v_locale_0.translate(str_0, str_2, int_0)
        str_4 = c_s_v_locale_0.translate(str_0, str_1)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = "Set the no-delay flag for this stream.\n\n        By default, small messages may be delayed and/or combined to minimize\n        the number of packets sent.  This can sometimes cause 200-500ms delays\n        due to the interaction between Nagle's algorithm and TCP delayed\n        ACKs.  To reduce this delay (at the expense of possibly increasing\n        bandwidth usage), call ``self.set_nodelay(True)`` once the websocket\n        connection is established.\n\n        See `.BaseIOStream.set_nodelay` for additional details.\n\n        .. versionadded:: 3.1\n        "
        str_1 = '.value.'
        str_2 = 'G`>z@Z(T;'
        null_translations_0 = module_1.NullTranslations()
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_1)
        str_3 = gettext_locale_0.pgettext(str_1, str_2, null_translations_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = 'ql8RXBZ\x0b@"X6\\+DPb'
        str_1 = None
        int_0 = -1486
        dict_0 = {}
        null_translations_0 = module_1.NullTranslations(dict_0)
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_2 = gettext_locale_0.translate(str_1, str_0, int_0)
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_1 = module_0.GettextLocale(str_0, null_translations_1)
        str_3 = 'openid.'
        str_4 = gettext_locale_1.pgettext(str_3, str_3)
        str_5 = gettext_locale_0.translate(str_2, str_0)
    except BaseException:
        pass

def test_case_13():
    try:
        float_0 = 20.0
        int_0 = None
        bool_0 = False
        locale_0 = module_0.get()
        str_0 = locale_0.format_date(float_0, bool_0)
        null_translations_0 = module_1.NullTranslations()
        locale_1 = module_0.get()
        str_1 = locale_1.format_date(int_0, bool_0)
    except BaseException:
        pass

def test_case_14():
    try:
        float_0 = 605.532771
        int_0 = -2563
        bool_0 = True
        bool_1 = True
        bool_2 = True
        locale_0 = module_0.get()
        str_0 = locale_0.format_date(float_0, int_0, bool_0, bool_1, bool_2)
        str_1 = '2_|W_:HH\x0c]2uIL'
        locale_1 = module_0.Locale(str_1)
    except BaseException:
        pass

def test_case_15():
    try:
        float_0 = 20.0
        int_0 = None
        str_0 = 'Q`L)XSTf/Q'
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_1 = gettext_locale_0.translate(str_0, int_0)
        bool_0 = False
        locale_0 = module_0.get()
        str_2 = locale_0.format_date(float_0, bool_0)
        str_3 = '/'
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_1 = module_0.GettextLocale(str_3, null_translations_1)
        str_4 = gettext_locale_1.translate(str_0, int_0)
        str_5 = ' 8Z=$rEzw=?\nkx~x`\n\n'
        str_6 = 'Apply to `RequestHandler` subclasses to enable streaming body support.\n\n    This decorator implies the following changes:\n\n    * `.HTTPServerRequest.body` is undefined, and body arguments will not\n      be included in `RequestHandler.get_argument`.\n    * `RequestHandler.prepare` is called when the request headers have been\n      read instead of after the entire body has been read.\n    * The subclass must define a method ``data_received(self, data):``, which\n      will be called zero or more times as data is available.  Note that\n      if the request has an empty body, ``data_received`` may not be called.\n    * ``prepare`` and ``data_received`` may return Futures (such as via\n      ``@gen.coroutine``, in which case the next method will not be called\n      until those futures have completed.\n    * The regular HTTP method (``post``, ``put``, etc) will be called after\n      the entire body has been read.\n\n    See the `file receiver demo <https://github.com/tornadoweb/tornado/tree/master/demos/file_upload/>`_\n    for example usage.\n    '
        str_7 = gettext_locale_1.pgettext(str_5, str_6, int_0)
        str_8 = "_7M'\nf,vQ\t{<]/t\\=mL"
        str_9 = '`x~?'
        list_0 = [str_4, str_3, str_8, str_9]
        locale_1 = module_0.get(*list_0)
        str_10 = 'Send ping frame to the remote end.\n\n        The data argument allows a small amount of data (up to 125\n        bytes) to be sent as a part of the ping message. Note that not\n        all websocket implementations expose this data to\n        applications.\n\n        Consider using the ``websocket_ping_interval`` application\n        setting instead of sending pings manually.\n\n        .. versionchanged:: 5.1\n\n           The data argument is now optional.\n\n        '
        locale_2 = module_0.Locale(str_10)
    except BaseException:
        pass

def test_case_16():
    try:
        str_0 = 'ql8RXBZ\x0b@"X6\\+DPb'
        str_1 = None
        int_0 = -1486
        int_1 = 1009
        locale_0 = module_0.get()
        str_2 = locale_0.friendly_number(int_1)
        dict_0 = {}
        null_translations_0 = module_1.NullTranslations(dict_0)
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_3 = gettext_locale_0.translate(str_1, str_0, int_0)
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_1 = module_0.GettextLocale(str_0, null_translations_1)
        str_4 = gettext_locale_1.pgettext(str_1, str_1)
        str_5 = 'j64W\x0b'
        str_6 = '"\rhLw('
        str_7 = None
        list_0 = [str_0, str_5, str_6, str_7]
        locale_1 = module_0.get(*list_0)
        bool_0 = True
        str_8 = locale_1.format_date(int_0, bool_0)
        str_9 = locale_1.translate(str_3, int_0)
    except BaseException:
        pass

def test_case_17():
    try:
        str_0 = 'ql8RXBZ\x0b@"X6\\+DPb'
        str_1 = None
        int_0 = -1167
        int_1 = 1009
        locale_0 = module_0.get()
        str_2 = locale_0.friendly_number(int_1)
        dict_0 = {}
        null_translations_0 = module_1.NullTranslations(dict_0)
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_3 = gettext_locale_0.translate(str_1, str_0, int_0)
        null_translations_1 = module_1.NullTranslations()
        gettext_locale_1 = module_0.GettextLocale(str_0, null_translations_1)
        str_4 = gettext_locale_1.pgettext(str_1, str_1)
        var_0 = null_translations_0.info()
        str_5 = locale_0.list(dict_0)
        str_6 = locale_0.format_date(int_1)
        str_7 = 'c1'
        module_0.load_gettext_translations(str_2, str_7)
    except BaseException:
        pass