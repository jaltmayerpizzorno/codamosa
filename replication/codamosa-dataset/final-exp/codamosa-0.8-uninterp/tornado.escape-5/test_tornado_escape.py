# Automatically generated by Pynguin.
import tornado.escape as module_0

def test_case_0():
    pass

def test_case_1():
    str_0 = '4[3_N\ne<;D\rf'
    str_1 = module_0.xhtml_escape(str_0)

def test_case_2():
    bytes_0 = b'\xf9u\x04^\x8d\xfc\xca\xa5'
    bool_0 = False
    dict_0 = module_0.parse_qs_bytes(bytes_0, bool_0)
    var_0 = None
    str_0 = module_0.json_encode(var_0)

def test_case_3():
    str_0 = '#'
    str_1 = module_0.squeeze(str_0)

def test_case_4():
    str_0 = '\x0b\t'
    str_1 = module_0.url_escape(str_0)

def test_case_5():
    str_0 = '#'
    var_0 = module_0.url_unescape(str_0, str_0)

def test_case_6():
    bytes_0 = b'\xe8\x83\xa4\x80\xd9\x82\xaaX\x9aQ\xa5b\xcf\xe8|\xe4\xf9'
    optional_0 = module_0.utf8(bytes_0)

def test_case_7():
    bytes_0 = b'yx'
    optional_0 = module_0.to_unicode(bytes_0)
    bytes_1 = None
    any_0 = module_0.recursive_unicode(bytes_1)

def test_case_8():
    str_0 = '0ocG,\x0bD2mrB"f-yMG|'
    bytes_0 = b'\xc9\x83'
    bytes_1 = b''
    list_0 = [bytes_0, bytes_1]
    str_1 = 'b3&FQ_"#Zl~ir$)R<~'
    str_2 = 'yf'
    dict_0 = {str_0: list_0, str_1: list_0, str_0: list_0, str_2: list_0}
    any_0 = module_0.recursive_unicode(dict_0)
    str_3 = 'sy\x0cd4OTu'
    str_4 = module_0.xhtml_unescape(str_3)
    str_5 = ':'
    str_6 = '`~unittest.TestCase` subclass for testing `.IOLoop`-based\n    asynchronous code.\n\n    The unittest framework is synchronous, so the test must be\n    complete by the time the test method returns. This means that\n    asynchronous code cannot be used in quite the same way as usual\n    and must be adapted to fit. To write your tests with coroutines,\n    decorate your test methods with `tornado.testing.gen_test` instead\n    of `tornado.gen.coroutine`.\n\n    This class also provides the (deprecated) `stop()` and `wait()`\n    methods for a more manual style of testing. The test method itself\n    must call ``self.wait()``, and asynchronous callbacks should call\n    ``self.stop()`` to signal completion.\n\n    By default, a new `.IOLoop` is constructed for each test and is available\n    as ``self.io_loop``.  If the code being tested requires a\n    global `.IOLoop`, subclasses should override `get_new_ioloop` to return it.\n\n    The `.IOLoop`\'s ``start`` and ``stop`` methods should not be\n    called directly.  Instead, use `self.stop <stop>` and `self.wait\n    <wait>`.  Arguments passed to ``self.stop`` are returned from\n    ``self.wait``.  It is possible to have multiple ``wait``/``stop``\n    cycles in the same test.\n\n    Example::\n\n        # This test uses coroutine style.\n        class MyTestCase(AsyncTestCase):\n            @tornado.testing.gen_test\n            def test_http_fetch(self):\n                client = AsyncHTTPClient()\n                response = yield client.fetch("http://www.tornadoweb.org")\n                # Test contents of response\n                self.assertIn("FriendFeed", response.body)\n\n        # This test uses argument passing between self.stop and self.wait.\n        class MyTestCase2(AsyncTestCase):\n            def test_http_fetch(self):\n                client = AsyncHTTPClient()\n                client.fetch("http://www.tornadoweb.org/", self.stop)\n                response = self.wait()\n                # Test contents of response\n                self.assertIn("FriendFeed", response.body)\n    '
    str_7 = module_0.squeeze(str_6)
    str_8 = module_0.xhtml_unescape(str_5)
    any_1 = module_0.recursive_unicode(str_5)

def test_case_9():
    bytes_0 = b'Q\x1c'
    any_0 = module_0.recursive_unicode(bytes_0)
    str_0 = 'Override this to set HTTP headers at the beginning of the request.\n\n        For example, this is the place to set a custom ``Server`` header.\n        Note that setting such headers in the normal flow of request\n        processing may not do what you want, since headers may be reset\n        during error handling.\n        '
    any_1 = module_0.recursive_unicode(str_0)
    var_0 = module_0.url_unescape(bytes_0)

def test_case_10():
    str_0 = 'http://example.com'
    str_1 = module_0.linkify(str_0)

def test_case_11():
    str_0 = 'A non-blocking TCP connection factory.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n    '
    bool_0 = True
    str_1 = module_0.linkify(str_0, bool_0)
    str_2 = 'GtO[8&\r?'
    dict_0 = module_0.parse_qs_bytes(str_2)

def test_case_12():
    tuple_0 = ()
    any_0 = module_0.recursive_unicode(tuple_0)
    any_1 = module_0.recursive_unicode(tuple_0)

def test_case_13():
    str_0 = 'http://www.example.cm&amp;quot;&amp;gt;http://www.example.cm&amp;lt;/a&amp;gt'
    str_1 = module_0.xhtml_unescape(str_0)

def test_case_14():
    str_0 = 'http://wwm.exatple.cm&amp;quot;&amp;gt;http:/'
    str_1 = module_0.linkify(str_0, str_0)

def test_case_15():
    str_0 = 'Hello <a href="http://www.hamid.com">www.hamid.com</a>, <a href="https://www.google.com">https://www.google.com</a>, <a href="http://www.example.com/">http://www.example.com/</a>, <a href="mailto:test@test.com">test@test.com</a>'
    str_1 = module_0.linkify(str_0)

def test_case_16():
    str_0 = 'This is a link to ftp://ftp.google.com/pub/.'
    str_1 = 'http'
    str_2 = [str_1]
    str_3 = module_0.linkify(str_0, str_2)

def test_case_17():
    str_0 = 'http://www.facebook.com/tornadoweb'
    bool_0 = True
    str_1 = module_0.linkify(str_0, bool_0)
    bool_1 = True
    str_2 = "<a href='http://foo.com'>http://foo.com</a>"
    str_3 = module_0.linkify(str_0, bool_1, str_2, bool_1)

def test_case_18():
    str_0 = 'http://www.a.com'
    bool_0 = True
    str_1 = module_0.linkify(str_0, bool_0)
    str_2 = module_0.linkify(str_0, bool_0)

def test_case_19():
    str_0 = 'http://www.facebook.com/tornadoweb'
    list_0 = [str_0]
    str_1 = module_0.linkify(str_0, list_0)

def test_case_20():
    str_0 = 'http://www.example.com'
    str_1 = module_0.linkify(str_0)
    bool_0 = False
    str_2 = 'D-\nn$OZYE'
    bool_1 = True
    str_3 = module_0.linkify(str_2, bool_1)
    str_4 = module_0.linkify(str_0, str_1, bool_0)
    str_5 = module_0.linkify(str_4, bool_1)

def test_case_21():
    str_0 = 'httpH//www.example.cm'
    str_1 = module_0.linkify(str_0)
    bool_0 = False
    str_2 = module_0.xhtml_escape(str_1)
    str_3 = module_0.xhtml_unescape(str_2)
    any_0 = module_0.recursive_unicode(str_2)
    var_0 = module_0.url_unescape(str_0)
    optional_0 = module_0.to_unicode(str_3)
    bool_1 = False
    dict_0 = module_0.parse_qs_bytes(str_0)
    str_4 = module_0.xhtml_escape(str_3)
    dict_1 = module_0.parse_qs_bytes(str_0, bool_0, bool_1)
    str_5 = module_0.json_encode(str_0)
    str_6 = "Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.\n\n        Implementation notes: Reads and writes have a fast path and a\n        slow path.  The fast path reads synchronously from socket\n        buffers, while the slow path uses `_add_io_state` to schedule\n        an IOLoop callback.\n\n        To detect closed connections, we must have called\n        `_add_io_state` at some point, but we want to delay this as\n        much as ossible so we don't have to set an `IOLoop.ERROR`\n        listener that will be overwritten by the next slow-path\n        operation. If a sequence of fast-path ops do not end in a\n        slow-path op, (e.g. for an @asynchronous long-poll request),\n        we must add the error handler.\n\n        TODO: reevaluate this now that callbacks are gone.\n\n        "
    dict_2 = module_0.parse_qs_bytes(str_0)
    str_7 = module_0.xhtml_escape(str_1)
    var_1 = module_0.url_unescape(str_2, str_6)
    list_0 = [str_6, str_7, str_1]
    str_8 = module_0.linkify(str_5, bool_0, str_5, list_0)
    str_9 = module_0.linkify(str_6, str_6)
    str_10 = module_0.xhtml_unescape(str_9)

def test_case_22():
    str_0 = "Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.\n\n        Implementation notes: Reads and writes have a fast path and a\n        slow path.  The fast path reads synchronously from socket\n        buffers, while the slow path uses `_add_io_state` to schedule\n        an IOLoop callback.\n\n        To detect closed connections, we must have called\n        `_add_io_state` at some point, but we want to delay this as\n        much as ossible so we don't have to set an `IOLoop.ERROR`\n        listener that will be overwritten by the next slow-path\n        operation. If a sequence of fast-path ops do not end in a\n        slow-path op, (e.g. for an @asynchronous long-poll request),\n        we must add the error handler.\n\n        TODO: reevaluate this now that callbacks are gone.\n\n        "
    str_1 = module_0.linkify(str_0, str_0)
    str_2 = module_0.xhtml_unescape(str_1)