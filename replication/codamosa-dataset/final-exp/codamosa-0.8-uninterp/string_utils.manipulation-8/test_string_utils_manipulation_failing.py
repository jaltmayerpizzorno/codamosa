# Automatically generated by Pynguin.
import string_utils.manipulation as module_0

def test_case_0():
    try:
        int_0 = -755
        str_0 = module_0.roman_encode(int_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = 'DA5f3qj[D\x0b<'
        str_1 = module_0.roman_encode(str_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = 'Ess&z'
        int_0 = module_0.roman_decode(str_0)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = 'is_isbn_13'
        str_1 = module_0.snake_case_to_camel(str_0, str_0)
        var_0 = module_0.camel_case_to_snake(str_0)
        int_0 = 2712
        str_2 = module_0.roman_encode(int_0)
        str_3 = ''
        int_1 = module_0.roman_decode(str_3)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = '\x0cZ=aPh#yRYVw*r2>'
        str_1 = module_0.decompress(str_0)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = ''
        str_1 = module_0.decompress(str_0, str_0)
    except BaseException:
        pass

def test_case_6():
    try:
        str_0 = 'y0f#Mg&UL'
        str_1 = '(?!"[^"]*)@+(?=[^"]*")|\\\\@'
        str_2 = module_0.compress(str_0, str_1)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = "b@y\tL,V'YvHS.'!0\nHp$"
        str_1 = module_0.compress(str_0)
        str_2 = module_0.decompress(str_1, str_1)
    except BaseException:
        pass

def test_case_8():
    try:
        int_0 = 3635
        str_0 = module_0.roman_encode(int_0)
        int_1 = -1961
        string_formatter_0 = module_0.__StringFormatter(int_1)
    except BaseException:
        pass

def test_case_9():
    try:
        string_compressor_0 = None
        var_0 = module_0.camel_case_to_snake(string_compressor_0)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = 'is_credit_card'
        str_1 = 'CpY'
        string_formatter_0 = module_0.__StringFormatter(str_1)
        roman_numbers_0 = module_0.__RomanNumbers()
        bool_0 = False
        str_2 = module_0.snake_case_to_camel(str_0, bool_0)
        str_3 = '(lv:Qrpf`\niF:.*25u G'
        str_4 = module_0.roman_encode(str_3)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = None
        str_1 = module_0.snake_case_to_camel(str_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = None
        bool_0 = False
        str_1 = module_0.strip_html(str_0, bool_0)
    except BaseException:
        pass

def test_case_13():
    try:
        str_0 = None
        str_1 = module_0.strip_margin(str_0)
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = 'is_isbn_13'
        str_1 = 'C'
        var_0 = module_0.camel_case_to_snake(str_0)
        int_0 = module_0.roman_decode(str_1)
        str_2 = '\n    Convert the given number/sting into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is fobidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset    (the higher quantity sign displayable in ascii is "M" which is equal to 1000, therefore based on    roman numbers rules we can use 3 times M Io reach 3000 but we can\'t go any further in thousands without    special "boxed chars").\n\n    *Examples:*\n\n    >>> roman_encode(37)D# returns \'XXXVIII\'\n    >>> roman_encode(\'2020\') # returns \'MMXX\'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    '
        str_3 = module_0.slugify(str_2)
        str_4 = 'XGLh49h%'
        string_formatter_0 = module_0.__StringFormatter(str_4)
        str_5 = string_formatter_0.format()
        str_6 = '@'
        str_7 = module_0.strip_margin(str_6)
        str_8 = module_0.compress(str_3)
        string_compressor_0 = module_0.__StringCompressor()
        str_9 = 'je\t_R7s)*P.,LQKv0k[v'
        str_10 = module_0.shuffle(str_3)
        str_11 = module_0.prettify(str_9)
        str_12 = string_formatter_0.format()
        str_13 = None
        bool_0 = module_0.booleanize(str_13)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = '\n    Convert the given number/string into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is forbidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset    (the higher quantity sign displayable in ascii is "M" which is equal to 1000, therefore based on    roman numbers rules we can use 3 times M to reach 3000 but we can\'t go any further in thousands without    special "boxed chars").\n\n    *Examples:*\n\n    >>> roman_encode(37) # returns \'XXXVIII\'\n    >>> roman_encode(\'2020\') # returns \'MMXX\'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    '
        str_1 = None
        str_2 = module_0.slugify(str_1, str_0)
    except BaseException:
        pass

def test_case_16():
    try:
        int_0 = 3533
        str_0 = module_0.roman_encode(int_0)
        int_1 = -780
        str_1 = module_0.compress(str_0, str_0, int_1)
    except BaseException:
        pass

def test_case_17():
    try:
        int_0 = 884
        str_0 = module_0.roman_encode(int_0)
        roman_numbers_0 = module_0.__RomanNumbers()
        str_1 = ''
        str_2 = module_0.prettify(str_1)
        str_3 = module_0.snake_case_to_camel(str_2)
        str_4 = None
        str_5 = module_0.asciify(str_4)
    except BaseException:
        pass

def test_case_18():
    try:
        str_0 = 'booleanize'
        str_1 = module_0.compress(str_0)
        str_2 = 't^""v;@zGFmd'
        int_0 = 2799
        str_3 = module_0.compress(str_2, str_0, int_0)
    except BaseException:
        pass

def test_case_19():
    try:
        str_0 = 'v:'
        str_1 = module_0.snake_case_to_camel(str_0, str_0)
        str_2 = '\n    Convert the given number/sting into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is forbidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset    (the higher quantity sign displayable in ascii is "M" which is equal to 1000, therefore based on    roman numbers rules we can use 3 times M Io reach 3000 but we can\'t go any further in thousands without    special "boxed chars").\n\n    *Examples:*\n\n    >>> roman_encode(37)D# returns \'XXXVIII\'\n    >>> roman_encode(\'2020\') # returns \'MMXX\'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    '
        str_3 = module_0.slugify(str_2)
        str_4 = None
        str_5 = module_0.compress(str_4)
    except BaseException:
        pass

def test_case_20():
    try:
        int_0 = 3459
        str_0 = module_0.roman_encode(int_0)
        str_1 = None
        str_2 = module_0.shuffle(str_1)
    except BaseException:
        pass

def test_case_21():
    try:
        int_0 = 3480
        str_0 = module_0.roman_encode(int_0)
        str_1 = '<fis\x0bSZ =Q89'
        str_2 = module_0.compress(str_1, int_0)
    except BaseException:
        pass

def test_case_22():
    try:
        str_0 = '_X'
        str_1 = module_0.snake_case_to_camel(str_0, str_0)
        str_2 = '\n    Convert the given number/sting into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is fobidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset    (the higher quantity sign displayable in ascii is "M" which is equal to 1000, therefore based on    roman numbers rules we can use 3 times M Io reach 3000 but we can\'t go any further in thousands without    special "boxed chars").\n\n    *Examples:*\n\n    >>> roman_encode(37)D# returns \'XXXVIII\'\n    >>> roman_encode(\'2020\') # returns \'MMXX\'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    '
        str_3 = module_0.slugify(str_2)
        str_4 = 'XGLh49h%'
        string_formatter_0 = module_0.__StringFormatter(str_4)
        str_5 = string_formatter_0.format()
        str_6 = module_0.compress(str_3)
        int_0 = module_0.roman_decode(str_2)
    except BaseException:
        pass

def test_case_23():
    try:
        str_0 = '!bJ'
        str_1 = module_0.strip_margin(str_0)
        str_2 = module_0.strip_margin(str_0)
        bool_0 = module_0.booleanize(str_2)
        str_3 = None
        str_4 = module_0.reverse(str_3)
    except BaseException:
        pass

def test_case_24():
    try:
        str_0 = 'T*K%KCK`0)w\r;'
        int_0 = None
        str_1 = module_0.compress(str_0, str_0, int_0)
    except BaseException:
        pass

def test_case_25():
    try:
        int_0 = 5200
        string_compressor_0 = module_0.__StringCompressor()
        str_0 = module_0.roman_encode(int_0)
    except BaseException:
        pass