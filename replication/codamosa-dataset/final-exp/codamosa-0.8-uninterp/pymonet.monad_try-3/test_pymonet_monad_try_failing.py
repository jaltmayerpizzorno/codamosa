# Automatically generated by Pynguin.
import pymonet.monad_try as module_0

def test_case_0():
    try:
        str_0 = '?78JXzy~Bi'
        bool_0 = True
        try_0 = module_0.Try(str_0, bool_0)
        bool_1 = try_0.__eq__(bool_0)
        bool_2 = False
        try_1 = module_0.Try(try_0, bool_2)
        int_0 = -4965
        var_0 = try_0.bind(int_0)
    except BaseException:
        pass

def test_case_1():
    try:
        tuple_0 = ()
        str_0 = '^*a4J,vXR#y'
        bool_0 = True
        try_0 = module_0.Try(str_0, bool_0)
        var_0 = try_0.map(tuple_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = ''
        int_0 = -4248
        bool_0 = True
        try_0 = module_0.Try(int_0, bool_0)
        var_0 = try_0.bind(str_0)
    except BaseException:
        pass

def test_case_3():
    try:
        tuple_0 = None
        bool_0 = True
        try_0 = module_0.Try(tuple_0, bool_0)
        float_0 = -1703.489
        var_0 = try_0.on_success(float_0)
    except BaseException:
        pass

def test_case_4():
    try:
        int_0 = 2084
        bool_0 = False
        try_0 = module_0.Try(int_0, bool_0)
        str_0 = 'OOOu#\x0bThJhC\r'
        dict_0 = {str_0: int_0}
        var_0 = try_0.on_fail(dict_0)
    except BaseException:
        pass

def test_case_5():
    try:
        int_0 = 1
        bool_0 = False
        try_0 = module_0.Try(int_0, bool_0)
        var_0 = try_0.filter(int_0)
        bool_1 = True
        try_1 = module_0.Try(bool_0, bool_1)
        var_1 = try_1.filter(try_0)
    except BaseException:
        pass

def test_case_6():
    try:
        list_0 = []
        bytes_0 = b'SJ\xf17\xf5\xdaR<\x81>\xd4O\n'
        bool_0 = True
        try_0 = module_0.Try(bytes_0, bool_0)
        bool_1 = try_0.__eq__(list_0)
        var_0 = try_0.get()
        str_0 = 'i]>>mU;&h,$TD'
        var_1 = try_0.filter(str_0)
    except BaseException:
        pass

def test_case_7():
    try:
        dict_0 = {}
        bytes_0 = b''
        bool_0 = True
        str_0 = '\n        Take function, store it and call with Task value during calling fork function.\n        Return new Task with result of called.\n\n        :param fn: mapper function\n        :type fn: Function(value) -> B\n        :returns: new Task with mapped resolve attribute\n        :rtype: Task[Function(resolve, reject -> A | B]\n        '
        try_0 = module_0.Try(str_0, bool_0)
        bool_1 = False
        tuple_0 = (bool_1,)
        bool_2 = False
        try_1 = module_0.Try(tuple_0, bool_2)
        try_2 = module_0.Try(try_1, bool_0)
        var_0 = try_2.get_or_else(try_0)
        try_3 = module_0.Try(bytes_0, bool_0)
        dict_1 = None
        int_0 = 13
        bool_3 = True
        try_4 = module_0.Try(int_0, bool_3)
        var_1 = try_4.get_or_else(dict_1)
        bool_4 = try_3.__eq__(dict_0)
        str_1 = try_3.__str__()
        list_0 = []
        var_2 = try_3.on_success(list_0)
    except BaseException:
        pass