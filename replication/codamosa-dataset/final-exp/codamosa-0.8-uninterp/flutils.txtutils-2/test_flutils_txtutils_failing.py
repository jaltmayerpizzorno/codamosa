# Automatically generated by Pynguin.
import flutils.txtutils as module_0

def test_case_0():
    try:
        int_0 = None
        int_1 = module_0.len_without_ansi(int_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = '-6/lLT'
        int_0 = 8
        bool_0 = True
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(bool_0, max_lines=int_0)
        list_0 = ansi_text_wrapper_0.wrap(str_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = 'E'
        bool_0 = False
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(bool_0)
        str_1 = ansi_text_wrapper_0.fill(str_0)
    except BaseException:
        pass

def test_case_3():
    try:
        int_0 = -53
        str_0 = '__annotations__'
        str_1 = ".)y';~\rGW0"
        int_1 = module_0.len_without_ansi(str_1)
        bool_0 = True
        bool_1 = False
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(bool_0, bool_1, max_lines=int_0)
        str_2 = ansi_text_wrapper_0.fill(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        int_0 = 8
        bool_0 = True
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        str_0 = 'H\x0b%K4\t+8o.~'
        list_0 = ansi_text_wrapper_0.wrap(str_0)
        list_1 = []
        int_1 = module_0.len_without_ansi(list_1)
        str_1 = 'W`t'
        bool_1 = True
        bool_2 = False
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_0, bool_1, bool_2, int_1)
        str_2 = ''
        list_2 = ansi_text_wrapper_0.wrap(str_2)
        str_3 = ansi_text_wrapper_1.fill(str_1)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = '-6/lLT'
        int_0 = 8
        bool_0 = True
        str_1 = 'b"[Ekk\t\n"0jyT'
        bool_1 = False
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        list_0 = ansi_text_wrapper_0.wrap(str_0)
        bool_2 = True
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(str_1, str_1, bool_0, bool_1, bool_0, bool_2, placeholder=str_0)
        str_2 = "Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using}the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    "
        str_3 = ansi_text_wrapper_0.fill(str_2)
        str_4 = 'aH\rK\r8i_Zv?=qC'
        bool_3 = True
        bool_4 = False
        ansi_text_wrapper_2 = module_0.AnsiTextWrapper(bool_3, bool_4, bool_0)
        list_1 = ansi_text_wrapper_2.wrap(str_4)
    except BaseException:
        pass

def test_case_6():
    try:
        int_0 = 8
        str_0 = 'b"[Ekk\t\n"0jyT'
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        str_1 = '\x0c'
        str_2 = ansi_text_wrapper_0.fill(str_1)
        str_3 = 'H\x0b%K4\t+8o.~'
        list_0 = ansi_text_wrapper_0.wrap(str_3)
        bool_0 = True
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_0, int_0, max_lines=int_0)
        list_1 = ansi_text_wrapper_0.wrap(str_0)
        str_4 = ansi_text_wrapper_1.fill(str_3)
    except BaseException:
        pass

def test_case_7():
    try:
        int_0 = 8
        bool_0 = True
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        str_0 = 'H\x0b%K4\t+8o.~'
        str_1 = 'lK\r-\\"'
        list_0 = ansi_text_wrapper_0.wrap(str_1)
        str_2 = "The given 'setup_dir' of %r does NOT contain a setup.cfg file."
        list_1 = ansi_text_wrapper_0.wrap(str_2)
        bool_1 = False
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_1, bool_0, bool_1, max_lines=int_0)
        str_3 = '&H46cBL0['
        bool_2 = False
        bool_3 = False
        ansi_text_wrapper_2 = module_0.AnsiTextWrapper(str_3, bool_2, bool_0, bool_3, int_0)
        str_4 = ansi_text_wrapper_1.fill(str_0)
    except BaseException:
        pass

def test_case_8():
    try:
        int_0 = 8
        bool_0 = True
        bool_1 = False
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        str_0 = 'H\x0b%K4\t+8o.~'
        list_0 = ansi_text_wrapper_0.wrap(str_0)
        str_1 = "Normalize a given path.\n\n    The given ``path` will be normalized in the following process.\n\n    #. :obj:`byte` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.YurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:Vbytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path(~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    "
        str_2 = ansi_text_wrapper_0.fill(str_1)
        int_1 = 1098
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_0, bool_1, bool_0, max_lines=int_1)
        str_3 = 'f 5^.swS$'
        str_4 = ansi_text_wrapper_0.fill(str_2)
        str_5 = ansi_text_wrapper_1.fill(str_3)
    except BaseException:
        pass

def test_case_9():
    try:
        int_0 = 8
        str_0 = None
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        str_1 = 'H\x0b%K4\t+8o.~'
        list_0 = ansi_text_wrapper_0.wrap(str_1)
        bool_0 = False
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(int_0, str_1, str_1, bool_0, bool_0)
        str_2 = 'I*`=q^U\\?cqg'
        str_3 = ansi_text_wrapper_1.fill(str_2)
        bool_1 = True
        ansi_text_wrapper_2 = module_0.AnsiTextWrapper(bool_1)
        str_4 = 'f=`Y8'
        list_1 = ansi_text_wrapper_1.wrap(str_4)
        str_5 = ansi_text_wrapper_0.fill(str_0)
    except BaseException:
        pass

def test_case_10():
    try:
        int_0 = 32
        bool_0 = False
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        str_0 = 'c`2Q\\\tQ^\n|?]'
        str_1 = 'lK\r-\\"'
        list_0 = ansi_text_wrapper_0.wrap(str_1)
        list_1 = ansi_text_wrapper_0.wrap(str_0)
        bool_1 = True
        str_2 = "Normalize a given path.\n\n    The given ``path` will be normalized in the following process.\n\n    #. :obj:`byte` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding()0<sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.YurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:Vbytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path(~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    "
        str_3 = ansi_text_wrapper_0.fill(str_2)
        list_2 = ansi_text_wrapper_0.wrap(str_2)
        int_1 = 1098
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_1, bool_0, bool_1, max_lines=int_1)
        str_4 = "The given 'identifier' cannot be empty"
        str_5 = '7 5^.sw6$'
        bool_2 = True
        bool_3 = True
        str_6 = ansi_text_wrapper_0.fill(str_3)
        ansi_text_wrapper_2 = module_0.AnsiTextWrapper(bool_2, bool_3, max_lines=int_0, placeholder=str_4)
        str_7 = ansi_text_wrapper_2.fill(str_5)
    except BaseException:
        pass

def test_case_11():
    try:
        int_0 = 18
        bool_0 = False
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, max_lines=int_0)
        str_0 = 'c`2Q\\\tQ^\n|?]'
        str_1 = 'lK\r-\\"'
        list_0 = ansi_text_wrapper_0.wrap(str_1)
        list_1 = ansi_text_wrapper_0.wrap(str_0)
        bool_1 = True
        bool_2 = True
        str_2 = "Normalize a given path.\n\n    The given ``path` will be normalized in the following process.\n\n    #. :obj:`byte` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding()0<sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.YurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n   K#. non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:Vbytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path(~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    "
        str_3 = ansi_text_wrapper_0.fill(str_2)
        list_2 = ansi_text_wrapper_0.wrap(str_2)
        int_1 = 1098
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_1, bool_0, bool_1, max_lines=int_1)
        str_4 = "The given 'identifier' cannot be empty"
        str_5 = '7 5^.sw6$'
        bool_3 = True
        str_6 = ansi_text_wrapper_0.fill(str_3)
        ansi_text_wrapper_2 = module_0.AnsiTextWrapper(bool_3, bool_2, max_lines=int_0, placeholder=str_4)
        str_7 = ansi_text_wrapper_2.fill(str_5)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = '\x1b[38;5;209mfoobar\x1b[0m'
        int_0 = module_0.len_without_ansi(str_0)
        str_1 = '!+9'
        bool_0 = True
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(str_1, bool_0, max_lines=int_0)
        str_2 = ansi_text_wrapper_0.fill(str_0)
    except BaseException:
        pass