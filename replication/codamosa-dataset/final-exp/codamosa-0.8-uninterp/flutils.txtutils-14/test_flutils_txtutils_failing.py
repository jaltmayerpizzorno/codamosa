# Automatically generated by Pynguin.
import flutils.txtutils as module_0

def test_case_0():
    try:
        str_0 = '\x1b[38;5;209mfoobar\x1b[0m'
        int_0 = module_0.len_without_ansi(str_0)
        bool_0 = False
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(bool_0, bool_0)
        str_1 = ansi_text_wrapper_0.fill(str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = "Unable to run the command:  %r, in interactive mode because 'bash' could NOT be found on the system."
        int_0 = 395
        bool_0 = True
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, bool_0, bool_0)
        str_1 = ansi_text_wrapper_0.fill(str_0)
    except BaseException:
        pass

def test_case_2():
    try:
        int_0 = -55
        str_0 = 'm'
        bool_0 = True
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, str_0, bool_0, bool_0)
        bool_1 = True
        str_1 = '._2)\x0b|(\rG'
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_1)
        int_1 = -1958
        str_2 = "A :obj:`NamedTuple <typing.NamedTuple>` that holds a completed\n    process' information.\n\n    Attributes:\n         return_code (int): The process return code.\n         stdout (str): All lines of the ``stdout`` from the process.\n         stderr (str): All lines of the ``stderr`` from the process.\n         cmd (str): The command that the process ran.\n    "
        str_3 = ansi_text_wrapper_1.fill(str_2)
        str_4 = 'A simple callable that simplifies many calls to :obj:`subprocess.run`.\n\n    Args:\n        raise_error (bool, optional): A value of :obj:`True` will raise\n            a :obj:`ChildProcessError` if the process,\n            exits with a non-zero return code. Default: :obj:`True`\n        output_encoding (str, optional): If set, the returned ``stdout``\n            and ``stderr`` will be converted to from bytes to a Python\n            string using this given ``encoding``.  Defaults to:\n            :obj:`None` which will use the value from\n            :obj:`locale.getpreferredencoding` or, if not set, the value\n            from :obj:`sys.getdefaultencoding` will be used. If the given\n            encoding does NOT exist the default will be used.\n        **default_kwargs: Any :obj:`subprocess.Popen` keyword argument.\n\n    Attributes:\n        default_kwargs (:obj:`NamedTuple <typing.NamedTuple>`): The\n            ``default_kwargs`` passed into the constructor which may be\n            passed on to :obj:`subprocess.run`.\n        output_encoding (str): The encoding used to decode the process\n            output\n\n    '
        ansi_text_wrapper_2 = module_0.AnsiTextWrapper(int_1, str_4, bool_1, bool_1)
        list_0 = ansi_text_wrapper_2.wrap(str_1)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = "'-JL2vHZ>yV"
        int_0 = 988
        bool_0 = True
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(bool_0, max_lines=int_0)
        list_0 = ansi_text_wrapper_0.wrap(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = 't``'
        bool_0 = False
        int_0 = -50
        bool_1 = None
        ansi_text_wrapper_0 = module_0.AnsiTextWrapper(int_0, str_0, bool_0, bool_1, max_lines=int_0)
        bool_2 = False
        bool_3 = None
        ansi_text_wrapper_1 = module_0.AnsiTextWrapper(bool_2, bool_3, int_0)
        bool_4 = True
        ansi_text_wrapper_2 = module_0.AnsiTextWrapper(bool_4)
        str_1 = 's6.L`'
        str_2 = ansi_text_wrapper_2.fill(str_1)
        str_3 = ''
        list_0 = ansi_text_wrapper_2.wrap(str_3)
        str_4 = '85yS7Y|\\{FLV'
        str_5 = ansi_text_wrapper_1.fill(str_4)
    except BaseException:
        pass