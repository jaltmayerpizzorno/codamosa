# Automatically generated by Pynguin.
import tornado.netutil as module_0
import ssl as module_1
import socket as module_2
import tornado.ioloop as module_3
import datetime as module_4

def test_case_0():
    try:
        int_0 = None
        list_0 = module_0.bind_sockets(int_0, int_0, int_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = 'T&'
        int_0 = 2180
        socket_0 = module_0.bind_unix_socket(str_0, int_0)
        str_1 = None
        dict_0 = {str_1: socket_0, str_1: str_1, str_1: socket_0, str_0: str_1}
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = 'IeT*Q#8&w4'
        socket_0 = module_0.bind_unix_socket(str_0)
        float_0 = 771.9
        callable_0 = module_0.add_accept_handler(socket_0, float_0)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = 'Google authentication using OAuth2.\n\n    In order to use, register your application with Google and copy the\n    relevant parameters to your application settings.\n\n    * Go to the Google Dev Console at http://console.developers.google.com\n    * Select a project, or create a new one.\n    * In the sidebar on the left, select APIs & Auth.\n    * In the list of APIs, find the Google+ API service and set it to ON.\n    * In the sidebar on the left, select Credentials.\n    * In the OAuth section of the page, select Create New Client ID.\n    * Set the Redirect URI to point to your auth handler\n    * Copy the "Client secret" and "Client ID" to the application settings as\n      ``{"google_oauth": {"key": CLIENT_ID, "secret": CLIENT_SECRET}}``\n\n    .. versionadded:: 3.2\n    '
        bool_0 = module_0.is_valid_ip(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        executor_resolver_0 = module_0.ExecutorResolver()
    except BaseException:
        pass

def test_case_5():
    try:
        resolver_0 = module_0.Resolver()
        override_resolver_0 = module_0.OverrideResolver()
    except BaseException:
        pass

def test_case_6():
    try:
        socket_0 = None
        s_s_l_context_0 = module_1.SSLContext()
        str_0 = ']+N'
        dict_0 = {str_0: s_s_l_context_0}
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, s_s_l_context_0, str_0, **dict_0)
    except BaseException:
        pass

def test_case_7():
    try:
        blocking_resolver_0 = module_0.BlockingResolver()
    except BaseException:
        pass

def test_case_8():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_9():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_10():
    try:
        socket_0 = module_2.socket()
        var_0 = module_1.create_default_context()
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, var_0)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = None
        socket_0 = module_0.bind_unix_socket(str_0)
    except BaseException:
        pass

def test_case_12():
    try:
        int_0 = 8787
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_13():
    try:
        int_0 = 3345
        str_0 = "'Crs{-)HCr!Kv2$"
        list_0 = [str_0, int_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        override_resolver_0.close()
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = '2PGR3'
        socket_0 = module_0.bind_unix_socket(str_0)
        str_1 = "'Crs{-)HCr!Kv2$"
        bool_0 = module_0.is_valid_ip(str_1)
        var_0 = socket_0.dup()
        dict_0 = None
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = None
        list_0 = []
        default_executor_resolver_0 = module_0.DefaultExecutorResolver(*list_0)
        bool_0 = module_0.is_valid_ip(str_0)
        socket_0 = None
        str_1 = "'Crs{-)HCr!Kv2$"
        str_2 = 'NL~Ss:+'
        str_3 = '|'
        dict_0 = {str_1: bool_0, str_1: str_0, str_2: default_executor_resolver_0, str_3: list_0}
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_0, str_2)
    except BaseException:
        pass

def test_case_16():
    try:
        i_o_loop_0 = module_3.IOLoop()
        int_0 = 756
        list_0 = []
        threaded_resolver_0 = module_0.ThreadedResolver(*list_0)
        threaded_resolver_0.initialize(int_0)
        default_executor_resolver_0 = module_0.DefaultExecutorResolver()
        var_0 = await resolver.resolve('www.baidu.com', 80)
    except BaseException:
        pass

def test_case_17():
    try:
        str_0 = '2?PGR3'
        dict_0 = {}
        resolver_0 = module_0.Resolver(**dict_0)
        socket_0 = module_0.bind_unix_socket(str_0)
        i_o_loop_0 = module_3.IOLoop()
        i_o_loop_1 = i_o_loop_0.instance()
        i_o_loop_2 = i_o_loop_1.instance()
        callable_0 = module_0.add_accept_handler(socket_0, i_o_loop_2)
        s_s_l_context_0 = module_1.SSLContext()
        int_0 = 825
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_18():
    try:
        str_0 = 'wsgi.errors'
        int_0 = 3337
        address_family_0 = module_2.AddressFamily.AF_PACKET
        timedelta_0 = module_4.timedelta()
        list_0 = [timedelta_0, timedelta_0]
        str_1 = 'eZ!<_*n\x0bYfHVl\tq~%Y'
        bool_0 = module_0.is_valid_ip(str_1)
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        awaitable_0 = override_resolver_0.resolve(str_0, int_0, address_family_0)
    except BaseException:
        pass