# Automatically generated by Pynguin.
import tornado.netutil as module_0
import socket as module_1
import concurrent.futures._base as module_2
import ssl as module_3

def test_case_0():
    try:
        int_0 = 405
        list_0 = module_0.bind_sockets(int_0, int_0, int_0)
    except BaseException:
        pass

def test_case_1():
    try:
        int_0 = 8888
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_2():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = 'Cross origin websockets not allowed'
        bool_0 = module_0.is_valid_ip(str_0)
        resolver_0 = module_0.Resolver()
        int_0 = 1272
        address_family_0 = module_1.AddressFamily.AF_UNIX
        awaitable_0 = resolver_0.resolve(str_0, int_0, address_family_0)
        blocking_resolver_0 = module_0.BlockingResolver()
    except BaseException:
        pass

def test_case_4():
    try:
        dict_0 = {}
        threaded_resolver_0 = module_0.ThreadedResolver(**dict_0)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = None
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        socket_0 = module_1.socket()
        dict_0 = {}
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_0, str_0)
        int_0 = 18
        socket_1 = module_0.bind_unix_socket(str_0, int_0)
    except BaseException:
        pass

def test_case_6():
    try:
        executor_0 = module_2.Executor()
        str_0 = "\x0c)BH(fS<@d'9"
        int_0 = 2605
        socket_0 = module_0.bind_unix_socket(str_0, int_0)
        str_1 = '.4t>s{u'
        str_2 = "Set the given ``value`` as the `Future`'s result, if not cancelled.\n\n    Avoids ``asyncio.InvalidStateError`` when calling ``set_result()`` on\n    a cancelled `asyncio.Future`.\n\n    .. versionadded:: 5.0\n    "
        dict_0 = {str_1: str_1, str_2: str_2, str_2: executor_0}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = None
        str_1 = '\x0cQT@jclT!l<'
        socket_0 = module_1.socket()
        dict_0 = {}
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_0, str_0)
        int_0 = 18
        socket_1 = module_0.bind_unix_socket(str_1, int_0)
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        str_2 = 'multipart/form-data'
        bool_0 = module_0.is_valid_ip(str_2)
        int_1 = 231
        list_0 = module_0.bind_sockets(int_1)
        callable_0 = None
        callable_1 = module_0.add_accept_handler(socket_0, callable_0)
    except BaseException:
        pass

def test_case_8():
    try:
        int_0 = 476
        str_0 = ''
        list_0 = module_0.bind_sockets(int_0, str_0, int_0)
    except BaseException:
        pass

def test_case_9():
    try:
        str_0 = 'Abstract implementation of OAuth 1.0 and 1.0a.\n\n    See `TwitterMixin` below for an example implementation.\n\n    Class attributes:\n\n    * ``_OAUTH_AUTHORIZE_URL``: The service\'s OAuth authorization url.\n    * ``_OAUTH_ACCESS_TOKEN_URL``: The service\'s OAuth access token url.\n    * ``_OAUTH_VERSION``: May be either "1.0" or "1.0a".\n    * ``_OAUTH_NO_CALLBACKS``: Set this to True if the service requires\n      advance registration of callbacks.\n\n    Subclasses must also override the `_oauth_get_user_future` and\n    `_oauth_consumer_token` methods.\n    '
        bool_0 = module_0.is_valid_ip(str_0)
    except BaseException:
        pass

def test_case_10():
    try:
        dict_0 = None
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = '{((Zf}CY;k%ido}oT:t'
        int_0 = 2048
        resolver_0 = module_0.Resolver()
        awaitable_0 = resolver_0.resolve(str_0, int_0)
        str_1 = 'H@pF )L'
        int_1 = None
        awaitable_1 = resolver_0.resolve(str_1, int_1)
        str_2 = '\x0cQT@jclT!l<'
        int_2 = 18
        socket_0 = module_0.bind_unix_socket(str_2, int_2)
        address_family_0 = module_1.AddressFamily.AF_X25
        bool_0 = True
        list_0 = module_0.bind_sockets(int_1, address_family_0, int_1, int_0, bool_0)
    except BaseException:
        pass

def test_case_12():
    try:
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        str_0 = '\x0cQT@jclT!l<'
        int_0 = 18
        s_s_l_context_0 = module_3.SSLContext()
        s_s_l_context_1 = module_0.ssl_options_to_context(s_s_l_context_0)
        default_executor_resolver_0 = module_0.DefaultExecutorResolver()
        bool_0 = module_0.is_valid_ip(str_0)
        int_1 = 65536
        list_0 = module_0.bind_sockets(int_1)
        int_2 = -3635
        list_1 = module_0.bind_sockets(int_0, int_2)
    except BaseException:
        pass

def test_case_13():
    try:
        str_0 = '192.168.0.1'
        int_0 = 3526
        list_0 = [str_0, str_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        awaitable_0 = override_resolver_0.resolve(str_0, int_0)
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = None
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        str_1 = '.'
        socket_0 = module_1.socket()
        dict_0 = {}
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_0, str_0)
        int_0 = 36
        socket_1 = module_0.bind_unix_socket(str_1, int_0)
    except BaseException:
        pass