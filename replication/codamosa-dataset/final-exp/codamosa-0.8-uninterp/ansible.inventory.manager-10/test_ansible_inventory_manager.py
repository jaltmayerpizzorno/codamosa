# Automatically generated by Pynguin.
import ansible.inventory.manager as module_0

def test_case_0():
    pass

def test_case_1():
    bool_0 = False
    inventory_manager_0 = module_0.InventoryManager(bool_0)
    var_0 = inventory_manager_0.list_hosts()

def test_case_2():
    bool_0 = False
    str_0 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,\n    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n    * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    inventory_manager_0 = module_0.InventoryManager(bool_0, str_0)
    var_0 = inventory_manager_0.refresh_inventory()
    var_1 = inventory_manager_0.list_hosts(bool_0)
    var_2 = inventory_manager_0.parse_source(inventory_manager_0)
    str_1 = ''
    var_3 = inventory_manager_0.list_hosts(str_1)

def test_case_3():
    str_0 = 'x];z3Z\\^Fot}-:t'
    var_0 = module_0.split_host_pattern(str_0)

def test_case_4():
    int_0 = 2033
    var_0 = module_0.split_host_pattern(int_0)

def test_case_5():
    str_0 = 'R\x0c'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)

def test_case_6():
    str_0 = '(8=IZl.Z|qy'
    list_0 = [str_0, str_0]
    inventory_manager_0 = module_0.InventoryManager(str_0, list_0)

def test_case_7():
    int_0 = 2645
    inventory_manager_0 = module_0.InventoryManager(int_0)

def test_case_8():
    str_0 = '"\'|)EYU'
    bool_0 = False
    set_0 = set()
    float_0 = -1094.42
    list_0 = []
    tuple_0 = (bool_0, set_0, float_0, list_0)
    bytes_0 = b''
    inventory_manager_0 = module_0.InventoryManager(tuple_0, bytes_0)
    str_1 = '8?!LN;8S=6\n76M0y'
    var_0 = inventory_manager_0.parse_source(inventory_manager_0, str_1)
    var_1 = inventory_manager_0.get_groups_dict()
    inventory_manager_1 = module_0.InventoryManager(str_0)
    set_1 = None
    var_2 = module_0.split_host_pattern(set_1)

def test_case_9():
    bytes_0 = b'\xf6\xfb\xd7\x1b\x02\xfa\xed\x82s\xf2\xac'
    str_0 = ',Kty|?ji6%j'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.list_hosts()
    dict_0 = {str_0: bytes_0, str_0: bytes_0}
    int_0 = 661
    var_1 = module_0.order_patterns(dict_0)
    list_0 = [inventory_manager_0, int_0]
    var_2 = inventory_manager_0.subset(list_0)
    var_3 = inventory_manager_0.reconcile_inventory()

def test_case_10():
    float_0 = 0.2
    str_0 = '~,GBcxZ%'
    inventory_manager_0 = module_0.InventoryManager(float_0, str_0)
    var_0 = inventory_manager_0.clear_caches()

def test_case_11():
    set_0 = None
    dict_0 = {set_0: set_0}
    int_0 = None
    dict_1 = {int_0: int_0, int_0: int_0}
    inventory_manager_0 = module_0.InventoryManager(dict_1)
    var_0 = inventory_manager_0.parse_source(dict_0)

def test_case_12():
    str_0 = 'R\x0c'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.refresh_inventory()

def test_case_13():
    float_0 = 1034.79
    str_0 = None
    str_1 = ''
    inventory_manager_0 = module_0.InventoryManager(str_1)
    var_0 = inventory_manager_0.get_hosts(float_0, str_0)

def test_case_14():
    str_0 = '(8=IZl.Z|qy'
    list_0 = [str_0, str_0]
    inventory_manager_0 = module_0.InventoryManager(str_0, list_0)
    var_0 = inventory_manager_0.list_groups()

def test_case_15():
    bytes_0 = b'i|X\xcbf$\xe5Kx\xaf\x1a'
    bool_0 = False
    inventory_manager_0 = module_0.InventoryManager(bool_0)
    var_0 = inventory_manager_0.subset(bytes_0)

def test_case_16():
    float_0 = -2216.1921
    inventory_manager_0 = module_0.InventoryManager(float_0)
    var_0 = inventory_manager_0.remove_restriction()
    var_1 = inventory_manager_0.clear_pattern_cache()

def test_case_17():
    bytes_0 = b'\xf6\xfb\xd7\x1b\x02\xfa\xed\x82s\xf2\xac'
    bool_0 = True
    str_0 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,\n    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n    * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    inventory_manager_0 = module_0.InventoryManager(bool_0, str_0)
    var_0 = inventory_manager_0.refresh_inventory()
    int_0 = -2501
    set_0 = {int_0, inventory_manager_0, int_0, bytes_0}
    dict_0 = {str_0: bool_0, int_0: set_0, var_0: inventory_manager_0}
    var_1 = inventory_manager_0.subset(dict_0)
    var_2 = inventory_manager_0.remove_restriction()
    var_3 = inventory_manager_0.list_hosts()
    str_1 = 'rmtree failed: %s'
    var_4 = inventory_manager_0.parse_source(str_1)
    var_5 = inventory_manager_0.list_hosts()

def test_case_18():
    str_0 = 'R\x0c'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.refresh_inventory()
    int_0 = 712
    list_0 = [inventory_manager_0, int_0]
    var_1 = inventory_manager_0.subset(list_0)
    var_2 = inventory_manager_0.list_hosts()

def test_case_19():
    bytes_0 = b'\xf6\xfb\xd7\x1b\x02\xfa\xed\x82s\xf2\xac'
    str_0 = 'R\x0c'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.list_hosts()
    dict_0 = {str_0: bytes_0, str_0: bytes_0}
    var_1 = inventory_manager_0.subset(dict_0)
    int_0 = 661
    list_0 = [inventory_manager_0, str_0, int_0]
    var_2 = inventory_manager_0.get_hosts()
    var_3 = inventory_manager_0.subset(list_0)
    var_4 = inventory_manager_0.list_hosts(list_0)

def test_case_20():
    bytes_0 = b'\xf6\xfb\xd7\x1b\x02\xfa\xed\x82s\xf2\xac'
    str_0 = 'R\x0c'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.list_hosts()
    var_1 = inventory_manager_0.refresh_inventory()
    dict_0 = {str_0: var_1, str_0: bytes_0}
    var_2 = inventory_manager_0.subset(dict_0)
    var_3 = inventory_manager_0.list_hosts()
    str_1 = '~\udc93\udcf5\x12\udcb2'
    var_4 = inventory_manager_0.list_hosts(str_1)

def test_case_21():
    str_0 = 'R\x0c'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.list_hosts()
    int_0 = 661
    var_1 = inventory_manager_0.subset(int_0)
    var_2 = inventory_manager_0.list_hosts()

def test_case_22():
    int_0 = -4292
    list_0 = [int_0, int_0, int_0]
    inventory_manager_0 = module_0.InventoryManager(list_0)
    str_0 = 'D-J\t|73s\x0cQC'
    str_1 = 'Z9Q;2vB'
    var_0 = inventory_manager_0.list_hosts(str_1)
    var_1 = inventory_manager_0.add_host(str_0)
    str_2 = '.config'
    inventory_manager_1 = module_0.InventoryManager(str_2)
    var_2 = inventory_manager_1.parse_sources()
    var_3 = inventory_manager_0.parse_sources()
    inventory_manager_2 = module_0.InventoryManager(inventory_manager_0)
    var_4 = inventory_manager_2.remove_restriction()
    var_5 = inventory_manager_2.get_hosts(list_0)
    var_6 = inventory_manager_1.get_groups_dict()
    int_1 = None
    var_7 = inventory_manager_1.list_hosts()
    inventory_manager_3 = module_0.InventoryManager(str_0)
    var_8 = inventory_manager_1.subset(int_1)

def test_case_23():
    list_0 = []
    bytes_0 = b'*\x9d\x82l\r\xecx\xb9\xb9\x96]\xba\xb9\xa8\xa4\xd5\x02>'
    inventory_manager_0 = module_0.InventoryManager(bytes_0)
    var_0 = inventory_manager_0.restrict_to_hosts(list_0)
    str_0 = 'jfd<,!KKRykZ^6'
    var_1 = inventory_manager_0.subset(str_0)
    var_2 = inventory_manager_0.list_hosts()

def test_case_24():
    str_0 = 'R\x0c'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.list_hosts()
    var_1 = inventory_manager_0.refresh_inventory()
    list_0 = [str_0, inventory_manager_0]
    var_2 = inventory_manager_0.subset(list_0)
    var_3 = inventory_manager_0.refresh_inventory()
    var_4 = inventory_manager_0.subset(inventory_manager_0)
    str_1 = '|"d{MQ%o|$O),'
    var_5 = inventory_manager_0.list_hosts(str_1)

def test_case_25():
    bytes_0 = b'M\xb9a\xc4VQ\xd4R\x1fY`'
    str_0 = 'R\x0c'
    bool_0 = False
    str_1 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,\n    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n    * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    inventory_manager_0 = module_0.InventoryManager(bool_0, str_1)
    var_0 = inventory_manager_0.refresh_inventory()
    int_0 = -1025
    set_0 = {int_0, inventory_manager_0, int_0, bytes_0}
    dict_0 = {str_0: bool_0, int_0: set_0, var_0: inventory_manager_0}
    var_1 = inventory_manager_0.subset(dict_0)
    var_2 = inventory_manager_0.list_hosts(bool_0)
    bool_1 = False
    var_3 = inventory_manager_0.subset(bool_1)
    var_4 = inventory_manager_0.list_hosts()

def test_case_26():
    bool_0 = False
    str_0 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,V    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n   * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    inventory_manager_0 = module_0.InventoryManager(bool_0, str_0)
    dict_0 = None
    var_0 = inventory_manager_0.get_hosts(str_0, dict_0)
    var_1 = inventory_manager_0.list_hosts(bool_0)
    var_2 = inventory_manager_0.parse_source(inventory_manager_0)
    str_1 = ''
    var_3 = inventory_manager_0.list_hosts(str_1)

def test_case_27():
    bytes_0 = b'\xf6\xfb\xd7\x1b\x02\xfa\xed\x82s\xf2\xac'
    list_0 = []
    bytes_1 = b'*\x9d\x82l\r\xecx\xb9\xb9\x96]\xba\xb9\xa8\xa4\xd5\x02>'
    inventory_manager_0 = module_0.InventoryManager(bytes_1)
    var_0 = inventory_manager_0.restrict_to_hosts(list_0)
    bool_0 = False
    str_0 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,\n    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n    * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    inventory_manager_1 = module_0.InventoryManager(bool_0, str_0)
    var_1 = inventory_manager_1.refresh_inventory()
    int_0 = -1025
    var_2 = inventory_manager_1.list_hosts()
    set_0 = {int_0, inventory_manager_1, int_0, bytes_0}
    dict_0 = {str_0: bool_0, int_0: set_0, var_1: inventory_manager_1}
    var_3 = inventory_manager_1.subset(dict_0)
    float_0 = -5583.148
    inventory_manager_2 = module_0.InventoryManager(float_0)
    var_4 = inventory_manager_2.subset(bool_0)
    var_5 = inventory_manager_1.list_hosts(bool_0)
    var_6 = inventory_manager_0.refresh_inventory()
    var_7 = inventory_manager_1.parse_source(dict_0, inventory_manager_1)
    var_8 = inventory_manager_2.list_hosts(inventory_manager_0)

def test_case_28():
    bytes_0 = b'\xf6\xfb\xd7\x1b\x02\xfa\xed\x82s\xf2\xac'
    str_0 = 'R\x0c'
    list_0 = []
    bytes_1 = b'*\xe9\x82l\r\xecx\xb9\xb9\x96]\xba\xb9\xa8\xa9\x04\x02>'
    inventory_manager_0 = module_0.InventoryManager(bytes_1)
    var_0 = inventory_manager_0.restrict_to_hosts(list_0)
    bool_0 = False
    str_1 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,\n    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n    * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    var_1 = inventory_manager_0.list_groups()
    inventory_manager_1 = module_0.InventoryManager(bool_0, str_1)
    var_2 = inventory_manager_0.refresh_inventory()
    int_0 = -1025
    set_0 = {int_0, inventory_manager_1, str_1, inventory_manager_0, int_0, bytes_0}
    dict_0 = {str_0: bool_0, int_0: set_0, var_2: inventory_manager_1}
    var_3 = inventory_manager_1.subset(dict_0)
    float_0 = -5583.148
    inventory_manager_2 = module_0.InventoryManager(float_0)
    var_4 = inventory_manager_2.subset(bool_0)
    var_5 = inventory_manager_1.list_hosts(bool_0)
    var_6 = inventory_manager_1.parse_source(dict_0, inventory_manager_1)
    var_7 = inventory_manager_1.list_hosts()
    var_8 = inventory_manager_1.get_groups_dict()

def test_case_29():
    bytes_0 = b'\xed\x1c\xd1B\xd1=\x98\xf6\x94\xf9p\xbf^{\xedmw\x0ez'
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(bytes_0)
    var_0 = inventory_manager_0.restrict_to_hosts(list_0)
    bool_0 = False
    str_0 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,\n    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n    * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    inventory_manager_1 = module_0.InventoryManager(bool_0, str_0)
    var_1 = inventory_manager_0.refresh_inventory()
    int_0 = -1040
    set_0 = {int_0, inventory_manager_1, int_0, bytes_0}
    dict_0 = {str_0: bool_0, int_0: set_0, var_1: inventory_manager_1}
    var_2 = inventory_manager_1.subset(dict_0)
    float_0 = -5583.148
    inventory_manager_2 = module_0.InventoryManager(float_0)
    var_3 = inventory_manager_0.subset(inventory_manager_2)
    var_4 = inventory_manager_0.list_hosts()
    str_1 = '*,'
    tuple_0 = None
    bytes_1 = b'\\\xf8*\xa2\xba\xb6V~\x86\x15'
    str_2 = 'VW9\x0cj`'
    tuple_1 = (tuple_0, list_0, bytes_1, str_2)
    var_5 = inventory_manager_0.get_hosts(str_1, tuple_1)
    var_6 = inventory_manager_1.list_hosts()
    var_7 = inventory_manager_2.clear_pattern_cache()
    var_8 = inventory_manager_1.parse_source(dict_0)
    bool_1 = True
    var_9 = inventory_manager_0.list_hosts(bool_1)

def test_case_30():
    bytes_0 = b'\xf6\xfb\xd7\x1b\x02\xfa\xed\x82s\xf2\xac'
    bool_0 = True
    str_0 = '\n    Return the version of the current OS distribution, as a human-readable\n    string.\n\n    If *pretty* is false, the version is returned without codename (e.g.\n    "7.0").\n\n    If *pretty* is true, the codename in parenthesis is appended, if the\n    codename is non-empty (e.g. "7.0 (Maipo)").\n\n    Some distributions provide version numbers with different precisions in\n    the different sources of distribution information. Examining the different\n    sources in a fixed priority order does not always yield the most precise\n    version (e.g. for Debian 8.2, or CentOS 7.1).\n\n    The *best* parameter can be used to control the approach for the returned\n    version:\n\n    If *best* is false, the first non-empty version number in priority order of\n    the examined sources is returned.\n\n    If *best* is true, the most precise version number out of all examined\n    sources is returned.\n\n    **Lookup hierarchy:**\n\n    In all cases, the version number is obtained from the following sources.\n    If *best* is false, this order represents the priority order:\n\n    * the value of the "VERSION_ID" attribute of the os-release file,\n    * the value of the "Release" attribute returned by the lsb_release\n      command,\n    * the version number parsed from the "<version_id>" field of the first line\n      of the distro release file,\n    * the version number parsed from the "PRETTY_NAME" attribute of the\n      os-release file, if it follows the format of the distro release files.\n    * the version number parsed from the "Description" attribute returned by\n      the lsb_release command, if it follows the format of the distro release\n      files.\n    '
    inventory_manager_0 = module_0.InventoryManager(bool_0, str_0)
    var_0 = inventory_manager_0.refresh_inventory()
    int_0 = -2501
    set_0 = {int_0, inventory_manager_0, int_0, bytes_0}
    dict_0 = {str_0: bool_0, int_0: set_0, var_0: inventory_manager_0}
    var_1 = inventory_manager_0.subset(dict_0)
    var_2 = inventory_manager_0.remove_restriction()
    var_3 = inventory_manager_0.list_hosts()
    float_0 = 5711.0
    bool_1 = True
    var_4 = inventory_manager_0.subset(bool_1)
    str_1 = 'DAl`r(I|O7b\x0b'
    str_2 = 'rmtree failed: %s'
    var_5 = inventory_manager_0.parse_source(str_2)
    var_6 = inventory_manager_0.parse_source(float_0)
    str_3 = 'MiXMz\r2HC5>F(jsMX*'
    var_7 = inventory_manager_0.get_hosts(str_1, str_3, inventory_manager_0)
    var_8 = inventory_manager_0.clear_caches()
    list_0 = []
    var_9 = inventory_manager_0.list_hosts(list_0)