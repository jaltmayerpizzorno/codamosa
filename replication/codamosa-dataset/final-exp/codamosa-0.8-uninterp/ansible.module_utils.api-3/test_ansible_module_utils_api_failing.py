# Automatically generated by Pynguin.
import ansible.module_utils.api as module_0

def test_case_0():
    try:
        bool_0 = False
        bool_1 = False
        var_0 = module_0.generate_jittered_backoff(bool_1)
        var_1 = module_0.retry(bool_0)
        float_0 = -2571.814237
        var_2 = module_0.rate_limit_argument_spec(float_0)
    except BaseException:
        pass

def test_case_1():
    try:
        float_0 = None
        var_0 = module_0.retry_never(float_0)
        var_1 = module_0.basic_auth_argument_spec()
        list_0 = [float_0, var_0]
        var_2 = module_0.retry_argument_spec(list_0)
    except BaseException:
        pass

def test_case_2():
    try:
        bool_0 = False
        str_0 = "\tO#Voc6!'"
        list_0 = [bool_0, bool_0, str_0]
        tuple_0 = (list_0,)
        str_1 = '\n    Helper class to template all variable content before jinja2 sees it. This is\n    done by hijacking the variable storage that jinja2 uses, and overriding __contains__\n    and __getitem__ to look like a dict. Added bonus is avoiding duplicating the large\n    hashes that inject tends to be.\n\n    To facilitate using builtin jinja2 things like range, globals are also handled here.\n    '
        list_1 = [tuple_0, tuple_0, str_1]
        var_0 = module_0.basic_auth_argument_spec(list_1)
    except BaseException:
        pass

def test_case_3():
    try:
        list_0 = []
        str_0 = 'H]e'
        var_0 = module_0.rate_limit(list_0, str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        var_0 = module_0.retry_argument_spec()
        str_0 = '9Iq!$|oc'
        var_1 = module_0.retry_with_delays_and_condition(str_0)
        var_2 = module_0.generate_jittered_backoff()
        dict_0 = {}
        var_3 = module_0.rate_limit_argument_spec()
        var_4 = module_0.generate_jittered_backoff(dict_0)
        tuple_0 = (dict_0,)
        var_5 = module_0.retry_argument_spec(tuple_0)
    except BaseException:
        pass