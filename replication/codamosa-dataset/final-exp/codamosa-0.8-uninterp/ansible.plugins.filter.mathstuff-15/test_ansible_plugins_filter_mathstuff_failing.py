# Automatically generated by Pynguin.
import ansible.plugins.filter.mathstuff as module_0

def test_case_0():
    try:
        int_0 = 752
        dict_0 = None
        bytes_0 = b'tj\x00_0\xceUy\x98N\x9a\xe2\xc8'
        var_0 = module_0.unique(int_0, dict_0, bytes_0)
    except BaseException:
        pass

def test_case_1():
    try:
        bytes_0 = b'\x1b\xfaa\x9d\xc5\x00\xe5\xd2(R'
        list_0 = [bytes_0]
        var_0 = module_0.symmetric_difference(bytes_0, bytes_0, list_0)
    except BaseException:
        pass

def test_case_2():
    try:
        list_0 = []
        filter_module_0 = module_0.FilterModule(*list_0)
        dict_0 = {}
        tuple_0 = (dict_0, filter_module_0)
        var_0 = module_0.difference(list_0, tuple_0, filter_module_0)
    except BaseException:
        pass

def test_case_3():
    try:
        filter_module_0 = module_0.FilterModule()
        var_0 = filter_module_0.filters()
        dict_0 = None
        bytes_0 = b'hr\xa0'
        int_0 = 254
        var_1 = module_0.symmetric_difference(dict_0, bytes_0, int_0)
    except BaseException:
        pass

def test_case_4():
    try:
        bool_0 = True
        set_0 = set()
        dict_0 = {}
        float_0 = 3322.348913
        var_0 = module_0.intersect(set_0, dict_0, float_0)
        filter_module_0 = module_0.FilterModule(**dict_0)
        var_1 = filter_module_0.filters()
        bytes_0 = b'hYN(\xc1\xa2\xf6a\xcaBR\xc5\xc0\xae\xc6U\x0f'
        bool_1 = True
        var_2 = module_0.union(bool_0, bytes_0, bool_1)
    except BaseException:
        pass

def test_case_5():
    try:
        bytes_0 = b'\x17E'
        list_0 = [bytes_0]
        list_1 = [bytes_0, bytes_0, bytes_0]
        var_0 = module_0.symmetric_difference(bytes_0, list_0, list_1)
        int_0 = 1398
        var_1 = module_0.human_readable(int_0)
        str_0 = 'JKPq~sJ2];RVp1|'
        var_2 = module_0.logarithm(str_0)
    except BaseException:
        pass

def test_case_6():
    try:
        dict_0 = None
        float_0 = 2122.339108
        var_0 = module_0.min(dict_0, float_0)
    except BaseException:
        pass

def test_case_7():
    try:
        int_0 = -2233
        var_0 = module_0.logarithm(int_0)
    except BaseException:
        pass

def test_case_8():
    try:
        dict_0 = None
        list_0 = [dict_0, dict_0, dict_0, dict_0]
        var_0 = module_0.logarithm(list_0)
    except BaseException:
        pass

def test_case_9():
    try:
        bytes_0 = None
        int_0 = -3369
        var_0 = module_0.power(bytes_0, int_0)
    except BaseException:
        pass

def test_case_10():
    try:
        list_0 = None
        var_0 = module_0.inversepower(list_0)
    except BaseException:
        pass

def test_case_11():
    try:
        list_0 = []
        filter_module_0 = module_0.FilterModule(*list_0)
        bool_0 = None
        bytes_0 = b'\xdd=\xca]\x17\x95/ON\xceQG\x80\x0f\xc6'
        var_0 = module_0.inversepower(bool_0, bytes_0)
    except BaseException:
        pass

def test_case_12():
    try:
        bool_0 = True
        float_0 = 1760.0
        bytes_0 = b'hYN(\xc1\xa2\xf6a\xcaBR\xc5\xc0\xae\xc6U\x0f'
        var_0 = module_0.human_readable(bytes_0, bool_0, float_0)
    except BaseException:
        pass

def test_case_13():
    try:
        filter_module_0 = module_0.FilterModule()
        bytes_0 = b"q6\xdfr'-\x90nY8\x14\xbf\x03L#%"
        var_0 = module_0.human_readable(bytes_0)
    except BaseException:
        pass

def test_case_14():
    try:
        int_0 = -752
        var_0 = module_0.human_to_bytes(int_0)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = 'namespace'
        tuple_0 = ()
        int_0 = 885
        dict_0 = {str_0: int_0}
        str_1 = '*qdd}\t9[Pe=|B'
        str_2 = 'Amazon3 E\n2'
        dict_1 = {str_1: str_1, str_2: str_1, str_0: str_2}
        var_0 = module_0.intersect(str_0, dict_0, dict_1)
        bytes_0 = None
        set_0 = {str_0, str_0, tuple_0, tuple_0}
        var_1 = module_0.rekey_on_member(bytes_0, set_0)
    except BaseException:
        pass

def test_case_16():
    try:
        list_0 = None
        filter_module_0 = module_0.FilterModule()
        var_0 = filter_module_0.filters()
        var_1 = module_0.min(list_0, filter_module_0)
    except BaseException:
        pass

def test_case_17():
    try:
        list_0 = None
        list_1 = None
        dict_0 = {list_0: list_0, list_0: list_0, list_0: list_1, list_1: list_0}
        str_0 = '|cm=i#gV9>6;j\\3,ca}7'
        var_0 = module_0.symmetric_difference(list_1, dict_0, str_0)
    except BaseException:
        pass

def test_case_18():
    try:
        filter_module_0 = module_0.FilterModule()
        var_0 = filter_module_0.filters()
        str_0 = 'QD|(#Lj\x0b\x0cBY$W\x0b2n\\]V,'
        float_0 = 2.718281828459045
        list_0 = [float_0]
        var_1 = module_0.difference(str_0, list_0, list_0)
        float_1 = 512.0
        var_2 = module_0.human_readable(float_1)
        float_2 = None
        str_1 = None
        str_2 = '}0'
        var_3 = module_0.difference(str_1, str_2, list_0)
        list_1 = [float_2, float_2, float_2, float_2]
        bool_0 = False
        var_4 = module_0.intersect(float_2, list_1, bool_0)
    except BaseException:
        pass

def test_case_19():
    try:
        str_0 = "9g,l%7h':oa,Z1nL w_"
        str_1 = {str_0: str_0, str_0: str_0}
        str_2 = [str_1, str_1]
        var_0 = module_0.rekey_on_member(str_2, str_1)
    except BaseException:
        pass

def test_case_20():
    try:
        bytes_0 = b'f\x93\xc4x\xf2\\[\xf66i\xf3\xce\xbcT\xff\xd7!U\x12l'
        filter_module_0 = None
        var_0 = module_0.max(bytes_0, filter_module_0)
    except BaseException:
        pass

def test_case_21():
    try:
        list_0 = []
        str_0 = '@<d=_\x0c-.D['
        str_1 = ')m4i]'
        list_1 = [str_0, str_1]
        var_0 = module_0.rekey_on_member(str_1, list_0, list_1)
    except BaseException:
        pass

def test_case_22():
    try:
        str_0 = "invalid semantic version '%s'"
        str_1 = '\n    Loads and returns a list of RoleInclude objects from the ds list of role definitions\n    :param ds: list of roles to load\n    :param play: calling Play object\n    :param current_role_path: path of the owning role, if any\n    :param variable_manager: varmgr to use for templating\n    :param loader: loader to use for DS parsing/services\n    :param collection_search_list: list of collections to search for unqualified role names\n    :return:\n    '
        dict_0 = {str_1: str_1, str_0: str_0}
        tuple_0 = None
        var_0 = module_0.union(str_0, dict_0, tuple_0)
    except BaseException:
        pass

def test_case_23():
    try:
        str_0 = '"\tX;kjQzP|\r>'
        dict_0 = None
        bool_0 = True
        var_0 = module_0.unique(str_0, str_0, dict_0, bool_0)
    except BaseException:
        pass

def test_case_24():
    try:
        int_0 = 1143
        var_0 = module_0.inversepower(int_0)
        bool_0 = False
        str_0 = ']x4ql)\n9'
        var_1 = module_0.rekey_on_member(str_0, bool_0)
    except BaseException:
        pass

def test_case_25():
    try:
        str_0 = "\n    Test the rekey_on_member function\n\n    These tests use python's internal unittest module\n\n    They also include a safety test against a regression in Ansible 2.7.0\n    (https://github.com/ansible/ansible/issues/44418) for which we have a fix\n    and can be removed if the fix is merged in Ansible\n\n    To run these tests, invoke this module directly with Python3:\n      python3 filter_plugins/math.py\n    "
        list_0 = [str_0, str_0]
        bytes_0 = b'\x01\xc9\xe1\xc0\x1e'
        var_0 = module_0.rekey_on_member(list_0, bytes_0)
    except BaseException:
        pass

def test_case_26():
    try:
        str_0 = 'y'
        dict_0 = {str_0: str_0}
        str_1 = 'N4$YA5aK<RAHXUw'
        filter_module_0 = module_0.FilterModule()
        var_0 = module_0.rekey_on_member(dict_0, str_1)
    except BaseException:
        pass

def test_case_27():
    try:
        int_0 = -3546
        set_0 = {int_0}
        str_0 = '+tfJ+qD/'
        var_0 = module_0.max(set_0, str_0)
        float_0 = -2003.6863743698902
        str_1 = '19fc_8T\x0bu^fqeq/^/"\\-'
        filter_module_0 = module_0.FilterModule()
        str_2 = ';}.m>[[D\r;g.8O6'
        dict_0 = {}
        var_1 = module_0.intersect(filter_module_0, str_2, dict_0)
        var_2 = module_0.min(float_0, str_1)
        str_3 = 'p(C tkVB\n_=43_'
        int_1 = 2313
        bool_0 = False
        var_3 = module_0.unique(str_3, int_1, bool_0)
    except BaseException:
        pass

def test_case_28():
    try:
        float_0 = 1387.015502
        int_0 = 1701
        var_0 = module_0.human_to_bytes(float_0, int_0)
    except BaseException:
        pass

def test_case_29():
    try:
        str_0 = 'key1'
        str_1 = 'valU1'
        str_2 = 'val'
        str_3 = {str_0: str_1, str_1: str_2}
        str_4 = [str_3, str_3]
        var_0 = module_0.rekey_on_member(str_4, str_2)
    except BaseException:
        pass

def test_case_30():
    try:
        int_0 = -3546
        set_0 = {int_0}
        str_0 = '+tfJ+qD/'
        var_0 = module_0.max(set_0, str_0)
        float_0 = -2003.3468808690109
        str_1 = '>L=[urzV1R'
        filter_module_0 = module_0.FilterModule()
        str_2 = ';}ym>[[DK;g.8O6'
        dict_0 = {}
        var_1 = module_0.intersect(filter_module_0, str_2, dict_0)
        var_2 = module_0.min(float_0, str_1)
        dict_1 = {}
        bool_0 = True
        tuple_0 = (dict_0, dict_0, bool_0)
        var_3 = module_0.unique(dict_1, tuple_0, str_1, dict_0)
        var_4 = module_0.unique(set_0, dict_1, dict_0, str_2)
        var_5 = filter_module_0.filters()
        var_6 = module_0.power(float_0, float_0)
    except BaseException:
        pass

def test_case_31():
    try:
        str_0 = 'nE\nq'
        str_1 = {str_0: str_0, str_0: str_0, str_0: str_0}
        str_2 = [str_1, str_1]
        var_0 = module_0.rekey_on_member(str_2, str_0)
    except BaseException:
        pass

def test_case_32():
    try:
        float_0 = 1209.0195
        bool_0 = False
        var_0 = module_0.inversepower(float_0, bool_0)
    except BaseException:
        pass