# Automatically generated by Pynguin.
import tornado.locale as module_0
import gettext as module_1

def test_case_0():
    try:
        str_0 = None
        module_0.load_gettext_translations(str_0, str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = "G`B|yTO|c9}lci'y"
        str_1 = "\rWF+Rek)A('R\x0cwl"
        str_2 = 'r\nu9dpH=Av=]'
        str_3 = '*]x1VN[M]\x0b<#<D\x0bp'
        dict_0 = {str_1: str_1, str_2: str_1, str_0: str_3}
        str_4 = 'A command line parsing module that lets modules define their own options.\n\nThis module is inspired by Google\'s `gflags\n<https://github.com/google/python-gflags>`_. The primary difference\nwith libraries such as `argparse` is that a global registry is used so\nthat options may be defined in any module (it also enables\n`tornado.log` by default). The rest of Tornado does not depend on this\nmodule, so feel free to use `argparse` or other configuration\nlibraries if you prefer them.\n\nOptions must be defined with `tornado.options.define` before use,\ngenerally at the top level of a module. The options are then\naccessible as attributes of `tornado.options.options`::\n\n    # myapp/db.py\n    from tornado.options import define, options\n\n    define("mysql_host", default="127.0.0.1:3306", help="Main user DB")\n    define("memcache_hosts", default="127.0.0.1:11011", multiple=True,\n           help="Main user memcache servers")\n\n    def connect():\n        db = database.Connection(options.mysql_host)\n        ...\n\n    # myapp/server.py\n    from tornado.options import define, options\n\n    define("port", default=8080, help="port to listen on")\n\n    def start_server():\n        app = make_app()\n        app.listen(options.port)\n\nThe ``main()`` method of your application does not need to be aware of all of\nthe options used throughout your program; they are all automatically loaded\nwhen the modules are loaded.  However, all modules that define options\nmust have been imported before the command line is parsed.\n\nYour ``main()`` method can parse the command line or parse a config file with\neither `parse_command_line` or `parse_config_file`::\n\n    import myapp.db, myapp.server\n    import tornado.options\n\n    if __name__ == \'__main__\':\n        tornado.options.parse_command_line()\n        # or\n        tornado.options.parse_config_file("/etc/server.conf")\n\n.. note::\n\n   When using multiple ``parse_*`` functions, pass ``final=False`` to all\n   but the last one, or side effects may occur twice (in particular,\n   this can result in log messages being doubled).\n\n`tornado.options.options` is a singleton instance of `OptionParser`, and\nthe top-level functions in this module (`define`, `parse_command_line`, etc)\nsimply call methods on it.  You may create additional `OptionParser`\ninstances to define isolated sets of options, such as for subcommands.\n\n.. note::\n\n   By default, several options are defined that will configure the\n   standard `logging` module when `parse_command_line` or `parse_config_file`\n   are called.  If you want Tornado to leave the logging configuration\n   alone so you can manage it yourself, either pass ``--logging=none``\n   on the command line or do the following to disable it in code::\n\n       from tornado.options import options, parse_command_line\n       options.logging = None\n       parse_command_line()\n\n.. versionchanged:: 4.3\n   Dashes and underscores are fully interchangeable in option names;\n   options can be defined, set, and read with any mix of the two.\n   Dashes are typical for command-line usage while config files require\n   underscores.\n'
        list_0 = [str_4, str_3, str_3]
        locale_0 = module_0.get(*list_0)
        str_5 = locale_0.list(dict_0)
    except BaseException:
        pass

def test_case_2():
    try:
        locale_0 = module_0.get()
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = 'wc'
        locale_0 = module_0.Locale(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = '/v-?A$hA}|JDA'
        list_0 = [str_0, str_0]
        locale_0 = module_0.get(*list_0)
        str_1 = locale_0.list(str_0)
        str_2 = 'S?_CS!Z6CMbHTbH6\x0c='
        str_3 = locale_0.translate(str_2, str_0)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = 'I^}h['
        str_1 = None
        str_2 = 'CD-N8r>F91S;'
        str_3 = '&gt;'
        dict_0 = {}
        dict_1 = {str_3: dict_0}
        c_s_v_locale_0 = module_0.CSVLocale(str_0, dict_1)
        str_4 = c_s_v_locale_0.pgettext(str_1, str_2, str_2)
    except BaseException:
        pass

def test_case_6():
    try:
        str_0 = "HTTP Response object.\n\n    Attributes:\n\n    * ``request``: HTTPRequest object\n\n    * ``code``: numeric HTTP status code, e.g. 200 or 404\n\n    * ``reason``: human-readable reason phrase describing the status code\n\n    * ``headers``: `tornado.httputil.HTTPHeaders` object\n\n    * ``effective_url``: final location of the resource after following any\n      redirects\n\n    * ``buffer``: ``cStringIO`` object for response body\n\n    * ``body``: response body as bytes (created on demand from ``self.buffer``)\n\n    * ``error``: Exception object, if any\n\n    * ``request_time``: seconds from request start to finish. Includes all\n      network operations from DNS resolution to receiving the last byte of\n      data. Does not include time spent in the queue (due to the\n      ``max_clients`` option). If redirects were followed, only includes\n      the final request.\n\n    * ``start_time``: Time at which the HTTP operation started, based on\n      `time.time` (not the monotonic clock used by `.IOLoop.time`). May\n      be ``None`` if the request timed out while in the queue.\n\n    * ``time_info``: dictionary of diagnostic timing information from the\n      request. Available data are subject to change, but currently uses timings\n      available from http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html,\n      plus ``queue``, which is the delay (if any) introduced by waiting for\n      a slot under `AsyncHTTPClient`'s ``max_clients`` setting.\n\n    .. versionadded:: 5.1\n\n       Added the ``start_time`` attribute.\n\n    .. versionchanged:: 5.1\n\n       The ``request_time`` attribute previously included time spent in the queue\n       for ``simple_httpclient``, but not in ``curl_httpclient``. Now queueing time\n       is excluded in both implementations. ``request_time`` is now more accurate for\n       ``curl_httpclient`` because it uses a monotonic clock when available.\n    "
        int_0 = 0
        str_1 = 'u4P9;|I\rQRfh]m6l&_T'
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_1, null_translations_0)
        str_2 = gettext_locale_0.translate(str_0, int_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = '6'
        str_1 = 'Ky^Wj<jU'
        list_0 = [str_0, str_0, str_0, str_1]
        locale_0 = module_0.get(*list_0)
        str_2 = 'jwP%Y;|\nL6}n\ne07T'
        list_1 = [str_2]
        locale_1 = module_0.get(*list_1)
        str_3 = locale_1.list(locale_0)
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = None
        module_0.load_translations(str_0, str_0)
        str_1 = 'F=$2v\nh\n^,\ryBBlJf'
        int_0 = -1703
        str_2 = '1|HdR'
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_2, null_translations_0)
        str_3 = gettext_locale_0.pgettext(str_1, str_1, int_0)
    except BaseException:
        pass

def test_case_9():
    try:
        int_0 = 0
        locale_0 = module_0.get()
        str_0 = locale_0.friendly_number(int_0)
        str_1 = 'HezTrR'
        str_2 = 'O4+*yQDyRmDqhW:'
        dict_0 = None
        str_3 = None
        dict_1 = {str_1: dict_0, str_1: dict_0, str_2: dict_0, str_3: dict_0}
        c_s_v_locale_0 = module_0.CSVLocale(str_2, dict_1)
        str_4 = c_s_v_locale_0.pgettext(str_0, str_1, str_0, int_0)
        str_5 = '?H]\\TuWO\\p%|z`]S'
        module_0.load_translations(str_5)
    except BaseException:
        pass

def test_case_10():
    try:
        int_0 = -2624
        str_0 = None
        str_1 = 'Ep2id&\x0c4\x0c)&0].$o{='
        str_2 = 'single'
        list_0 = [str_0, str_1, str_0, str_2]
        locale_0 = module_0.get(*list_0)
        str_3 = locale_0.friendly_number(int_0)
        datetime_0 = None
        bool_0 = locale_0.format_day(datetime_0)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = "TDVp7)vTwT[\x0b*2'u"
        str_1 = '-)>xH4\tWI%Ux[0C3[[ru'
        bool_0 = None
        locale_0 = module_0.get()
        str_2 = locale_0.pgettext(str_0, str_1, bool_0)
        str_3 = 'oJ,\nH^82y\x0cw]`[Sb{P@'
        str_4 = locale_0.translate(str_3)
        str_5 = 'M1>t<=nk2<jcl1UH'
        str_6 = '\rjY78Mg_-D\\Z<hN'
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_4, null_translations_0)
        str_7 = gettext_locale_0.pgettext(str_5, str_6)
        int_0 = None
        str_8 = locale_0.format_date(int_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = "x0\t'tII0Nu]"
        list_0 = [str_0, str_0]
        locale_0 = module_0.get(*list_0)
        str_1 = 'If-Modified-Since'
        dict_0 = {}
        c_s_v_locale_0 = module_0.CSVLocale(str_1, dict_0)
        str_2 = ')qMd/;,W{AJa8wK?h2'
        c_s_v_locale_1 = module_0.CSVLocale(str_1, dict_0)
        str_3 = 'OW?'
        dict_1 = {c_s_v_locale_1: dict_0, str_0: c_s_v_locale_1, str_0: str_3, c_s_v_locale_1: str_1}
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_4 = gettext_locale_0.translate(str_2, str_1, dict_1)
        int_0 = 4001
        str_5 = locale_0.friendly_number(int_0)
        str_6 = locale_0.list(str_0)
        str_7 = locale_0.pgettext(str_0, str_0)
        locale_1 = module_0.Locale(str_0)
    except BaseException:
        pass

def test_case_13():
    try:
        str_0 = 'fa_IR'
        locale_0 = module_0.Locale(str_0)
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = 'T'
        list_0 = [str_0, str_0]
        str_1 = 'rLghw6a\x0b0vt4##g!L'
        str_2 = 'BNaf\ttVf -[OB}Jy'
        str_3 = '7'
        dict_0 = {}
        dict_1 = {str_3: dict_0, str_0: dict_0}
        c_s_v_locale_0 = module_0.CSVLocale(str_2, dict_1)
        str_4 = c_s_v_locale_0.pgettext(str_1, str_1)
        locale_0 = module_0.get(*list_0)
        int_0 = 4001
        str_5 = locale_0.friendly_number(int_0)
        str_6 = locale_0.list(str_0)
        int_1 = 750
        iterable_0 = module_0.get_supported_locales()
        iterable_1 = module_0.get_supported_locales()
        str_7 = 'Base class for HTTP request handlers.\n\n    Subclasses must define at least one of the methods defined in the\n    "Entry points" section below.\n\n    Applications should not construct `RequestHandler` objects\n    directly and subclasses should not override ``__init__`` (override\n    `~RequestHandler.initialize` instead).\n\n    '
        null_translations_0 = module_1.NullTranslations()
        str_8 = '\t#w\x0bYE[Y(=U!]qP[9'
        gettext_locale_0 = module_0.GettextLocale(str_8, null_translations_0)
        str_9 = '_IOStreamType'
        str_10 = gettext_locale_0.pgettext(str_7, str_9, int_1)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = "O0T'ttI8Nu]"
        str_1 = '-ju3lu8\n? L'
        list_0 = [str_0, str_1, str_0]
        locale_0 = module_0.get(*list_0)
        list_1 = [str_0, str_0]
        locale_1 = module_0.get(*list_1)
        int_0 = 4001
        str_2 = locale_1.friendly_number(int_0)
        str_3 = locale_1.list(list_1)
        str_4 = 'Stream is closed'
        str_5 = '1G4.:8('
        str_6 = locale_1.pgettext(str_4, str_5)
        str_7 = locale_1.list(str_0)
        int_1 = -1039
        str_8 = locale_1.pgettext(str_0, str_0)
        bool_0 = True
        str_9 = locale_1.format_date(int_0, bool_0)
        locale_2 = module_0.get(*list_1)
        str_10 = 'G_dq\x0b{#_!_5kV-D'
        iterable_0 = module_0.get_supported_locales()
        iterable_1 = module_0.get_supported_locales()
        str_11 = '\\'
        null_translations_0 = module_1.NullTranslations(locale_2)
        gettext_locale_0 = module_0.GettextLocale(str_11, null_translations_0)
        str_12 = '[+!,03_`s@-uo3V'
        str_13 = gettext_locale_0.pgettext(str_12, str_2)
        str_14 = '[E%Uo|S7w5;'
        str_15 = ''
        str_16 = gettext_locale_0.pgettext(str_14, str_15, str_10, int_1)
        int_2 = 3501
        str_17 = gettext_locale_0.translate(str_8)
        str_18 = locale_2.translate(str_2, int_2)
    except BaseException:
        pass