# Automatically generated by Pynguin.
import ansible.module_utils.compat.version as module_0

def test_case_0():
    try:
        version_0 = module_0.Version()
        var_0 = version_0.__repr__()
    except BaseException:
        pass

def test_case_1():
    try:
        bool_0 = None
        version_0 = module_0.Version()
        var_0 = version_0.__eq__(bool_0)
    except BaseException:
        pass

def test_case_2():
    try:
        int_0 = 63
        str_0 = '\n---\nauthor: Ansible Core Team (@ansible)\nmodule: include_role\nshort_description: Load and execute a role\ndescription:\n  - Dynamically loads and executes a specified role as a task.\n  - May be used only where Ansible tasks are allowed - inside C(pre_tasks), C(tasks), or C(post_tasks) play objects, or as a task inside a role.\n  - Task-level keywords, loops, and conditionals apply only to the C(include_role) statement itself.\n  - To apply keywords to the tasks within the role, pass them using the C(apply) option or use M(ansible.builtin.import_role) instead.\n  - Ignores some keywords, like C(until) and C(retries).\n  - This module is also supported for Windows targets.\n  - Does not work in handlers.\nversion_added: "2.2"\noptions:\n  apply:\n    description:\n      - Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to all tasks within the included role.\n    version_added: \'2.7\'\n  name:\n    description:\n      - The name of the role to be executed.\n    type: str\n    required: True\n  tasks_from:\n    description:\n      - File to load from a role\'s C(tasks/) directory.\n    type: str\n    default: main\n  vars_from:\n    description:\n      - File to load from a role\'s C(vars/) directory.\n    type: str\n    default: main\n  defaults_from:\n    description:\n      - File to load from a role\'s C(defaults/) directory.\n    type: str\n    default: main\n  allow_duplicates:\n    description:\n      - Overrides the role\'s metadata setting to allow using a role more than once with the same parameters.\n    type: bool\n    default: yes\n  public:\n    description:\n      - This option dictates whether the role\'s C(vars) and C(defaults) are exposed to the play. If set to C(yes)\n        the variables will be available to tasks following the C(include_role) task. This functionality differs from\n        standard variable exposure for roles listed under the C(roles) header or C(import_role) as they are exposed\n        to the play at playbook parsing time, and available to earlier roles and tasks as well.\n    type: bool\n    default: no\n    version_added: \'2.7\'\n  handlers_from:\n    description:\n      - File to load from a role\'s C(handlers/) directory.\n    type: str\n    default: main\n    version_added: \'2.8\'\n  rolespec_validate:\n    description:\n      - Perform role argument spec validation if an argument spec is defined.\n    type: bool\n    default: yes\n    version_added: \'2.11\'\nextends_documentation_fragment:\n    - action_common_attributes\n    - action_common_attributes.conn\n    - action_common_attributes.flow\n    - action_core\n    - action_core.include\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\nnotes:\n  - Handlers and are made available to the whole play.\n  - After Ansible 2.4, you can use M(ansible.builtin.import_role) for C(static) behaviour and this action for C(dynamic) one.\nseealso:\n- module: ansible.builtin.import_playbook\n- module: ansible.builtin.import_role\n- module: ansible.builtin.import_tasks\n- module: ansible.builtin.include_tasks\n- ref: playbooks_reuse_includes\n  description: More information related to including and importing playbooks, roles and tasks.\n'
        loose_version_0 = module_0.LooseVersion()
        var_0 = loose_version_0.parse(str_0)
        version_0 = module_0.Version()
        var_1 = version_0.__lt__(int_0)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = '?\t()0'
        bytes_0 = b''
        dict_0 = {str_0: bytes_0, bytes_0: str_0, bytes_0: bytes_0}
        version_0 = module_0.Version()
        var_0 = version_0.__le__(dict_0)
    except BaseException:
        pass

def test_case_4():
    try:
        int_0 = 307
        version_0 = module_0.Version()
        var_0 = version_0.__gt__(int_0)
    except BaseException:
        pass

def test_case_5():
    try:
        strict_version_0 = module_0.StrictVersion()
        str_0 = '66y\x0b'
        var_0 = strict_version_0.parse(str_0)
    except BaseException:
        pass

def test_case_6():
    try:
        loose_version_0 = module_0.LooseVersion()
        var_0 = loose_version_0.__str__()
    except BaseException:
        pass

def test_case_7():
    try:
        dict_0 = {}
        version_0 = module_0.Version()
        var_0 = version_0.__ge__(dict_0)
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = '\n---\nauthor: Ansible Core Team (@ansible)\nmodule: include_role\nshort_description: Load and execute a role\ndescription:\n  - Dynamically loads and executes a specified role as a task.\n  - May be used only where Ansible tasks are allowed - inside C(pre_tasks), C(tasks), or C(post_tasks) play objects, or as a task inside a role.\n  - Task-level keywords, loops, and conditionals apply only to the C(include_role) statement itself.\n  - To apply keywords to the tasks within the role, pass them using the C(apply) option or use M(ansible.builtin.import_role) instead.\n  - Ignores some keywords, like C(until) and C(retries).\n  - This module is also supported for Windows targets.\n  - Does not work in handlers.\nversion_added: "2.2"\noptions:\n  apply:\n    description:\n      - Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to all tasks within the included role.\n    version_added: \'2.7\'\n  name:\n    description:\n      - The name of the role to be executed.\n    type: str\n    required: True\n  tasks_from:\n    description:\n      - File to load from a role\'s C(tasks/) directory.\n    type: str\n    default: main\n  vars_from:\n    description:\n      - File to load from a role\'s C(vars/) directory.\n    type: str\n    default: main\n  defaults_from:\n    description:\n      - File to load from a role\'s C(defaults/) directory.\n    type: str\n    default: main\n  allow_duplicates:\n    description:\n      - Overrides the role\'s metadata setting to allow using a role more than once with the same parameters.\n    type: bool\n    default: yes\n  public:\n    description:\n      - This option dictates whether the role\'s C(vars) and C(defaults) are exposed to the play. If set to C(yes)\n        the variables will be available to tasks following the C(include_role) task. This functionality differs from\n        standard variable exposure for roles listed under the C(roles) header or C(import_role) as they are exposed\n        to the play at playbook parsing time, and available to earlier roles and tasks as well.\n    type: bool\n    default: no\n    version_added: \'2.7\'\n  handlers_from:\n    description:\n      - File to load from a role\'s C(handlers/) directory.\n    type: str\n    default: main\n    version_added: \'2.8\'\n  rolespec_validate:\n    description:\n      - Perform role argument spec validation if an argument spec is defined.\n    type: bool\n    default: yes\n    version_added: \'2.11\'\nextends_documentation_fragment:\n    - action_common_attributes\n    - action_common_attributes.conn\n    - action_common_attributes.flow\n    - action_core\n    - action_core.include\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\nnotes:\n  - Handlers and are made available to the whole play.\n  - After Ansible 2.4, you can use M(ansible.builtin.import_role) for C(static) behaviour and this action for C(dynamic) one.\nseealso:\n- module: ansible.builtin.import_playbook\n- module: ansible.builtin.import_role\n- module: ansible.builtin.import_tasks\n- module: ansible.builtin.include_tasks\n- ref: playbooks_reuse_includes\n  description: More information related to including and importing playbooks, roles and tasks.\n'
        loose_version_0 = module_0.LooseVersion()
        var_0 = loose_version_0.parse(str_0)
        version_0 = module_0.Version()
        strict_version_0 = module_0.StrictVersion()
        var_1 = strict_version_0.__str__()
    except BaseException:
        pass