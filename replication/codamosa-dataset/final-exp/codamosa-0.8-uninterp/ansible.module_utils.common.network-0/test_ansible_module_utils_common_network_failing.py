# Automatically generated by Pynguin.
import ansible.module_utils.common.network as module_0

def test_case_0():
    try:
        str_0 = ' f;9<Y,\x0c}X8l\rOumLO'
        var_0 = module_0.to_netmask(str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        set_0 = set()
        var_0 = module_0.to_masklen(set_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = "k_'zwy_]})u"
        bool_0 = True
        var_0 = module_0.to_subnet(str_0, bool_0)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = '255.255.2gIn'
        var_0 = module_0.to_bits(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        set_0 = set()
        var_0 = module_0.is_masklen(set_0)
    except BaseException:
        pass

def test_case_5():
    try:
        int_0 = -2327
        var_0 = module_0.to_netmask(int_0)
    except BaseException:
        pass

def test_case_6():
    try:
        bool_0 = True
        int_0 = None
        var_0 = module_0.to_subnet(bool_0, int_0, int_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = '255.255.255.0'
        str_1 = '192.168.5.5'
        str_2 = '255.255.0.0'
        var_0 = module_0.to_subnet(str_1, str_2)
        str_3 = '\n---\nmodule: copy\nversion_added: historical\nshort_description: Copy files to remote locations\ndescription:\n    - The C(copy) module copies a file from the local or remote machine to a location on the remote machine.\n    - Use the M(ansible.builtin.fetch) module to copy files from remote locations to the local box.\n    - If you need variable interpolation in copied files, use the M(ansible.builtin.template) module.\n      Using a variable in the C(content) field will result in unpredictable output.\n    - For Windows targets, use the M(ansible.windows.win_copy) module instead.\noptions:\n  src:\n    description:\n    - Local path to a file to copy to the remote server.\n    - This can be absolute or relative.\n    - If path is a directory, it is copied recursively. In this case, if path ends\n      with "/", only inside contents of that directory are copied to destination.\n      Otherwise, if it does not end with "/", the directory itself with all contents\n      is copied. This behavior is similar to the C(rsync) command line tool.\n    type: path\n  content:\n    description:\n    - When used instead of C(src), sets the contents of a file directly to the specified value.\n    - Works only when C(dest) is a file. Creates the file if it does not exist.\n    - For advanced formatting or if C(content) contains a variable, use the\n      M(ansible.builtin.template) module.\n    type: str\n    version_added: \'1.1\'\n  dest:\n    description:\n    - Remote absolute path where the file should be copied to.\n    - If C(src) is a directory, this must be a directory too.\n    - If C(dest) is a non-existent path and if either C(dest) ends with "/" or C(src) is a directory, C(dest) is created.\n    - If I(dest) is a relative path, the starting directory is determined by the remote host.\n    - If C(src) and C(dest) are files, the parent directory of C(dest) is not created and the task fails if it does not already exist.\n    type: path\n    required: yes\n  backup:\n    description:\n    - Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.\n    type: bool\n    default: no\n    version_added: \'0.7\'\n  force:\n    description:\n    - Influence whether the remote file must always be replaced.\n    - If C(yes), the remote file will be replaced when contents are different than the source.\n    - If C(no), the file will only be transferred if the destination does not exist.\n    - Alias C(thirsty) has been deprecated and will be removed in 2.13.\n    type: bool\n    default: yes\n    aliases: [ thirsty ]\n    version_added: \'1.1\'\n  mode:\n    description:\n    - The permissions of the destination file or directory.\n    - For those used to C(/usr/bin/chmod) remember that modes are actually octal numbers.\n      You must either add a leading zero so that Ansible\'s YAML parser knows it is an octal number\n      (like C(0644) or C(01777)) or quote it (like C(\'644\') or C(\'1777\')) so Ansible receives a string\n      and can do its own conversion from string into number. Giving Ansible a number without following\n      one of these rules will end up with a decimal number which will have unexpected results.\n    - As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\n    - As of Ansible 2.3, the mode may also be the special string C(preserve).\n    - C(preserve) means that the file will be given the same permissions as the source file.\n    - When doing a recursive copy, see also C(directory_mode).\n    - If C(mode) is not specified and the destination file B(does not) exist, the default C(umask) on the system will be used\n      when setting the mode for the newly created file.\n    - If C(mode) is not specified and the destination file B(does) exist, the mode of the existing file will be used.\n    - Specifying C(mode) is the best way to ensure files are created with the correct permissions.\n      See CVE-2020-1736 for further details.\n  directory_mode:\n    description:\n    - When doing a recursive copy set the mode for the directories.\n    - If this is not set we will use the system defaults.\n    - The mode is only set on directories which are newly created, and will not affect those that already existed.\n    type: raw\n    version_added: \'1.5\'\n  remote_src:\n    description:\n    - Influence whether C(src) needs to be transferred or already is present remotely.\n    - If C(no), it will search for C(src) on the controller node.\n    - If C(yes) it will search for C(src) on the managed (remote) node.\n    - C(remote_src) supports recursive copying as of version 2.8.\n    - C(remote_src) only works with C(mode=preserve) as of version 2.6.\n    - Autodecryption of files does not work when C(remote_src=yes).\n    type: bool\n    default: no\n    version_added: \'2.0\'\n  follow:\n    description:\n    - This flag indicates that filesystem links in the destination, if they exist, should be followed.\n    type: bool\n    default: no\n    version_added: \'1.8\'\n  local_follow:\n    description:\n    - This flag indicates that filesystem links in the source tree, if they exist, should be followed.\n    type: bool\n    default: yes\n    version_added: \'2.4\'\n  checksum:\n    description:\n    - SHA1 checksum of the file being transferred.\n    - Used to validate that the copy of the file was successful.\n    - If this is not provided, ansible will use the local calculated checksum of the src file.\n    type: str\n    version_added: \'2.5\'\nextends_documentation_fragment:\n    - decrypt\n    - files\n    - validate\n    - action_common_attributes\n    - action_common_attributes.files\n    - action_common_attributes.flow\nnotes:\n    - The M(ansible.builtin.copy) module recursively copy facility does not scale to lots (>hundreds) of files.\nseealso:\n    - module: ansible.builtin.assemble\n    - module: ansible.builtin.fetch\n    - module: ansible.builtin.file\n    - module: ansible.builtin.template\n    - module: ansible.posix.synchronize\n    - module: ansible.windows.win_copy\nauthor:\n    - Ansible Core Team\n    - Michael DeHaan\nattributes:\n  action:\n    support: full\n  async:\n    support: none\n  bypass_host_loop:\n    support: none\n  check_mode:\n    support: full\n  diff_mode:\n    support: full\n  platform:\n    platforms: posix\n  safe_file_operations:\n      support: full\n  vault:\n    support: full\n    version_added: \'2.2\'\n'
        var_1 = module_0.to_ipv6_subnet(str_3)
        int_0 = 3012
        dict_0 = {str_0: var_1, var_1: int_0}
        int_1 = 3016
        var_2 = module_0.to_subnet(int_0, dict_0, int_1)
    except BaseException:
        pass