# Automatically generated by Pynguin.
import tornado.options as module_0
import datetime as module_1

def test_case_0():
    try:
        str_0 = 'Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n           If the `IOLoop` implementation supports non-integer objects\n           for "file descriptors", those objects will have their\n           ``close`` method when ``all_fds`` is true.\n        '
        option_parser_0 = module_0.OptionParser()
        mockable_0 = option_parser_0.mockable()
        mockable_0.__setattr__(str_0, str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        option_parser_0 = module_0.OptionParser()
        var_0 = iter(option_parser_0)
        var_1 = next(var_0)
        str_0 = ''
        dict_0 = option_parser_0.group_dict(str_0)
        var_2 = Exception(var_0)
        str_1 = '|\rbJOK]'
        bool_0 = option_parser_0.__contains__(str_1)
        str_2 = ';dlML.;|\x0c\\D%'
        dict_1 = option_parser_0.group_dict(str_2)
        dict_2 = option_parser_0.group_dict(str_1)
        iterable_0 = option_parser_0.items()
        list_0 = module_0.parse_command_line(iterable_0)
    except BaseException:
        pass

def test_case_2():
    try:
        option_parser_0 = module_0.OptionParser()
        str_0 = '--'
        option_parser_0.__setattr__(str_0, str_0)
    except BaseException:
        pass

def test_case_3():
    try:
        error_0 = module_0.Error()
        str_0 = '6cX4,ix+19&|\\>EU4'
        option_parser_0 = module_0.OptionParser()
        any_0 = option_parser_0.__getitem__(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        option_parser_0 = module_0.OptionParser()
        dict_0 = option_parser_0.as_dict()
        str_0 = 'azdw^N0K'
        option_parser_0.__setitem__(str_0, str_0)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = 'Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n           If the `IOLoop` implementation supports non-integer objects\n           for "file descriptors", those objects will have their\n           ``close`` method when ``all_fds`` is true.\n        '
        option_parser_0 = module_0.OptionParser()
        set_0 = option_parser_0.groups()
        option_parser_1 = module_0.OptionParser()
        dict_0 = option_parser_0.group_dict(str_0)
        mockable_0 = option_parser_1.mockable()
        mockable_0.__setattr__(str_0, str_0)
    except BaseException:
        pass

def test_case_6():
    try:
        option_parser_0 = module_0.OptionParser()
        str_0 = '"%TD6\tDb zC8wAapm'
        list_0 = []
        dict_0 = {str_0: str_0, str_0: str_0, str_0: list_0}
        module_0.define(str_0, option_parser_0, dict_0)
        str_1 = '--he)'
        list_1 = option_parser_0.parse_command_line(str_1)
    except BaseException:
        pass

def test_case_7():
    try:
        list_0 = module_0.parse_command_line()
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = 'B'
        str_1 = 'uB}Dr='
        list_0 = [str_0, str_0, str_1, str_1]
        bool_0 = False
        option_parser_0 = module_0.OptionParser()
        list_1 = option_parser_0.parse_command_line(list_0, bool_0)
        str_2 = '[UAvE(.e2"JT}Mm'
        dict_0 = {str_0: str_0, str_2: list_0, str_1: list_1, str_1: option_parser_0}
        error_0 = module_0.Error(**dict_0)
    except BaseException:
        pass

def test_case_9():
    try:
        set_0 = None
        list_0 = [set_0]
        error_0 = module_0.Error(*list_0)
        option_parser_0 = module_0.OptionParser()
        tuple_0 = (set_0, error_0, option_parser_0)
        iterable_0 = option_parser_0.items()
        callable_0 = None
        module_0.add_parse_callback(callable_0)
        list_1 = [tuple_0, error_0, list_0, tuple_0]
        error_1 = module_0.Error(*list_1)
        str_0 = 'HWR=U:ff>&Pzlf'
        mockable_0 = option_parser_0.mockable()
        module_0.define(str_0, str_0)
        option_parser_1 = module_0.OptionParser()
        option_parser_0.add_parse_callback(callable_0)
        str_1 = 'rqh_#U.H)YKi'
        dict_0 = option_parser_0.group_dict(str_1)
        mockable_1 = module_0._Mockable(option_parser_1)
        str_2 = ''
        mockable_1.__delattr__(str_2)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = 'sq=z"(Vam\r7Q'
        optional_0 = None
        option_0 = module_0._Option(str_0, optional_0)
    except BaseException:
        pass

def test_case_11():
    try:
        option_parser_0 = module_0.OptionParser()
        iterable_0 = option_parser_0.items()
        str_0 = 'khxP&Ae'
        option_0 = module_0._Option(str_0, str_0, option_parser_0)
        any_0 = option_0.parse(str_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = '$"b|vMeXMH'
        module_0.parse_config_file(str_0)
    except BaseException:
        pass

def test_case_13():
    try:
        module_0.print_help()
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = '-'
        option_parser_0 = module_0.OptionParser()
        dict_0 = option_parser_0.group_dict(str_0)
        option_parser_1 = module_0.OptionParser()
        iterator_0 = option_parser_1.__iter__()
        dict_1 = option_parser_1.as_dict()
        str_1 = '--he)'
        list_0 = [str_0]
        module_0.add_parse_callback(list_0)
        list_1 = option_parser_1.parse_command_line(str_1)
    except BaseException:
        pass

def test_case_15():
    try:
        bool_0 = True
        list_0 = module_0.parse_command_line(bool_0)
    except BaseException:
        pass

def test_case_16():
    try:
        str_0 = '0-zx{M3^H Xy1dP'
        module_0.print_help(str_0)
    except BaseException:
        pass

def test_case_17():
    try:
        str_0 = None
        option_parser_0 = module_0.OptionParser()
        mockable_0 = module_0._Mockable(option_parser_0)
        any_0 = mockable_0.__getattr__(str_0)
    except BaseException:
        pass

def test_case_18():
    try:
        set_0 = None
        list_0 = [set_0]
        error_0 = module_0.Error(*list_0)
        option_parser_0 = module_0.OptionParser()
        tuple_0 = (set_0, error_0, option_parser_0)
        iterable_0 = option_parser_0.items()
        list_1 = [tuple_0, error_0, list_0, tuple_0]
        error_1 = module_0.Error(*list_1)
        str_0 = 'HWR=U:ff>&Pzlf'
        mockable_0 = option_parser_0.mockable()
        module_0.define(str_0, str_0)
    except BaseException:
        pass

def test_case_19():
    try:
        option_parser_0 = module_0.OptionParser()
        iterator_0 = option_parser_0.__iter__()
        iterator_1 = option_parser_0.__iter__()
        optional_0 = None
        list_0 = [optional_0, iterator_0, optional_0, iterator_0]
        error_0 = module_0.Error(*list_0)
        str_0 = '_WJ\t`_*(]a'
        option_parser_1 = module_0.OptionParser()
        bool_0 = option_parser_1.__contains__(str_0)
        str_1 = '}Qxum<rPybQ!'
        str_2 = '`I1f'
        str_3 = '0Jw!F6,l\n9w\\? +`zsx3'
        dict_0 = option_parser_0.group_dict(str_2)
        str_4 = '\\85OZ}RE'
        option_0 = module_0._Option(str_4, str_3, str_3)
        any_0 = option_0.value()
        option_0.set(optional_0)
        option_parser_0.run_parse_callbacks()
        module_0.parse_config_file(str_1)
    except BaseException:
        pass

def test_case_20():
    try:
        str_0 = '/input/tornado/log.py'
        module_0.parse_config_file(str_0)
    except BaseException:
        pass

def test_case_21():
    try:
        option_parser_0 = module_0.OptionParser()
        str_0 = '*\tR-NYB^_?'
        var_0 = None
        option_parser_0.define(str_0, var_0)
        var_1 = setattr(option_parser_0, str_0, option_parser_0)
    except BaseException:
        pass

def test_case_22():
    try:
        list_0 = module_0.parse_command_line()
    except BaseException:
        pass

def test_case_23():
    try:
        str_0 = 'Testing _Option.set(self, value)'
        var_0 = print(str_0)
        str_1 = 'name'
        var_1 = None
        bool_0 = True
        option_0 = module_0._Option(str_1, var_1, var_1, var_1, var_1, bool_0, var_1, var_1, var_1)
    except BaseException:
        pass

def test_case_24():
    try:
        option_parser_0 = module_0.OptionParser()
        str_0 = '/input/tornado/log.py'
        option_parser_0.parse_config_file(str_0)
        bool_0 = None
        option_parser_0.parse_config_file(str_0, bool_0)
        set_0 = option_parser_0.groups()
        dict_0 = option_parser_0.as_dict()
        list_0 = module_0.parse_command_line()
    except BaseException:
        pass

def test_case_25():
    try:
        str_0 = '--test3'
        str_1 = [str_0, str_0, str_0]
        option_parser_0 = module_0.OptionParser()
        str_2 = 'test3'
        option_parser_0.define(str_2, str_0, str_1)
        list_0 = option_parser_0.parse_command_line(str_1)
    except BaseException:
        pass

def test_case_26():
    try:
        option_parser_0 = module_0.OptionParser()
        iterator_0 = option_parser_0.__iter__()
        str_0 = 'Provides an iterator to yield the results of awaitables as they finish.\n\n    Yielding a set of awaitables like this:\n\n    ``results = yield [awaitable1, awaitable2]``\n\n    pauses the coroutine until both ``awaitable1`` and ``awaitable2``\n    return, and then restarts the coroutine with the results of both\n    awaitables. If either awaitable raises an exception, the\n    expression will raise that exception and all the results will be\n    lost.\n\n    If you need to get the result of each awaitable as soon as possible,\n    or if you need the result of some awaitables even if others produce\n    errors, you can use ``WaitIterator``::\n\n      wait_iterator = gen.WaitIterator(awaitable1, awaitable2)\n      while not wait_iterator.done():\n          try:\n              result = yield wait_iterator.next()\n          except Exception as e:\n              print("Error {} from {}".format(e, wait_iterator.current_future))\n          else:\n              print("Result {} received from {} at {}".format(\n                  result, wait_iterator.current_future,\n                  wait_iterator.current_index))\n\n    Because results are returned as soon as they are available the\n    output from the iterator *will not be in the same order as the\n    input arguments*. If you need to know which future produced the\n    current result, you can use the attributes\n    ``WaitIterator.current_future``, or ``WaitIterator.current_index``\n    to get the index of the awaitable from the input list. (if keyword\n    arguments were used in the construction of the `WaitIterator`,\n    ``current_index`` will use the corresponding keyword).\n\n    On Python 3.5, `WaitIterator` implements the async iterator\n    protocol, so it can be used with the ``async for`` statement (note\n    that in this version the entire iteration is aborted if any value\n    raises an exception, while the previous example can continue past\n    individual errors)::\n\n      async for result in gen.WaitIterator(future1, future2):\n          print("Result {} received from {} at {}".format(\n              result, wait_iterator.current_future,\n              wait_iterator.current_index))\n\n    .. versionadded:: 4.1\n\n    .. versionchanged:: 4.3\n       Added ``async for`` support in Python 3.5.\n\n    '
        dict_0 = {str_0: str_0, str_0: str_0, str_0: str_0, str_0: str_0}
        str_1 = 'AkYL\x0b5@+P{-ed;p LJ'
        str_2 = '6mSp\\t"\\?nO3:;'
        option_parser_0.define(str_1, str_2)
        bool_0 = False
        option_0 = module_0._Option(str_0, dict_0, bool_0, str_0, str_0, str_0)
        mockable_0 = module_0._Mockable(option_parser_0)
        option_0.set(iterator_0)
    except BaseException:
        pass

def test_case_27():
    try:
        str_0 = None
        str_1 = '[sP\\otY=F/\n +Q'
        str_2 = '\x0cC,&HV'
        list_0 = [str_0, str_1, str_2]
        str_3 = 'H51d<w'
        bool_0 = False
        option_0 = module_0._Option(str_3, str_3, str_3, bool_0, str_3, str_3, str_1)
        option_0.set(list_0)
    except BaseException:
        pass

def test_case_28():
    try:
        option_parser_0 = module_0.OptionParser()
        var_0 = iter(option_parser_0)
        var_1 = next(var_0)
        str_0 = '+c#+\r,\x0b0Mn]x9C?'
        bool_0 = option_parser_0.__contains__(str_0)
        str_1 = '--database=mysql://user:pass@proximus.modulusmongo.net:27017/I7wixeqa'
        str_2 = '\r01GVP)n.=f{(x#r99'
        mockable_0 = module_0._Mockable(option_parser_0)
        str_3 = ')'
        dict_0 = option_parser_0.group_dict(str_3)
        dict_1 = option_parser_0.as_dict()
        option_parser_1 = module_0.OptionParser()
        option_parser_2 = module_0.OptionParser()
        str_4 = 't}'
        timedelta_0 = module_1.timedelta()
        optional_0 = None
        option_0 = module_0._Option(str_4, optional_0, bool_0, str_3, str_1, mockable_0)
        any_0 = option_0.parse(str_2)
    except BaseException:
        pass

def test_case_29():
    try:
        option_parser_0 = module_0.OptionParser()
        var_0 = iter(option_parser_0)
        var_1 = next(var_0)
        str_0 = '+c#+\r,\x0b0Mn]x9C?'
        bool_0 = option_parser_0.__contains__(str_0)
        option_parser_0.print_help()
        str_1 = "'^I"
        str_2 = '\r01GVP)nA=f{WxRr99'
        str_3 = 'Override to enable support for allowing alternate origins.\n\n        The ``origin`` argument is the value of the ``Origin`` HTTP\n        header, the url responsible for initiating this request.  This\n        method is not called for clients that do not send this header;\n        such requests are always allowed (because all browsers that\n        implement WebSockets support this header, and non-browser\n        clients do not have the same cross-site security concerns).\n\n        Should return ``True`` to accept the request or ``False`` to\n        reject it. By default, rejects all requests with an origin on\n        a host other than this one.\n\n        This is a security protection against cross site scripting attacks on\n        browsers, since WebSockets are allowed to bypass the usual same-origin\n        policies and don\'t use CORS headers.\n\n        .. warning::\n\n           This is an important security measure; don\'t disable it\n           without understanding the security implications. In\n           particular, if your authentication is cookie-based, you\n           must either restrict the origins allowed by\n           ``check_origin()`` or implement your own XSRF-like\n           protection for websocket connections. See `these\n           <https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html>`_\n           `articles\n           <https://devcenter.heroku.com/articles/websocket-security>`_\n           for more.\n\n        To accept all cross-origin traffic (which was the default prior to\n        Tornado 4.0), simply override this method to always return ``True``::\n\n            def check_origin(self, origin):\n                return True\n\n        To allow connections from any subdomain of your site, you might\n        do something like::\n\n            def check_origin(self, origin):\n                parsed_origin = urllib.parse.urlparse(origin)\n                return parsed_origin.netloc.endswith(".mydomain.com")\n\n        .. versionadded:: 4.0\n\n        '
        bool_1 = True
        option_parser_0.define(str_3, bool_1)
        mockable_0 = module_0._Mockable(option_parser_0)
        str_4 = ')'
        dict_0 = option_parser_0.group_dict(str_4)
        option_parser_1 = module_0.OptionParser()
        option_parser_2 = module_0.OptionParser()
        iterable_0 = option_parser_0.items()
        mockable_0.__setattr__(str_3, bool_0)
        mockable_0.__setattr__(str_2, str_1)
    except BaseException:
        pass