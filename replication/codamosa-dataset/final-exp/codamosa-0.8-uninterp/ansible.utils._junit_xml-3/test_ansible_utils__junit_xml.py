# Automatically generated by Pynguin.
import ansible.utils._junit_xml as module_0

def test_case_0():
    pass

def test_case_1():
    test_failure_0 = module_0.TestFailure()

def test_case_2():
    str_0 = 'aaa'
    test_error_0 = module_0.TestError(str_0)
    dict_0 = test_error_0.get_attributes()

def test_case_3():
    str_0 = 'Test case name'
    test_case_0 = module_0.TestCase(str_0)
    element_0 = test_case_0.get_xml_element()

def test_case_4():
    str_0 = 'TestSuite'
    test_suite_0 = module_0.TestSuite(str_0)
    element_0 = test_suite_0.get_xml_element()

def test_case_5():
    str_0 = '\n---\nmodule: copy\nversion_added: historical\nshort_description: Copy files to remote locations\ndescription:\n    - The C(copy) module copies a file from the local or remote machine to a location on the remote machine.\n    - Use the M(ansible.builtin.fetch) module to copy files from remote locations to the local box.\n    - If you need variable interpolation in copied files, use the M(ansible.builtin.template) module.\n      Using a variable in the C(content) field will result in unpredictable output.\n    - For Windows targets, use the M(ansible.windows.win_copy) module instead.\noptions:\n  src:\n    description:\n    - Local path to a file to copy to the remote server.\n    - This can be absolute or relative.\n    - If path is a directory, it is copied recursively. In this case, if path ends\n      with "/", only inside contents of that directory are copied to destination.\n      Otherwise, if it does not end with "/", the directory itself with all contents\n      is copied. This behavior is similar to the C(rsync) command line tool.\n    type: path\n  content:\n    description:\n    - When used instead of C(src), sets the contents of a file directly to the specified value.\n    - Works only when C(dest) is a file. Creates the file if it does not exist.\n    - For advanced formatting or if C(content) contains a variable, use the\n      M(ansible.builtin.template) module.\n    type: str\n    version_added: \'1.1\'\n  dest:\n    description:\n    - Remote absolute path where the file should be copied to.\n    - If C(src) is a directory, this must be a directory too.\n    - If C(dest) is a non-existent path and if either C(dest) ends with "/" or C(src) is a directory, C(dest) is created.\n    - If I(dest) is a relative path, the starting directory is determined by the remote host.\n    - If C(src) and C(dest) are files, the parent directory of C(dest) is not created and the task fails if it does not already exist.\n    type: path\n    required: yes\n  backup:\n    description:\n    - Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.\n    type: bool\n    default: no\n    version_added: \'0.7\'\n  force:\n    description:\n    - Influence whether the remote file must always be replaced.\n    - If C(yes), the remote file will be replaced when contents are different than the source.\n    - If C(no), the file will only be transferred if the destination does not exist.\n    - Alias C(thirsty) has been deprecated and will be removed in 2.13.\n    type: bool\n    default: yes\n    aliases: [ thirsty ]\n    version_added: \'1.1\'\n  mode:\n    description:\n    - The permissions of the destination file or directory.\n    - For those used to C(/usr/bin/chmod) remember that modes are actually octal numbers.\n      You must either add a leading zero so that Ansible\'s YAML parser knows it is an octal number\n      (like C(0644) or C(01777)) or quote it (like C(\'644\') or C(\'1777\')) so Ansible receives a string\n      and can do its own conversion from string into number. Giving Ansible a number without following\n      one of these rules will end up with a decimal number which will have unexpected results.\n    - As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\n    - As of Ansible 2.3, the mode may also be the special string C(preserve).\n    - C(preserve) means that the file will be given the same permissions as the source file.\n    - When doing a recursive copy, see also C(directory_mode).\n    - If C(mode) is not specified and the destination file B(does not) exist, the default C(umask) on the system will be used\n      when setting the mode for the newly created file.\n    - If C(mode) is not specified and the destination file B(does) exist, the mode of the existing file will be used.\n    - Specifying C(mode) is the best way to ensure files are created with the correct permissions.\n      See CVE-2020-1736 for further details.\n  directory_mode:\n    description:\n    - When doing a recursive copy set the mode for the directories.\n    - If this is not set we will use the system defaults.\n    - The mode is only set on directories which are newly created, and will not affect those that already existed.\n    type: raw\n    version_added: \'1.5\'\n  remote_src:\n    description:\n    - Influence whether C(src) needs to be transferred or already is present remotely.\n    - If C(no), it will search for C(src) on the controller node.\n    - If C(yes) it will search for C(src) on the managed (remote) node.\n    - C(remote_src) supports recursive copying as of version 2.8.\n    - C(remote_src) only works with C(mode=preserve) as of version 2.6.\n    - Autodecryption of files does not work when C(remote_src=yes).\n    type: bool\n    default: no\n    version_added: \'2.0\'\n  follow:\n    description:\n    - This flag indicates that filesystem links in the destination, if they exist, should be followed.\n    type: bool\n    default: no\n    version_added: \'1.8\'\n  local_follow:\n    description:\n    - This flag indicates that filesystem links in the source tree, if they exist, should be followed.\n    type: bool\n    default: yes\n    version_added: \'2.4\'\n  checksum:\n    description:\n    - SHA1 checksum of the file being transferred.\n    - Used to validate that the copy of the file was successful.\n    - If this is not provided, ansible will use the local calculated checksum of the src file.\n    type: str\n    version_added: \'2.5\'\nextends_documentation_fragment:\n    - decrypt\n    - files\n    - validate\n    - action_common_attributes\n    - action_common_attributes.files\n    - action_common_attributes.flow\nnotes:\n    - The M(ansible.builtin.copy) module recursively copy facility does not scale to lots (>hundreds) of files.\nseealso:\n    - module: ansible.builtin.assemble\n    - module: ansible.builtin.fetch\n    - module: ansible.builtin.file\n    - module: ansible.builtin.template\n    - module: ansible.posix.synchronize\n    - module: ansible.windows.win_copy\nauthor:\n    - Ansible Core Team\n    - Michael DeHaan\nattributes:\n  action:\n    support: full\n  async:\n    support: none\n  bypass_host_loop:\n    support: none\n  check_mode:\n    support: full\n  diff_mode:\n    support: full\n  platform:\n    platforms: posix\n  safe_file_operations:\n      support: full\n  vault:\n    support: full\n    version_added: \'2.2\'\n'
    str_1 = ''
    str_2 = 'V:;\tPYYHk6LgjaT/~XZ'
    test_failure_0 = module_0.TestFailure(str_1)
    dict_0 = {str_1: str_1, str_0: str_2, str_2: str_1}
    test_suite_0 = module_0.TestSuite(str_0, str_0, str_0, dict_0)
    list_0 = [test_suite_0]
    test_suites_0 = module_0.TestSuites(list_0)
    str_3 = test_suites_0.to_pretty_xml()
    var_0 = test_suites_0.__repr__()
    int_0 = 3968
    test_case_0 = module_0.TestCase(str_0, int_0, str_0)
    test_error_0 = module_0.TestError(str_3)
    var_1 = test_suites_0.__eq__(test_error_0)

def test_case_6():
    str_0 = 'gu*Rv* \\\\Sj`ikhyAa'
    int_0 = 43
    str_1 = '0`J}W\x0bSDs32Jg3h0G'
    test_case_0 = module_0.TestCase(str_0, int_0, str_1)
    element_0 = test_case_0.get_xml_element()
    str_2 = 'fji?Zmc'
    str_3 = 'IY\x0by/&=U9(u,tt(*8N'
    test_error_0 = module_0.TestError(str_2, str_2, str_3)
    var_0 = test_error_0.__repr__()

def test_case_7():
    str_0 = 'Test'
    test_error_0 = module_0.TestError(str_0)
    element_0 = test_error_0.get_xml_element()

def test_case_8():
    str_0 = 'teO}ust_'
    var_0 = None
    str_1 = 'TeTAstCHcuotor'
    str_2 = '65534'
    int_0 = 468
    test_failure_0 = module_0.TestFailure(str_2, str_0, str_2)
    list_0 = [test_failure_0]
    bool_0 = False
    str_3 = None
    test_case_0 = module_0.TestCase(str_1, int_0, list_0, str_3, bool_0)
    dict_0 = test_case_0.get_attributes()
    str_4 = 'test_suite_calculator'
    test_case_1 = [test_case_0]
    test_suite_0 = module_0.TestSuite(str_4, var_0, var_0, var_0, var_0, var_0, test_case_1, var_0, var_0)
    element_0 = test_suite_0.get_xml_element()