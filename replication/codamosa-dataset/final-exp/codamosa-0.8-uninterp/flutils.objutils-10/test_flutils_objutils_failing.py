# Automatically generated by Pynguin.
import flutils.objutils as module_0

def test_case_0():
    try:
        bool_0 = True
        str_0 = '__doc__'
        str_1 = '`i'
        list_0 = [str_1, str_0]
        bool_1 = module_0.has_any_attrs(bool_0)
        bool_2 = module_0.has_any_callables(str_1, *list_0)
    except BaseException:
        pass

def test_case_1():
    try:
        bool_0 = True
        bool_1 = False
        dict_0 = {}
        bool_2 = module_0.has_any_attrs(dict_0)
        str_0 = '__doc__'
        list_0 = [str_0, str_0]
        bool_3 = module_0.has_callables(bool_1, *list_0)
        str_1 = "&Wp'RinH"
        str_2 = ' Return code: '
        list_1 = [str_1, str_2]
        bool_4 = module_0.has_any_attrs(bool_0)
        bool_5 = module_0.has_any_callables(str_1, *list_1)
        bool_6 = module_0.has_attrs(dict_0, *list_1)
        bool_7 = module_0.has_callables(list_1)
    except BaseException:
        pass

def test_case_2():
    try:
        float_0 = 3725.4
        bool_0 = module_0.has_attrs(float_0)
        bool_1 = module_0.is_subclass_of_any(bool_0)
        str_0 = 'yo3y EL'
        str_1 = 'count'
        list_0 = [str_1, str_1, str_1, str_1]
        bool_2 = module_0.has_any_callables(str_0, *list_0)
        str_2 = '4{T'
        str_3 = 'Bm!\x0cH+6F-#F:h '
        list_1 = [str_0, str_2, str_2, str_3]
        bool_3 = module_0.has_attrs(float_0, *list_1)
        bool_4 = module_0.is_subclass_of_any(float_0)
        bool_5 = module_0.has_attrs(bool_4)
        bool_6 = module_0.has_callables(float_0)
        bytes_0 = b"\xc3'(\x9f\xe1\xb7\x84\x99\x8f"
        bool_7 = module_0.has_callables(bool_4)
        bool_8 = module_0.is_list_like(bool_0)
        bool_9 = module_0.has_any_callables(bytes_0)
        bool_10 = module_0.has_callables(list_1, *list_0)
        list_2 = [str_3, str_0]
        bool_11 = module_0.is_subclass_of_any(bool_2, *list_2)
    except BaseException:
        pass

def test_case_3():
    try:
        bool_0 = True
        list_0 = [bool_0, bool_0]
        bool_1 = module_0.is_subclass_of_any(list_0)
        dict_0 = {}
        bool_2 = module_0.is_list_like(dict_0)
        bool_3 = module_0.has_any_attrs(dict_0)
        bool_4 = module_0.has_any_callables(bool_3)
        str_0 = '__doc__'
        list_1 = [str_0]
        bool_5 = module_0.has_callables(bool_2, *list_1)
        str_1 = 'Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            """This is the mymodule docstring."""\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            """This is the mymodule docstring."""\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                \'mymodule.mysubmoduleone\',\n                \'mymodule.mysubmoduletwo,two\',\n                \'mymodule.mysubmodulethree:afunction\',\n                \'mymodule.mysubmodulethree:anotherfunction,anotherfuc\'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get(\'mymodule.mysubmodulethree\')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    '
        list_2 = [str_1, str_0]
        bool_6 = module_0.has_any_attrs(bool_1)
        bool_7 = module_0.has_any_callables(bool_2, *list_1)
        bool_8 = module_0.has_any_callables(str_1, *list_2)
    except BaseException:
        pass