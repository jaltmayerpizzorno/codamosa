# Automatically generated by Pynguin.
import tornado.httpclient as module_0
import builtins as module_1
import tornado.httputil as module_2
import ssl as module_3

def test_case_0():
    try:
        str_0 = 'htp://www.gGogle.com/'
        h_t_t_p_client_0 = module_0.HTTPClient()
        h_t_t_p_response_0 = h_t_t_p_client_0.fetch(str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        h_t_t_p_client_0 = module_0.HTTPClient()
        async_h_t_t_p_client_0 = module_0.AsyncHTTPClient()
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = 'hp.//wwwgGogl\x0c.com/'
        h_t_t_p_client_0 = module_0.HTTPClient()
        str_1 = '__main__'
        dict_0 = {str_0: str_0, str_0: str_1}
        bool_0 = True
        optional_0 = None
        dict_1 = {}
        h_t_t_p_request_0 = module_0.HTTPRequest(str_0, str_0, str_0, dict_0, str_1, bool_0, str_1, optional_0, str_1, bool_0, str_1, bool_0, dict_1)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = 'http://wwwgoogle.com/'
        h_t_t_p_client_0 = module_0.HTTPClient()
        h_t_t_p_response_0 = h_t_t_p_client_0.fetch(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        module_0.main()
    except BaseException:
        pass

def test_case_5():
    try:
        module_0.main()
    except BaseException:
        pass

def test_case_6():
    try:
        bool_0 = True
        h_t_t_p_client_0 = module_0.HTTPClient(bool_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = 'N\x0cFlUS\\tGQ:CtPW'
        str_1 = 'A non-blocking, single-threaded HTTP server.\n\n    A server is defined by a subclass of `.HTTPServerConnectionDelegate`,\n    or, for backwards compatibility, a callback that takes an\n    `.HTTPServerRequest` as an argument. The delegate is usually a\n    `tornado.web.Application`.\n\n    `HTTPServer` supports keep-alive connections by default\n    (automatically for HTTP/1.1, or for HTTP/1.0 when the client\n    requests ``Connection: keep-alive``).\n\n    If ``xheaders`` is ``True``, we support the\n    ``X-Real-Ip``/``X-Forwarded-For`` and\n    ``X-Scheme``/``X-Forwarded-Proto`` headers, which override the\n    remote IP and URI scheme/protocol for all requests.  These headers\n    are useful when running Tornado behind a reverse proxy or load\n    balancer.  The ``protocol`` argument can also be set to ``https``\n    if Tornado is run behind an SSL-decoding proxy that does not set one of\n    the supported ``xheaders``.\n\n    By default, when parsing the ``X-Forwarded-For`` header, Tornado will\n    select the last (i.e., the closest) address on the list of hosts as the\n    remote host IP address.  To select the next server in the chain, a list of\n    trusted downstream hosts may be passed as the ``trusted_downstream``\n    argument.  These hosts will be skipped when parsing the ``X-Forwarded-For``\n    header.\n\n    To make this server serve SSL traffic, send the ``ssl_options`` keyword\n    argument with an `ssl.SSLContext` object. For compatibility with older\n    versions of Python ``ssl_options`` may also be a dictionary of keyword\n    arguments for the `ssl.wrap_socket` method.::\n\n       ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n       ssl_ctx.load_cert_chain(os.path.join(data_dir, "mydomain.crt"),\n                               os.path.join(data_dir, "mydomain.key"))\n       HTTPServer(application, ssl_options=ssl_ctx)\n\n    `HTTPServer` initialization follows one of three patterns (the\n    initialization methods are defined on `tornado.tcpserver.TCPServer`):\n\n    1. `~tornado.tcpserver.TCPServer.listen`: simple single-process::\n\n            server = HTTPServer(app)\n            server.listen(8888)\n            IOLoop.current().start()\n\n       In many cases, `tornado.web.Application.listen` can be used to avoid\n       the need to explicitly create the `HTTPServer`.\n\n    2. `~tornado.tcpserver.TCPServer.bind`/`~tornado.tcpserver.TCPServer.start`:\n       simple multi-process::\n\n            server = HTTPServer(app)\n            server.bind(8888)\n            server.start(0)  # Forks multiple sub-processes\n            IOLoop.current().start()\n\n       When using this interface, an `.IOLoop` must *not* be passed\n       to the `HTTPServer` constructor.  `~.TCPServer.start` will always start\n       the server on the default singleton `.IOLoop`.\n\n    3. `~tornado.tcpserver.TCPServer.add_sockets`: advanced multi-process::\n\n            sockets = tornado.netutil.bind_sockets(8888)\n            tornado.process.fork_processes(0)\n            server = HTTPServer(app)\n            server.add_sockets(sockets)\n            IOLoop.current().start()\n\n       The `~.TCPServer.add_sockets` interface is more complicated,\n       but it can be used with `tornado.process.fork_processes` to\n       give you more flexibility in when the fork happens.\n       `~.TCPServer.add_sockets` can also be used in single-process\n       servers if you want to create your listening sockets in some\n       way other than `tornado.netutil.bind_sockets`.\n\n    .. versionchanged:: 4.0\n       Added ``decompress_request``, ``chunk_size``, ``max_header_size``,\n       ``idle_connection_timeout``, ``body_timeout``, ``max_body_size``\n       arguments.  Added support for `.HTTPServerConnectionDelegate`\n       instances as ``request_callback``.\n\n    .. versionchanged:: 4.1\n       `.HTTPServerConnectionDelegate.start_request` is now called with\n       two arguments ``(server_conn, request_conn)`` (in accordance with the\n       documentation) instead of one ``(request_conn)``.\n\n    .. versionchanged:: 4.2\n       `HTTPServer` is now a subclass of `tornado.util.Configurable`.\n\n    .. versionchanged:: 4.5\n       Added the ``trusted_downstream`` argument.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument has been removed.\n    '
        bool_0 = False
        h_t_t_p_request_0 = module_0.HTTPRequest(str_0, str_1, str_1, str_0, str_0, str_1, str_1, bool_0, bool_0)
        int_0 = -1870
        h_t_t_p_response_0 = module_0.HTTPResponse(h_t_t_p_request_0, int_0)
        h_t_t_p_response_0.rethrow()
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = 'htp://Zww.gGoglk.cm/'
        h_t_t_p_client_0 = module_0.HTTPClient()
        bool_0 = True
        base_exception_0 = module_1.BaseException()
        h_t_t_p_request_0 = module_0.HTTPRequest(str_0, bool_0, str_0, str_0, bool_0, base_exception_0, bool_0)
        int_0 = 1570
        h_t_t_p_headers_0 = module_2.HTTPHeaders()
        h_t_t_p_headers_1 = h_t_t_p_headers_0.copy()
        h_t_t_p_response_0 = module_0.HTTPResponse(h_t_t_p_request_0, int_0, h_t_t_p_headers_1)
        str_1 = h_t_t_p_response_0.__repr__()
        h_t_t_p_client_0.close()
        h_t_t_p_response_1 = h_t_t_p_client_0.fetch(str_0)
    except BaseException:
        pass

def test_case_9():
    try:
        h_t_t_p_client_0 = module_0.HTTPClient()
        str_0 = 'tornado.httpclient'
        float_0 = -3553.9
        bool_0 = True
        bool_1 = False
        h_t_t_p_request_0 = module_0.HTTPRequest(str_0, str_0, float_0, str_0, str_0, str_0, str_0, bool_0, str_0, bool_1, bool_0)
        dict_0 = {str_0: bool_0, str_0: float_0}
        h_t_t_p_response_0 = h_t_t_p_client_0.fetch(h_t_t_p_request_0, **dict_0)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = '}!fQ!Y}#Ca`,'
        str_1 = "t'$1~>r*8N9H'&"
        float_0 = -2327.23717
        optional_0 = None
        bytes_0 = b''
        future_0 = None
        base_exception_0 = module_1.BaseException()
        h_t_t_p_request_0 = module_0.HTTPRequest(str_1, str_1, float_0, optional_0, bytes_0, str_0, future_0, base_exception_0, str_0)
        int_0 = 941
        dict_0 = {}
        none_type_0 = None
        h_t_t_p_response_0 = module_0.HTTPResponse(h_t_t_p_request_0, int_0, dict_0, int_0, base_exception_0, float_0, none_type_0, str_1)
        h_t_t_p_client_0 = module_0.HTTPClient()
        s_s_l_context_0 = module_3.SSLContext()
        str_2 = '1P;'
        dict_1 = {str_0: s_s_l_context_0, str_2: str_0, str_0: str_0}
        h_t_t_p_response_1 = h_t_t_p_client_0.fetch(str_0, **dict_1)
    except BaseException:
        pass