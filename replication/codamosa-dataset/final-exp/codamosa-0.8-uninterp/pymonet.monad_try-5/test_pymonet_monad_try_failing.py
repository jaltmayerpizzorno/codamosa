# Automatically generated by Pynguin.
import pymonet.monad_try as module_0

def test_case_0():
    try:
        float_0 = -594.576
        list_0 = [float_0, float_0, float_0]
        bool_0 = False
        try_0 = module_0.Try(float_0, bool_0)
        var_0 = try_0.get()
        bool_1 = True
        try_1 = module_0.Try(list_0, bool_1)
        try_2 = module_0.Try(bool_0, bool_1)
        bool_2 = try_0.__eq__(try_2)
        bool_3 = True
        bool_4 = False
        try_3 = module_0.Try(bool_3, bool_4)
        var_1 = try_3.get()
    except BaseException:
        pass

def test_case_1():
    try:
        bytes_0 = b'\x15\xd2\x94s\x17('
        str_0 = '\x0cm!'
        dict_0 = {str_0: str_0, str_0: str_0}
        bool_0 = True
        try_0 = module_0.Try(dict_0, bool_0)
        var_0 = try_0.map(bytes_0)
    except BaseException:
        pass

def test_case_2():
    try:
        bool_0 = False
        bytes_0 = b'+\x82\x81'
        bool_1 = False
        try_0 = module_0.Try(bytes_0, bool_1)
        bool_2 = True
        try_1 = module_0.Try(try_0, bool_2)
        bytes_1 = b'\xc4l\xd3'
        tuple_0 = (bool_0, try_1, bytes_1)
        var_0 = try_0.get_or_else(try_1)
        bytes_2 = b'P\xb2?\xbd\xd8\xc0\x9a\x99\xa4'
        bool_3 = True
        try_2 = module_0.Try(bytes_2, bool_3)
        var_1 = try_2.bind(tuple_0)
    except BaseException:
        pass

def test_case_3():
    try:
        int_0 = 264
        str_0 = '9?{h G#'
        tuple_0 = (int_0, str_0)
        bool_0 = True
        bool_1 = False
        try_0 = module_0.Try(bool_0, bool_1)
        list_0 = [bool_0, int_0, int_0, int_0]
        try_1 = module_0.Try(list_0, bool_0)
        var_0 = try_1.on_fail(try_0)
        try_2 = module_0.Try(tuple_0, bool_0)
        var_1 = try_2.on_success(try_2)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = '\n        :param semigroup: other semigroup to concat\n        :type semigroup: First[B]\n        :returns: new First with first value\n        :rtype: First[A]\n        '
        bool_0 = True
        try_0 = module_0.Try(str_0, bool_0)
        str_1 = '9 k n*>IHlt&Y"'
        bool_1 = try_0.__eq__(str_1)
        var_0 = try_0.get()
        float_0 = 1267.91
        bool_2 = False
        bool_3 = True
        try_1 = module_0.Try(bool_2, bool_3)
        var_1 = try_1.on_fail(float_0)
        bytes_0 = None
        var_2 = try_1.get_or_else(bytes_0)
        bool_4 = False
        bool_5 = False
        try_2 = module_0.Try(bool_4, bool_5)
        str_2 = try_1.__str__()
        bytes_1 = b'|\x92\xd7n'
        var_3 = try_2.on_fail(bytes_1)
    except BaseException:
        pass

def test_case_5():
    try:
        float_0 = 374.81
        bool_0 = True
        try_0 = module_0.Try(bool_0, bool_0)
        bool_1 = True
        try_1 = module_0.Try(try_0, bool_1)
        var_0 = try_1.filter(float_0)
    except BaseException:
        pass

def test_case_6():
    try:
        bool_0 = True
        str_0 = '\n        If Maybe is empty or filterer returns False return default_value, in other case\n        return new instance of Maybe with the same value.\n\n        :param filterer:\n        :type filterer: Function(A) -> Boolean\n        :returns: copy of self when filterer returns True, in other case empty Maybe\n        :rtype: Maybe[A] | Maybe[None]\n        '
        try_0 = module_0.Try(str_0, bool_0)
        bool_1 = try_0.__eq__(try_0)
        bool_2 = False
        set_0 = set()
        try_1 = module_0.Try(set_0, bool_2)
        try_2 = module_0.Try(try_0, bool_2)
        bytes_0 = b':*\xe2\xb6\xf7R\x16'
        bool_3 = True
        int_0 = True
        try_3 = module_0.Try(int_0, bool_2)
        var_0 = try_3.filter(bool_3)
        bool_4 = try_2.__eq__(bytes_0)
        dict_0 = None
        var_1 = try_2.on_success(dict_0)
        var_2 = try_0.filter(try_0)
    except BaseException:
        pass