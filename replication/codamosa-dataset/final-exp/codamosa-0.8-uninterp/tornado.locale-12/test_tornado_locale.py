# Automatically generated by Pynguin.
import tornado.locale as module_0
import gettext as module_1

def test_case_0():
    pass

def test_case_1():
    str_0 = None
    module_0.load_translations(str_0)

def test_case_2():
    int_0 = -2017
    bool_0 = False
    locale_0 = module_0.get()
    str_0 = locale_0.format_date(int_0, bool_0)
    iterable_0 = module_0.get_supported_locales()

def test_case_3():
    int_0 = 4239
    str_0 = '7AA)&.'
    list_0 = [str_0, str_0, str_0]
    locale_0 = module_0.get(*list_0)
    str_1 = locale_0.format_date(int_0)

def test_case_4():
    locale_0 = module_0.get()

def test_case_5():
    locale_0 = module_0.get()

def test_case_6():
    int_0 = 25
    locale_0 = module_0.get()
    str_0 = locale_0.format_date(int_0)

def test_case_7():
    int_0 = 4239
    str_0 = 'q;q3'
    str_1 = '7AA)&.'
    list_0 = [str_0, str_1, str_1]
    locale_0 = module_0.get(*list_0)
    str_2 = locale_0.format_date(int_0)

def test_case_8():
    int_0 = 25
    locale_0 = module_0.get()
    str_0 = locale_0.format_date(int_0)
    str_1 = locale_0.list(str_0)

def test_case_9():
    str_0 = '9Q'
    int_0 = 1514
    str_1 = '4o&$'
    str_2 = 'A condition allows one or more coroutines to wait until notified.\n\n    Like a standard `threading.Condition`, but does not need an underlying lock\n    that is acquired and released.\n\n    With a `Condition`, coroutines can wait to be notified by other coroutines:\n\n    .. testcode::\n\n        from tornado import gen\n        from tornado.ioloop import IOLoop\n        from tornado.locks import Condition\n\n        condition = Condition()\n\n        async def waiter():\n            print("I\'ll wait right here")\n            await condition.wait()\n            print("I\'m done waiting")\n\n        async def notifier():\n            print("About to notify")\n            condition.notify()\n            print("Done notifying")\n\n        async def runner():\n            # Wait for waiter() and notifier() in parallel\n            await gen.multi([waiter(), notifier()])\n\n        IOLoop.current().run_sync(runner)\n\n    .. testoutput::\n\n        I\'ll wait right here\n        About to notify\n        Done notifying\n        I\'m done waiting\n\n    `wait` takes an optional ``timeout`` argument, which is either an absolute\n    timestamp::\n\n        io_loop = IOLoop.current()\n\n        # Wait up to 1 second for a notification.\n        await condition.wait(timeout=io_loop.time() + 1)\n\n    ...or a `datetime.timedelta` for a timeout relative to the current time::\n\n        # Wait up to 1 second.\n        await condition.wait(timeout=datetime.timedelta(seconds=1))\n\n    The method returns False if there\'s no notification before the deadline.\n\n    .. versionchanged:: 5.0\n       Previously, waiters could be notified synchronously from within\n       `notify`. Now, the notification will always be received on the\n       next iteration of the `.IOLoop`.\n    '
    str_3 = 'ml\x0bq1aOup$i'
    dict_0 = {str_1: str_1, str_1: str_1, str_2: str_2, str_1: str_3}
    dict_1 = {str_1: dict_0, str_2: dict_0}
    c_s_v_locale_0 = module_0.CSVLocale(str_1, dict_1)
    str_4 = c_s_v_locale_0.translate(str_0, str_0, int_0)

def test_case_10():
    str_0 = 'er 56'
    list_0 = []
    locale_0 = module_0.get(*list_0)
    str_1 = locale_0.pgettext(str_0, str_0)
    str_2 = './'
    str_3 = 'messages'
    module_0.load_gettext_translations(str_2, str_3)

def test_case_11():
    str_0 = 'z >K)'
    null_translations_0 = module_1.NullTranslations()
    gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
    str_1 = gettext_locale_0.translate(str_0)

def test_case_12():
    str_0 = 'en_US'
    str_1 = 'gPB\rn YX\\hp~'
    null_translations_0 = module_1.NullTranslations()
    gettext_locale_0 = module_0.GettextLocale(str_1, null_translations_0)
    str_2 = gettext_locale_0.pgettext(str_0, str_0)

def test_case_13():
    str_0 = '#I Xw_m'
    int_0 = -1040
    str_1 = 'bg_BG'
    str_2 = 'A condition allows one or more coroutines to wait until notified.\n\n    Like a standard `threading.Condition`, but does not need an underlying lock\n    that is acquired and released.\n\n    With a `Condition`, coroutines can wait to be notified by other coroutines:\n\n    .. testcode::\n\n        from tornado import gen\n        from tornado.ioloop import IOLoop\n        from tornado.locks import Condition\n\n        condition = Condition()\n\n        async def waiter():\n            print("I\'ll wait right here")\n            await condition.wait()\n            print("I\'m done waiting")\n\n        async def notifier():\n            print("About to notify")\n            condition.notify()\n            print("Done notifying")\n\n        async def runner():\n            # Wait for waiter() and notifier() in parallel\n            await gen.multi([waiter(), notifier()])\n\n        IOLoop.current().run_sync(runner)\n\n    .. testoutput::\n\n        I\'ll wait right here\n        About to notify\n        Done notifying\n        I\'m done waiting\n\n    `wait` takes an optional ``timeout`` argument, which is either an absolute\n    timestamp::\n\n        io_loop = IOLoop.current()\n\n        # Wait up to 1 second for a notification.\n        await condition.wait(timeout=io_loop.time() + 1)\n\n    ...or a `datetime.timedelta` for a timeout relative to the current time::\n\n        # Wait up to 1 second.\n        await condition.wait(timeout=datetime.timedelta(seconds=1))\n\n    The method returns False if there\'s no notification before the deadline.\n\n    .. versionchanged:: 5.0\n       Previously, waiters could be notified synchronously from within\n       `notify`. Now, the notification will always be received on the\n       next iteration of the `.IOLoop`.\n    '
    str_3 = 'Pn{B>JVA>'
    list_0 = [str_1, str_0, str_2, str_3]
    locale_0 = module_0.get(*list_0)
    str_4 = locale_0.format_date(int_0)

def test_case_14():
    int_0 = -2017
    locale_0 = module_0.get()
    locale_1 = module_0.get()
    str_0 = 'en_US'
    list_0 = [str_0]
    locale_2 = module_0.get(*list_0)
    int_1 = 1547
    str_1 = locale_0.format_date(int_0, int_1)

def test_case_15():
    bool_0 = True
    locale_0 = module_0.get()
    int_0 = -2462
    str_0 = '\x0bQ7wr`Ke*\\gg:=X~Ke'
    bool_1 = False
    str_1 = locale_0.format_date(int_0, bool_0, bool_1)
    locale_1 = module_0.get()
    str_2 = locale_1.list(str_0)

def test_case_16():
    str_0 = ' (via %s)'
    bytes_0 = b'\x07\xe9\xe8\xab\xb4>j.\x02\xc53\xb3\x890\x9c'
    str_1 = '\x0bk%\x0b*dq`K2/T6=g!CDB('
    dict_0 = {}
    dict_1 = {str_1: dict_0, str_0: dict_0, str_0: dict_0}
    c_s_v_locale_0 = module_0.CSVLocale(str_1, dict_1)
    null_translations_0 = module_1.NullTranslations()
    gettext_locale_0 = module_0.GettextLocale(str_1, null_translations_0)
    str_2 = gettext_locale_0.pgettext(str_0, str_0, str_0, bytes_0)

def test_case_17():
    str_0 = 'Q7ky$YVy`'
    dict_0 = {}
    str_1 = 'C,~/&5b'
    int_0 = -988
    bytes_0 = b'\x95\x11\xddV+>:\xf7}\xd8\\\xf6\xf2\x9c\xe8_[X\xe1'
    null_translations_0 = module_1.NullTranslations(bytes_0)
    gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
    str_2 = gettext_locale_0.pgettext(str_0, str_0)
    str_3 = '\x0b4?"LQ'
    str_4 = 'A condition allows one or more coroutines to wait until notified.\n\n    Like a standard `threading.Condition`, but does not need an underlying lock\n    that is acquired and released.\n\n    With a `Condition`, coroutines can wait to be notified by other coroutines:\n\n    .. testcode::\n\n        from tornado import gen\n        from tornado.ioloop import IOLoop\n        from tornado.locks import Condition\n\n        condition = Condition()\n\n        async def waiter():\n            print("I\'ll wait right here")\n            await condition.wait()\n            print("I\'m done waiting")\n\n        async def notifier():\n            print("About to notify")\n            condition.notify()\n            print("Done notifying")\n\n        async def runner():\n            # Wait for waiter() and notifier() in parallel\n            await gen.multi([waiter(), notifier()])\n\n        IOLoop.current().run_sync(runner)\n\n    .. testoutput::\n\n        I\'ll wait right here\n        About to notify\n        Done notifying\n        I\'m done waiting\n\n    `wait` takes an optional ``timeout`` argument, which is either an absolute\n    timestamp::\n\n        io_loop = IOLoop.current()\n\n        # Wait up to 1 second for a notification.\n        await condition.wait(timeout=io_loop.time() + 1)\n\n    ...or a `datetime.timedelta` for a timeout relative to the current time::\n\n        # Wait up to 1 second.\n        await condition.wait(timeout=datetime.timedelta(seconds=1))\n\n    The method returns False if there\'s no notification before the deadline.\n\n    .. versionchanged:: 5.0\n       Previously, waiters could be notified synchronously from within\n       `notify`. Now, the notification will always be received on the\n       next iteration of the `.IOLoop`.\n    '
    str_5 = 'OU?H`KT] fB=N15.=-'
    list_0 = [str_3, str_5, str_4, str_5]
    locale_0 = module_0.get(*list_0)
    str_6 = '+?#'
    module_0.set_default_locale(str_6)
    str_7 = 'F#_7Y4\x0b&ejT}sQ3hQy'
    dict_1 = {str_7: dict_0, str_4: dict_0}
    c_s_v_locale_0 = module_0.CSVLocale(str_7, dict_1)
    str_8 = locale_0.format_date(int_0)
    dict_2 = {str_0: dict_0, str_1: dict_0, str_1: dict_0}
    c_s_v_locale_1 = module_0.CSVLocale(str_0, dict_2)
    str_9 = c_s_v_locale_1.pgettext(str_0, str_0)
    str_10 = None
    c_s_v_locale_2 = module_0.CSVLocale(str_1, dict_2)
    module_0.load_translations(str_10, str_3)
    str_11 = c_s_v_locale_0.translate(str_7, str_5, int_0)
    str_12 = locale_0.list(dict_0)

def test_case_18():
    str_0 = 'Q7ky$YVy`'
    iterable_0 = module_0.get_supported_locales()
    int_0 = -1043
    str_1 = 'zh_CN'
    bytes_0 = b'\x95\x11\xddV+>:\xf7}\xbf\xd8\\\xf6\xf2\x9c\xe8_[\xe2\xe1'
    null_translations_0 = module_1.NullTranslations(bytes_0)
    gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
    str_2 = gettext_locale_0.pgettext(str_0, str_1)
    str_3 = '\x0b4?"LQ'
    str_4 = 'Returns url string for a given route name and arguments\n        or ``None`` if no match is found.\n\n        :arg str name: route name.\n        :arg argsn url parameters.\n       :returns: parametrized url stringfor a given route name (or ``None``).\n        '
    str_5 = gettext_locale_0.pgettext(str_3, str_4, str_4, int_0)
    str_6 = 'Pn{B>JVA>'
    list_0 = [str_3, str_6, str_6, str_3, str_6, str_2]
    locale_0 = module_0.get(*list_0)
    str_7 = locale_0.format_date(int_0)
    str_8 = locale_0.friendly_number(int_0)
    str_9 = None
    module_0.load_translations(str_9)
    str_10 = locale_0.friendly_number(int_0)
    str_11 = locale_0.list(str_5)

def test_case_19():
    str_0 = './'
    str_1 = 'messages'
    module_0.load_gettext_translations(str_0, str_1)

def test_case_20():
    str_0 = '/usr/share/locale'
    str_1 = 'test-test'
    module_0.load_gettext_translations(str_0, str_1)

def test_case_21():
    str_0 = 'Q7ky$YVy`'
    dict_0 = {}
    iterable_0 = module_0.get_supported_locales()
    int_0 = 7
    str_1 = 'zh_CN'
    bytes_0 = b'\x95\x11\xddV+>:\xf7}\xbf\xd8\\\xf6\xf2\x9c\xe8_[\xe2\xe1'
    null_translations_0 = module_1.NullTranslations(bytes_0)
    gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
    str_2 = gettext_locale_0.pgettext(str_0, str_1)
    str_3 = 'zh_CN'
    str_4 = 'A condition allows one or more coroutines to wait until notified.\n\n    Like a standard `threading.Condition`, but does not need an underlying lock\n    that is acquired and released.\n\n    With a `Condition`, coroutines can wait to be notified by other coroutines:\n\n    .. testcode::\n\n        from tornado import gen\n        from tornado.ioloop import IOLoop\n        from tornado.locks import Condition\n\n        condition = Condition()\n\n        async def waiter():\n            print("I\'ll wait right here")\n            await condition.wait()\n            print("I\'m done waiting")\n\n        async def notifier():\n            print("About to notify")\n            condition.notify()\n            print("Done notifying")\n\n        async def runner():\n            # Wait for waiter() and notifier() in parallel\n            await gen.multi([waiter(), notifier()])\n\n        IOLoop.current().run_sync(runner)\n\n    .. testoutput::\n\n        I\'ll wait right here\n        About to notify\n        Done notifying\n        I\'m done waiting\n\n    `wait` takes an optional ``timeout`` argument, which is either an absolute\n    timestamp::\n\n        io_loop = IOLoop.current()\n\n        # Wait up to 1 second for a notification.\n        await condition.wait(timeout=io_loop.time() + 1)\n\n    ...or a `datetime.timedelta` for a timeout relative to the current time::\n\n        # Wait up to 1 second.\n        await condition.wait(timeout=datetime.timedelta(seconds=1))\n\n    The method returns False if there\'s no notification before the deadline.\n\n    .. versionchanged:: 5.0\n       Previously, waiters could be notified synchronously from within\n       `notify`. Now, the notification will always be received on the\n       next iteration of the `.IOLoop`.\n    '
    str_5 = 'Y^M(z*E9X#'
    str_6 = 'zh_CN'
    str_7 = 'p'
    dict_1 = {str_7: dict_0}
    c_s_v_locale_0 = module_0.CSVLocale(str_2, dict_1)
    str_8 = c_s_v_locale_0.translate(str_4, str_0, int_0)
    c_s_v_locale_1 = module_0.CSVLocale(str_6, dict_1)
    str_9 = c_s_v_locale_1.pgettext(str_5, str_2)
    str_10 = 'k_J5'
    str_11 = 'Returns url string for a given route name and arguments\n        or ``None`` if no match is found.\n\n        :arg str name: route name.\n        :arg args: url parameters.\n        :returns: parametrized url string for a given route name (or ``None``).\n        '
    str_12 = gettext_locale_0.pgettext(str_10, str_11, str_11, int_0)
    str_13 = 'Pn{B>JVA>'
    list_0 = [str_3, str_13, str_13, str_4, str_13, str_2]
    locale_0 = module_0.get(*list_0)
    str_14 = 'F#_7Y4\x0b&ejT}sQ3hQy'
    dict_2 = {str_14: dict_0, str_4: dict_0}
    c_s_v_locale_2 = module_0.CSVLocale(str_14, dict_2)
    str_15 = locale_0.format_date(int_0)
    dict_3 = {str_0: dict_0, str_8: dict_0, str_0: dict_0, str_8: dict_0}
    c_s_v_locale_3 = module_0.CSVLocale(str_0, dict_3)
    str_16 = locale_0.friendly_number(int_0)
    str_17 = c_s_v_locale_3.pgettext(str_0, str_0)
    str_18 = None
    module_0.load_translations(str_18)
    str_19 = locale_0.list(str_0)