# Automatically generated by Pynguin.
import ansible.utils.unsafe_proxy as module_0
import ansible.utils.native_jinja as module_1

def test_case_0():
    ansible_unsafe_bytes_0 = module_0.AnsibleUnsafeBytes()

def test_case_1():
    int_0 = 286
    list_0 = [int_0, int_0, int_0]
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0)
    var_0 = module_0.wrap_var(int_0)

def test_case_2():
    str_0 = '<kWb)r(tbsNR>/zXfOv'
    int_0 = -2756
    dict_0 = {str_0: int_0}
    var_0 = module_0.wrap_var(dict_0)

def test_case_3():
    str_0 = '<kWb)r(tbsNR>/zXfOv'
    dict_0 = None
    var_0 = module_0.wrap_var(dict_0)
    list_0 = [var_0, dict_0, str_0, var_0]
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0)

def test_case_4():
    bytes_0 = b'>/\x1f8\x87<\xc4=L<Z\xfc\x13\xb4\x85'
    var_0 = module_0.wrap_var(bytes_0)

def test_case_5():
    str_0 = '\n---\nmodule: file\nversion_added: historical\nshort_description: Manage files and file properties\nextends_documentation_fragment: [files, action_common_attributes]\ndescription:\n- Set attributes of files, symlinks or directories.\n- Alternatively, remove files, symlinks or directories.\n- Many other modules support the same options as the C(file) module - including M(ansible.builtin.copy),\n  M(ansible.builtin.template), and M(ansible.builtin.assemble).\n- For Windows targets, use the M(ansible.windows.win_file) module instead.\noptions:\n  path:\n    description:\n    - Path to the file being managed.\n    type: path\n    required: yes\n    aliases: [ dest, name ]\n  state:\n    description:\n    - If C(absent), directories will be recursively deleted, and files or symlinks will\n      be unlinked. In the case of a directory, if C(diff) is declared, you will see the files and folders deleted listed\n      under C(path_contents). Note that C(absent) will not cause C(file) to fail if the C(path) does\n      not exist as the state did not change.\n    - If C(directory), all intermediate subdirectories will be created if they\n      do not exist. Since Ansible 1.7 they will be created with the supplied permissions.\n    - If C(file), with no other options, returns the current state of C(path).\n    - If C(file), even with other options (such as C(mode)), the file will be modified if it exists but will NOT be created if it does not exist.\n      Set to C(touch) or use the M(ansible.builtin.copy) or M(ansible.builtin.template) module if you want to create the file if it does not exist.\n    - If C(hard), the hard link will be created or changed.\n    - If C(link), the symbolic link will be created or changed.\n    - If C(touch) (new in 1.4), an empty file will be created if the file does not\n      exist, while an existing file or directory will receive updated file access and\n      modification times (similar to the way C(touch) works from the command line).\n    type: str\n    default: file\n    choices: [ absent, directory, file, hard, link, touch ]\n  src:\n    description:\n    - Path of the file to link to.\n    - This applies only to C(state=link) and C(state=hard).\n    - For C(state=link), this will also accept a non-existing path.\n    - Relative paths are relative to the file being created (C(path)) which is how\n      the Unix command C(ln -s SRC DEST) treats relative paths.\n    type: path\n  recurse:\n    description:\n    - Recursively set the specified file attributes on directory contents.\n    - This applies only when C(state) is set to C(directory).\n    type: bool\n    default: no\n    version_added: \'1.1\'\n  force:\n    description:\n    - >\n      Force the creation of the symlinks in two cases: the source file does\n      not exist (but will appear later); the destination exists and is a file (so, we need to unlink the\n      C(path) file and create symlink to the C(src) file in place of it).\n    type: bool\n    default: no\n  follow:\n    description:\n    - This flag indicates that filesystem links, if they exist, should be followed.\n    - Previous to Ansible 2.5, this was C(no) by default.\n    type: bool\n    default: yes\n    version_added: \'1.8\'\n  modification_time:\n    description:\n    - This parameter indicates the time the file\'s modification time should be set to.\n    - Should be C(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or C(now).\n    - Default is None meaning that C(preserve) is the default for C(state=[file,directory,link,hard]) and C(now) is default for C(state=touch).\n    type: str\n    version_added: "2.7"\n  modification_time_format:\n    description:\n    - When used with C(modification_time), indicates the time format that must be used.\n    - Based on default Python format (see time.strftime doc).\n    type: str\n    default: "%Y%m%d%H%M.%S"\n    version_added: \'2.7\'\n  access_time:\n    description:\n    - This parameter indicates the time the file\'s access time should be set to.\n    - Should be C(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or C(now).\n    - Default is C(None) meaning that C(preserve) is the default for C(state=[file,directory,link,hard]) and C(now) is default for C(state=touch).\n    type: str\n    version_added: \'2.7\'\n  access_time_format:\n    description:\n    - When used with C(access_time), indicates the time format that must be used.\n    - Based on default Python format (see time.strftime doc).\n    type: str\n    default: "%Y%m%d%H%M.%S"\n    version_added: \'2.7\'\nseealso:\n- module: ansible.builtin.assemble\n- module: ansible.builtin.copy\n- module: ansible.builtin.stat\n- module: ansible.builtin.template\n- module: ansible.windows.win_file\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        details: permissions and ownership will be shown but file contents on absent/touch will not.\n        support: partial\n    platform:\n        platforms: posix\nauthor:\n- Ansible Core Team\n- Michael DeHaan\n'
    int_0 = -2756
    dict_0 = {str_0: int_0}
    var_0 = module_0.wrap_var(dict_0)
    list_0 = [dict_0]
    var_1 = module_0.wrap_var(list_0)

def test_case_6():
    int_0 = 263
    list_0 = [int_0, int_0, int_0]
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0)
    ansible_unsafe_bytes_0 = module_0.AnsibleUnsafeBytes()
    var_0 = module_0.wrap_var(int_0)
    ansible_unsafe_text_0 = module_0.AnsibleUnsafeText()
    var_1 = module_0.wrap_var(ansible_unsafe_text_0)
    set_0 = {ansible_unsafe_bytes_0}
    var_2 = module_0.wrap_var(set_0)

def test_case_7():
    int_0 = 263
    list_0 = [int_0, int_0, int_0]
    unsafe_proxy_0 = module_0.UnsafeProxy(*list_0)
    ansible_unsafe_bytes_0 = module_0.AnsibleUnsafeBytes()
    set_0 = None
    str_0 = '\tQKW'
    list_1 = [set_0, ansible_unsafe_bytes_0, unsafe_proxy_0, str_0]
    var_0 = module_0.wrap_var(list_1)
    ansible_unsafe_0 = module_0.AnsibleUnsafe()
    list_2 = [ansible_unsafe_0]
    unsafe_proxy_1 = module_0.UnsafeProxy(*list_2)

def test_case_8():
    var_0 = None
    var_1 = module_0.wrap_var(var_0)
    str_0 = "|]<j84RV\x0b'SS]bT9YBFQ"
    var_2 = module_0.wrap_var(str_0)
    str_1 = 'k'
    str_2 = '_raw'
    str_3 = 'N\x0bF.hH<CAn203 x"Ok'
    dict_0 = {str_0: str_0, str_1: var_2, str_2: str_1, str_3: str_1}
    var_3 = module_0.wrap_var(dict_0)
    bytes_0 = b'\x86\xacn\x1f\x82\xd2\xbe\xfcs\xd7{\x0b'
    var_4 = module_0.wrap_var(bytes_0)
    float_0 = -2938.411
    var_5 = module_0.wrap_var(float_0)
    native_jinja_text_0 = module_1.NativeJinjaText()
    var_6 = module_0.wrap_var(native_jinja_text_0)