# Automatically generated by Pynguin.
import ast as module_0
import apimd.parser as module_1
import builtins as module_2
import collections.abc as module_3

def test_case_0():
    try:
        str_0 = 'FH'
        import_from_0 = module_0.ImportFrom()
        str_1 = 'MIT'
        list_0 = [str_0, str_1, str_0]
        iterable_0 = None
        str_2 = module_1.table(*list_0, items=iterable_0)
    except BaseException:
        pass

def test_case_1():
    try:
        constant_0 = module_0.Constant()
        str_0 = '$jYB^p1HCj\nfKaX9Uu'
        str_1 = '3s\\k#zM"&Bq\tzv'
        str_2 = '\x0b=9@3r]31'
        str_3 = 'q+"?mV'
        str_4 = 'AR'
        str_5 = '<v[n(oTy\\_,BTp<h}S'
        dict_0 = {str_0: str_1, str_2: str_3, str_0: str_4, str_5: str_0}
        resolver_0 = module_1.Resolver(str_0, dict_0)
        a_s_t_0 = resolver_0.visit_Constant(constant_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = 'JY'
        expr_0 = module_0.expr()
        name_0 = module_0.Name()
        str_1 = None
        dict_0 = {str_0: str_0, str_1: str_1, str_1: str_0}
        str_2 = module_1.const_type(expr_0)
        resolver_0 = module_1.Resolver(str_0, dict_0)
        a_s_t_0 = resolver_0.visit_Name(name_0)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = '(E^@:2j3'
        dict_0 = {}
        str_1 = '6~'
        str_2 = 'collections.abc.Awaitable'
        str_3 = '/8]W"*'
        dict_1 = {str_1: str_2, str_3: str_2}
        parser_0 = module_1.Parser(dict_0, dict_1, dict_1)
        parser_0.parse(str_0, str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = "s\n'((?L'VP;,x;qs"
        assign_0 = module_0.Assign()
        int_0 = -856
        str_1 = '#l'
        dict_0 = {str_1: str_1}
        parser_0 = module_1.Parser(int_0, dict_0)
        parser_0.globals(str_0, assign_0)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = 'Zc\\'
        list_0 = [str_0, str_0]
        function_def_0 = module_0.FunctionDef(*list_0)
        str_1 = '\t '
        bool_0 = False
        int_0 = 1496
        str_2 = '\r$7nVYUFSp'
        str_3 = 'Q#[0:xR@)+{{&%'
        dict_0 = {str_2: str_2, str_2: str_3, str_3: str_2}
        parser_0 = module_1.Parser(bool_0, int_0, dict_0, dict_0, dict_0)
        parser_0.api(str_0, function_def_0, prefix=str_1)
    except BaseException:
        pass

def test_case_6():
    try:
        str_0 = 'cLw\rO.\nzw'
        str_1 = '}<o7@e'
        import_0 = module_0.Import()
        str_2 = 'oh'
        dict_0 = {str_1: str_0, str_2: str_1}
        arguments_0 = module_0.arguments(**dict_0)
        list_0 = [arguments_0, str_0]
        assign_0 = module_0.Assign(*list_0, **dict_0)
        list_1 = [str_1, import_0, assign_0, str_0]
        arguments_1 = module_0.arguments(*list_1)
        optional_0 = None
        bool_0 = True
        str_3 = '<{g;\x0c'
        set_0 = set()
        str_4 = '$r.W1\tr'
        dict_1 = {str_3: set_0, str_4: set_0}
        str_5 = 'tW'
        str_6 = 'oZl\rYL\rfO'
        str_7 = 's8'
        str_8 = '8\'\\*%G[d=t"J2'
        dict_2 = {str_5: str_6, str_6: str_3, str_7: str_8}
        parser_0 = module_1.Parser(dict_1, dict_2)
        parser_0.func_api(str_0, str_1, arguments_1, optional_0, has_self=bool_0, cls_method=bool_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = '\rgKc\nX2 N<Fi'
        bool_0 = module_1.is_magic(str_0)
        str_1 = '--toc'
        str_2 = 'r'
        str_3 = module_1.esc_underscore(str_2)
        int_0 = 1
        bool_1 = False
        dict_0 = {str_1: str_1, str_0: str_1, str_0: str_1}
        parser_0 = module_1.Parser(int_0, bool_1, dict_0)
        parser_0.parse(str_0, str_1)
        str_4 = module_1.code(str_1)
        arguments_0 = module_0.arguments()
        optional_0 = None
        parser_0.func_api(str_1, str_4, arguments_0, optional_0, has_self=bool_1, cls_method=bool_1)
    except BaseException:
        pass

def test_case_8():
    try:
        attribute_0 = module_0.Attribute()
        str_0 = '\ry'
        str_1 = ''
        expr_0 = module_0.expr()
        list_0 = [expr_0, expr_0]
        list_1 = [attribute_0]
        name_0 = module_0.Name(*list_1)
        import_0 = module_0.Import()
        list_2 = [name_0, import_0]
        dict_0 = {}
        parser_0 = module_1.Parser(dict_0)
        parser_0.class_api(str_0, str_1, list_0, list_2)
    except BaseException:
        pass

def test_case_9():
    try:
        str_0 = '6~A~3AR'
        bool_0 = module_1.is_public_family(str_0)
        str_1 = ''
        bool_1 = module_1.is_public_family(str_1)
        expr_0 = None
        bool_2 = True
        str_2 = 'JUZ\\'
        dict_0 = {str_0: str_0, str_2: str_2, str_2: str_2}
        parser_0 = module_1.Parser(bool_2, dict_0)
        str_3 = 'z0^x|b3F9oI&N:H!.Cb"'
        str_4 = '\roy;EwnoXCUN'
        str_5 = '+\r(E4?[!uqF'
        str_6 = '"@C'
        dict_1 = {str_3: dict_0, str_4: expr_0, str_4: str_1, str_5: str_6}
        assign_0 = module_0.Assign(**dict_1)
        str_7 = parser_0.resolve(str_1, expr_0, str_0)
    except BaseException:
        pass

def test_case_10():
    try:
        attribute_0 = module_0.Attribute()
        str_0 = None
        bool_0 = False
        parser_0 = module_1.Parser(bool_0)
        bool_1 = parser_0.is_public(str_0)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = 'NpWvf.'
        bool_0 = module_1.is_magic(str_0)
        str_1 = ':S'
        str_2 = None
        dict_0 = {str_1: str_2, str_2: bool_0}
        module_x_var_0 = module_2.module(**dict_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = '0'
        list_0 = [str_0]
        int_0 = -5359
        str_1 = 'D)<u#EEU-D_}~  I\t '
        str_2 = '@staticmethod'
        bool_0 = module_1.is_magic(str_2)
        str_3 = module_1.code(str_1)
        str_4 = module_1.esc_underscore(str_2)
        dict_0 = {str_3: str_0, str_3: str_3, str_2: str_0, str_0: str_3, str_1: str_3}
        name_0 = module_0.Name(*list_0)
        dict_1 = {str_2: name_0}
        async_function_def_0 = module_0.AsyncFunctionDef(*list_0, **dict_1)
        parser_0 = module_1.Parser(bool_0, int_0, bool_0, dict_0, dict_0)
        parser_0.api(str_1, async_function_def_0)
    except BaseException:
        pass

def test_case_13():
    try:
        bool_0 = False
        int_0 = -955
        dict_0 = None
        parser_0 = module_1.Parser(bool_0, int_0, dict_0)
        str_0 = '~6^Nv5'
        str_1 = 'xnMw"_X\x0c'
        str_2 = '$140UV"_'
        str_3 = ':S'
        str_4 = '\')w0QK)}V "HaJe'
        dict_1 = {str_1: bool_0, str_2: parser_0, str_3: str_1, str_4: str_2}
        import_0 = module_0.Import(**dict_1)
        parser_0.imports(str_0, import_0)
    except BaseException:
        pass

def test_case_14():
    try:
        list_0 = []
        list_1 = [list_0, list_0]
        attribute_0 = module_0.Attribute(*list_1)
        str_0 = '\nRQC!Xts'
        str_1 = '5\tC]:ztU9dQIa\t'
        str_2 = ";bb';vh1AfTBMZx"
        float_0 = -1555.042
        list_2 = [list_1, str_0, str_2, float_0]
        dict_0 = {str_1: list_0, str_1: list_0, str_0: str_1}
        arguments_0 = module_0.arguments(*list_2, **dict_0)
        expr_0 = module_0.expr()
        bool_0 = True
        bool_1 = True
        bool_2 = True
        str_3 = None
        dict_1 = {str_0: str_3, str_3: str_0}
        dict_2 = {}
        str_4 = None
        dict_3 = {str_3: str_4}
        parser_0 = module_1.Parser(bool_2, dict_1, dict_2, dict_3)
        parser_0.func_api(str_1, str_2, arguments_0, expr_0, has_self=bool_0, cls_method=bool_1)
    except BaseException:
        pass

def test_case_15():
    try:
        assign_0 = None
        str_0 = '[P\t\t$QcY'
        bool_0 = False
        int_0 = -2364
        bool_1 = False
        parser_0 = module_1.Parser(bool_0, int_0, bool_1)
        parser_0.globals(str_0, assign_0)
        str_1 = '_Self'
        import_from_0 = module_0.ImportFrom()
        str_2 = 'MIT'
        list_0 = [str_1, str_2, str_1]
        iterable_0 = None
        str_3 = module_1.table(*list_0, items=iterable_0)
    except BaseException:
        pass

def test_case_16():
    try:
        str_0 = "CU2j1'"
        str_1 = module_1.esc_underscore(str_0)
        list_0 = [str_0]
        arguments_0 = module_0.arguments(*list_0)
        str_2 = 'l|h?(^&i'
        str_3 = 'D)<u#EEU-D_}~  I\t '
        str_4 = '@staticmethod'
        bool_0 = module_1.is_magic(str_4)
        str_5 = 'N<'
        str_6 = '&'
        str_7 = None
        dict_0 = {str_5: str_0, str_3: str_4, str_2: str_6, str_7: str_0, str_3: str_2}
        dict_1 = {}
        parser_0 = module_1.Parser(dict_0, dict_0, dict_1)
        str_8 = 've'
        import_0 = module_0.Import(*list_0)
        parser_0.imports(str_8, import_0)
    except BaseException:
        pass

def test_case_17():
    try:
        int_0 = -5343
        str_0 = 'D)<u#EEU-D_}~  I\t '
        str_1 = '\x0c'
        list_0 = []
        list_1 = [list_0, list_0]
        import_from_0 = module_0.ImportFrom(*list_1)
        parser_0 = module_1.Parser()
        parser_0.imports(str_1, import_from_0)
        str_2 = '&'
        str_3 = None
        dict_0 = {str_2: int_0, str_0: int_0, str_1: int_0, str_3: int_0}
        str_4 = 'xD'
        str_5 = 'module'
        dict_1 = {str_5: dict_0, str_4: str_4, str_5: int_0, str_5: int_0}
        sequence_0 = module_3.Sequence(*list_1, **dict_1)
    except BaseException:
        pass

def test_case_18():
    try:
        str_0 = "CU2j1'"
        list_0 = [str_0]
        arguments_0 = module_0.arguments(*list_0)
        str_1 = '\x0c'
        str_2 = '!NU00U\n*%;{k(\nh/'
        bool_0 = module_1.is_public_family(str_2)
        str_3 = '$7$6+~F6Lkr'
        dict_0 = {}
        parser_0 = module_1.Parser(dict_0)
        parser_0.parse(str_1, str_3)
    except BaseException:
        pass

def test_case_19():
    try:
        str_0 = ''
        list_0 = [str_0]
        arguments_0 = module_0.arguments(*list_0)
        str_1 = 'l|h?(^&i'
        int_0 = -5359
        str_2 = 'D)<u#EEU-D_}~  I\t '
        bool_0 = module_1.is_public_family(str_2)
        str_3 = 'AST parser.\n\n    Usage:\n    >>> p = Parser()\n    >>> with open("pkg_path", \'r\') as f:\n    >>>     p.parse(\'pkg_name\', f.read())\n    >>> s = p.compile()\n\n    Or create with parameters:\n    >>> p = Parser.new(link=True, level=1)\n    '
        bool_1 = module_1.is_magic(str_3)
        str_4 = module_1.code(str_2)
        str_5 = module_1.esc_underscore(str_3)
        int_1 = 1
        list_1 = []
        stmt_0 = None
        list_2 = [stmt_0, stmt_0]
        dict_0 = {str_1: str_0, str_1: str_5, str_3: str_0, str_0: str_5, str_2: str_1}
        str_6 = 'qK\\p\r[f\t@Hqb'
        name_0 = module_0.Name(*list_0)
        resolver_0 = module_1.Resolver(str_4, dict_0, str_4)
        a_s_t_0 = resolver_0.visit_Name(name_0)
        dict_1 = {}
        parser_0 = module_1.Parser(dict_0, dict_0, dict_1)
        parser_0.class_api(str_2, str_2, list_1, list_2)
        dict_2 = {str_1: int_0, str_2: int_1, str_3: int_0, str_0: int_1}
        str_7 = module_1.doctest(str_6)
        str_8 = ')5DFt\rl'
        str_9 = 'p7A#&;X\n<8A(:HQf[c$}'
        dict_3 = {str_0: dict_2, str_8: str_8, str_9: int_1, str_0: int_0}
        parser_1 = module_1.Parser(dict_1)
        async_function_def_0 = module_0.AsyncFunctionDef(**dict_3)
        parser_2 = module_1.Parser(bool_0, dict_0)
        parser_2.api(str_5, async_function_def_0)
    except BaseException:
        pass

def test_case_20():
    try:
        str_0 = "C2j1'"
        list_0 = [str_0, str_0]
        arguments_0 = module_0.arguments(*list_0)
        str_1 = 'l|h?(^&i'
        int_0 = -5359
        str_2 = 'D)<u#EEU-D_}~  I\t '
        str_3 = '\x0c'
        int_1 = 1
        str_4 = '&'
        str_5 = None
        dict_0 = {str_3: str_0, str_1: str_4, str_5: str_0, str_2: str_1}
        dict_1 = {str_1: int_0, str_2: int_1, str_3: int_0, str_0: int_1}
        str_6 = ')5DFt\rl'
        str_7 = 'module'
        dict_2 = {str_0: dict_1, str_6: str_6, str_7: int_1, str_0: int_0}
        int_2 = 0
        dict_3 = {str_6: int_2, str_6: int_2, str_5: int_2}
        str_8 = 'G\t'
        parser_0 = module_1.Parser(dict_3, dict_0, dict_0, dict_0)
        assign_0 = module_0.Assign(*list_0, **dict_2)
        parser_0.globals(str_3, assign_0)
        str_9 = module_1.code(str_8)
        assign_1 = module_0.Assign(**dict_2)
        str_10 = '5?X9ugV->u{qm'
        import_from_0 = module_0.ImportFrom(*list_0)
        parser_0.imports(str_10, import_from_0)
    except BaseException:
        pass

def test_case_21():
    try:
        str_0 = ''
        list_0 = [str_0]
        arguments_0 = module_0.arguments(*list_0)
        int_0 = -5359
        str_1 = 'D)<u#EEU-D_}~  I\t '
        bool_0 = module_1.is_public_family(str_1)
        str_2 = '@staticmethod'
        bool_1 = module_1.is_magic(str_2)
        str_3 = module_1.code(str_1)
        dict_0 = {str_3: str_0, str_3: str_3, str_2: str_0, str_0: str_3, str_1: str_3}
        name_0 = module_0.Name(*list_0)
        dict_1 = {str_2: name_0}
        async_function_def_0 = module_0.AsyncFunctionDef(*list_0, **dict_1)
        parser_0 = module_1.Parser(bool_1, int_0, bool_0, dict_0, dict_0)
        parser_0.api(str_1, async_function_def_0)
    except BaseException:
        pass

def test_case_22():
    try:
        str_0 = '@6R~u1p:^1\x0cz2w.*Wk6W'
        str_1 = 'D)<u#EEU-D_}~  I\t '
        int_0 = 1688
        str_2 = ''
        list_0 = []
        stmt_0 = None
        list_1 = [list_0, list_0, int_0]
        str_3 = 'v"tJ'
        str_4 = module_1.doctest(str_3)
        import_from_0 = module_0.ImportFrom(*list_1)
        parser_0 = module_1.Parser()
        parser_0.imports(str_2, import_from_0)
        list_2 = [stmt_0, stmt_0]
        str_5 = '&'
        str_6 = None
        dict_0 = {str_2: str_6, str_0: str_5, str_6: str_6, str_1: str_0}
        str_7 = '$7$6+~F6Lkr'
        str_8 = '](#'
        set_0 = {str_1, str_8}
        dict_1 = {str_7: set_0, str_2: set_0}
        parser_1 = module_1.Parser(dict_0, dict_0, dict_1)
        parser_1.class_api(str_1, str_1, list_0, list_2)
        str_9 = ')AfDq`*U|`6i,}'
        bool_0 = parser_0.is_public(str_9)
    except BaseException:
        pass

def test_case_23():
    try:
        int_0 = -5359
        str_0 = 'D)<u#EEU-D_}~  I\t '
        int_1 = 1688
        str_1 = '\x0c'
        int_2 = 1
        list_0 = []
        stmt_0 = None
        list_1 = [list_0, list_0]
        import_from_0 = module_0.ImportFrom(*list_1)
        parser_0 = module_1.Parser()
        parser_0.imports(str_1, import_from_0)
        list_2 = [stmt_0, stmt_0]
        str_2 = ''
        str_3 = None
        dict_0 = {str_1: str_3, str_2: str_2, str_3: str_3, str_0: str_2}
        str_4 = 'qK\\p\r[f\t@HqUb'
        set_0 = {str_0, str_4}
        dict_1 = {str_0: set_0, str_1: set_0}
        parser_1 = module_1.Parser(dict_0, dict_0, dict_1)
        parser_1.class_api(str_0, str_0, list_0, list_2)
        dict_2 = {str_2: int_0, str_0: int_1, str_1: int_0, str_3: int_2}
        str_5 = 'module'
        dict_3 = {str_5: dict_2, str_5: str_5, str_5: int_2, str_5: int_1}
        int_3 = 2
        dict_4 = {str_2: int_3, str_2: int_3, str_3: int_3}
        str_6 = '@*`D#l]@9(Ez}'
        parser_2 = module_1.Parser(dict_0, dict_0, dict_1, dict_0, dict_0)
        resolver_0 = module_1.Resolver(str_2, dict_0, str_6)
        constant_0 = module_0.Constant(*list_1)
        str_7 = 'Q'
        arguments_0 = module_0.arguments(*list_1, **dict_3)
        optional_0 = None
        bool_0 = True
        bool_1 = False
        parser_3 = module_1.Parser(bool_1, dict_4, dict_0, dict_0)
        parser_3.func_api(str_7, str_5, arguments_0, optional_0, has_self=bool_0, cls_method=bool_0)
    except BaseException:
        pass

def test_case_24():
    try:
        str_0 = 'os.pa?h'
        bool_0 = module_1.is_public_family(str_0)
        str_1 = 'pth3ib.Pth'
        str_2 = 'Q'
        list_0 = [str_2, str_0, bool_0]
        assign_0 = module_0.Assign(*list_0)
        dict_0 = {str_1: str_2, str_1: str_1, str_1: str_2, str_1: str_1}
        parser_0 = module_1.Parser(dict_0)
        parser_0.globals(str_2, assign_0)
        sequence_0 = module_3.Sequence()
    except BaseException:
        pass