# Automatically generated by Pynguin.
import ansible.inventory.manager as module_0
import ansible.inventory.data as module_1

def test_case_0():
    pass

def test_case_1():
    tuple_0 = ()
    inventory_manager_0 = module_0.InventoryManager(tuple_0)
    var_0 = inventory_manager_0.get_hosts()

def test_case_2():
    list_0 = None
    list_1 = [list_0, list_0, list_0]
    var_0 = module_0.order_patterns(list_1)
    var_1 = None
    inventory_manager_0 = module_0.InventoryManager(var_1)
    str_0 = 'localhost'
    var_2 = inventory_manager_0.parse_source(str_0, str_0)
    var_3 = inventory_manager_0.refresh_inventory()

def test_case_3():
    inventory_data_0 = module_1.InventoryData()
    var_0 = module_0.split_host_pattern(inventory_data_0)

def test_case_4():
    var_0 = None
    inventory_manager_0 = module_0.InventoryManager(var_0, var_0)
    str_0 = '%(shebang)s\n%(coding)s\n_ANSIBALLZ_WRAPPER = True # For test-module.py script to tell this is a ANSIBALLZ_WRAPPER\n# This code is part of Ansible, but is an independent component.\n# The code in this particular templatable string, and this templatable string\n# only, is BSD licensed.  Modules which end up using this snippet, which is\n# dynamically combined together by Ansible still belong to the author of the\n# module, and they may assign their own license to the complete work.\n#\n# Copyright (c), James Cammarata, 2016\n# Copyright (c), Toshio Kuratomi, 2016\n#\n# Redistribution and use in source and binary forms, with or without modification,\n# are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above copyright notice,\n#      this list of conditions and the following disclaimer in the documentation\n#      and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\ndef _ansiballz_main():\n    import os\n    import os.path\n\n    # Access to the working directory is required by Python when using pipelining, as well as for the coverage module.\n    # Some platforms, such as macOS, may not allow querying the working directory when using become to drop privileges.\n    try:\n        os.getcwd()\n    except OSError:\n        try:\n            os.chdir(os.path.expanduser(\'~\'))\n        except OSError:\n            os.chdir(\'/\')\n\n%(rlimit)s\n\n    import sys\n    import __main__\n\n    # For some distros and python versions we pick up this script in the temporary\n    # directory.  This leads to problems when the ansible module masks a python\n    # library that another import needs.  We have not figured out what about the\n    # specific distros and python versions causes this to behave differently.\n    #\n    # Tested distros:\n    # Fedora23 with python3.4  Works\n    # Ubuntu15.10 with python2.7  Works\n    # Ubuntu15.10 with python3.4  Fails without this\n    # Ubuntu16.04.1 with python3.5  Fails without this\n    # To test on another platform:\n    # * use the copy module (since this shadows the stdlib copy module)\n    # * Turn off pipelining\n    # * Make sure that the destination file does not exist\n    # * ansible ubuntu16-test -m copy -a \'src=/etc/motd dest=/var/tmp/m\'\n    # This will traceback in shutil.  Looking at the complete traceback will show\n    # that shutil is importing copy which finds the ansible module instead of the\n    # stdlib module\n    scriptdir = None\n    try:\n        scriptdir = os.path.dirname(os.path.realpath(__main__.__file__))\n    except (AttributeError, OSError):\n        # Some platforms don\'t set __file__ when reading from stdin\n        # OSX raises OSError if using abspath() in a directory we don\'t have\n        # permission to read (realpath calls abspath)\n        pass\n\n    # Strip cwd from sys.path to avoid potential permissions issues\n    excludes = set((\'\', \'.\', scriptdir))\n    sys.path = [p for p in sys.path if p not in excludes]\n\n    import base64\n    import runpy\n    import shutil\n    import tempfile\n    import zipfile\n\n    if sys.version_info < (3,):\n        PY3 = False\n    else:\n        PY3 = True\n\n    ZIPDATA = """%(zipdata)s"""\n\n    # Note: temp_path isn\'t needed once we switch to zipimport\n    def invoke_module(modlib_path, temp_path, json_params):\n        # When installed via setuptools (including python setup.py install),\n        # ansible may be installed with an easy-install.pth file.  That file\n        # may load the system-wide install of ansible rather than the one in\n        # the module.  sitecustomize is the only way to override that setting.\n        z = zipfile.ZipFile(modlib_path, mode=\'a\')\n\n        # py3: modlib_path will be text, py2: it\'s bytes.  Need bytes at the end\n        sitecustomize = u\'import sys\\nsys.path.insert(0,"%%s")\\n\' %%  modlib_path\n        sitecustomize = sitecustomize.encode(\'utf-8\')\n        # Use a ZipInfo to work around zipfile limitation on hosts with\n        # clocks set to a pre-1980 year (for instance, Raspberry Pi)\n        zinfo = zipfile.ZipInfo()\n        zinfo.filename = \'sitecustomize.py\'\n        zinfo.date_time = ( %(year)i, %(month)i, %(day)i, %(hour)i, %(minute)i, %(second)i)\n        z.writestr(zinfo, sitecustomize)\n        z.close()\n\n        # Put the zipped up module_utils we got from the controller first in the python path so that we\n        # can monkeypatch the right basic\n        sys.path.insert(0, modlib_path)\n\n        # Monkeypatch the parameters into basic\n        from ansible.module_utils import basic\n        basic._ANSIBLE_ARGS = json_params\n%(coverage)s\n        # Run the module!  By importing it as \'__main__\', it thinks it is executing as a script\n        runpy.run_module(mod_name=\'%(module_fqn)s\', init_globals=dict(_module_fqn=\'%(module_fqn)s\', _modlib_path=modlib_path),\n                         run_name=\'__main__\', alter_sys=True)\n\n        # Ansible modules must exit themselves\n        print(\'{"msg": "New-style module did not handle its own exit", "failed": true}\')\n        sys.exit(1)\n\n    def debug(command, zipped_mod, json_params):\n        # The code here normally doesn\'t run.  It\'s only used for debugging on the\n        # remote machine.\n        #\n        # The subcommands in this function make it easier to debug ansiballz\n        # modules.  Here\'s the basic steps:\n        #\n        # Run ansible with the environment variable: ANSIBLE_KEEP_REMOTE_FILES=1 and -vvv\n        # to save the module file remotely::\n        #   $ ANSIBLE_KEEP_REMOTE_FILES=1 ansible host1 -m ping -a \'data=october\' -vvv\n        #\n        # Part of the verbose output will tell you where on the remote machine the\n        # module was written to::\n        #   [...]\n        #   <host1> SSH: EXEC ssh -C -q -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o\n        #   PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o\n        #   ControlPath=/home/badger/.ansible/cp/ansible-ssh-%%h-%%p-%%r -tt rhel7 \'/bin/sh -c \'"\'"\'LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8\n        #   LC_MESSAGES=en_US.UTF-8 /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping\'"\'"\'\'\n        #   [...]\n        #\n        # Login to the remote machine and run the module file via from the previous\n        # step with the explode subcommand to extract the module payload into\n        # source files::\n        #   $ ssh host1\n        #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping explode\n        #   Module expanded into:\n        #   /home/badger/.ansible/tmp/ansible-tmp-1461173408.08-279692652635227/ansible\n        #\n        # You can now edit the source files to instrument the code or experiment with\n        # different parameter values.  When you\'re ready to run the code you\'ve modified\n        # (instead of the code from the actual zipped module), use the execute subcommand like this::\n        #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping execute\n\n        # Okay to use __file__ here because we\'re running from a kept file\n        basedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), \'debug_dir\')\n        args_path = os.path.join(basedir, \'args\')\n\n        if command == \'explode\':\n            # transform the ZIPDATA into an exploded directory of code and then\n            # print the path to the code.  This is an easy way for people to look\n            # at the code on the remote machine for debugging it in that\n            # environment\n            z = zipfile.ZipFile(zipped_mod)\n            for filename in z.namelist():\n                if filename.startswith(\'/\'):\n                    raise Exception(\'Something wrong with this module zip file: should not contain absolute paths\')\n\n                dest_filename = os.path.join(basedir, filename)\n                if dest_filename.endswith(os.path.sep) and not os.path.exists(dest_filename):\n                    os.makedirs(dest_filename)\n                else:\n                    directory = os.path.dirname(dest_filename)\n                    if not os.path.exists(directory):\n                        os.makedirs(directory)\n                    f = open(dest_filename, \'wb\')\n                    f.write(z.read(filename))\n                    f.close()\n\n            # write the args file\n            f = open(args_path, \'wb\')\n            f.write(json_params)\n            f.close()\n\n            print(\'Module expanded into:\')\n            print(\'%%s\' %% basedir)\n            exitcode = 0\n\n        elif command == \'execute\':\n            # Execute the exploded code instead of executing the module from the\n            # embedded ZIPDATA.  This allows people to easily run their modified\n            # code on the remote machine to see how changes will affect it.\n\n            # Set pythonpath to the debug dir\n            sys.path.insert(0, basedir)\n\n            # read in the args file which the user may have modified\n            with open(args_path, \'rb\') as f:\n                json_params = f.read()\n\n            # Monkeypatch the parameters into basic\n            from ansible.module_utils import basic\n            basic._ANSIBLE_ARGS = json_params\n\n            # Run the module!  By importing it as \'__main__\', it thinks it is executing as a script\n            runpy.run_module(mod_name=\'%(module_fqn)s\', init_globals=None, run_name=\'__main__\', alter_sys=True)\n\n            # Ansible modules must exit themselves\n            print(\'{"msg": "New-style module did not handle its own exit", "failed": true}\')\n            sys.exit(1)\n\n        else:\n            print(\'WARNING: Unknown debug command.  Doing nothing.\')\n            exitcode = 0\n\n        return exitcode\n\n    #\n    # See comments in the debug() method for information on debugging\n    #\n\n    ANSIBALLZ_PARAMS = %(params)s\n    if PY3:\n        ANSIBALLZ_PARAMS = ANSIBALLZ_PARAMS.encode(\'utf-8\')\n    try:\n        # There\'s a race condition with the controller removing the\n        # remote_tmpdir and this module executing under async.  So we cannot\n        # store this in remote_tmpdir (use system tempdir instead)\n        # Only need to use [ansible_module]_payload_ in the temp_path until we move to zipimport\n        # (this helps ansible-test produce coverage stats)\n        temp_path = tempfile.mkdtemp(prefix=\'ansible_%(ansible_module)s_payload_\')\n\n        zipped_mod = os.path.join(temp_path, \'ansible_%(ansible_module)s_payload.zip\')\n\n        with open(zipped_mod, \'wb\') as modlib:\n            modlib.write(base64.b64decode(ZIPDATA))\n\n        if len(sys.argv) == 2:\n            exitcode = debug(sys.argv[1], zipped_mod, ANSIBALLZ_PARAMS)\n        else:\n            # Note: temp_path isn\'t needed once we switch to zipimport\n            invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS)\n    finally:\n        try:\n            shutil.rmtree(temp_path)\n        except (NameError, OSError):\n            # tempdir creation probably failed\n            pass\n    sys.exit(exitcode)\n\nif __name__ == \'__main__\':\n    _ansiballz_main()\n'
    var_1 = inventory_manager_0.get_hosts(str_0)
    dict_0 = {}
    var_2 = inventory_manager_0.get_hosts(dict_0)
    var_3 = inventory_manager_0.list_groups()

def test_case_5():
    str_0 = 'DEFAULT_TEST_COMMAND'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)

def test_case_6():
    bool_0 = True
    inventory_manager_0 = module_0.InventoryManager(bool_0)

def test_case_7():
    str_0 = 'S;;V|VcR'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.reconcile_inventory()

def test_case_8():
    dict_0 = {}
    str_0 = '\x0bgC,'
    inventory_manager_0 = module_0.InventoryManager(dict_0, str_0)
    var_0 = inventory_manager_0.clear_pattern_cache()

def test_case_9():
    str_0 = 'S;;V|VcR'
    str_1 = '\x0c\x0b=,oRT:T\t8'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_1)
    var_0 = inventory_manager_0.reconcile_inventory()

def test_case_10():
    var_0 = None
    inventory_manager_0 = module_0.InventoryManager(var_0)
    str_0 = 'localhost'
    var_1 = inventory_manager_0.parse_source(str_0, str_0)
    var_2 = inventory_manager_0.refresh_inventory()

def test_case_11():
    str_0 = 'Z'
    inventory_manager_0 = module_0.InventoryManager(str_0)
    var_0 = None
    var_1 = inventory_manager_0.subset(var_0)
    str_1 = '/ll'
    var_2 = inventory_manager_0.subset(str_1)
    var_3 = inventory_manager_0.get_hosts()

def test_case_12():
    inventory_data_0 = module_1.InventoryData()
    str_0 = 'localhost'
    str_1 = [str_0, inventory_data_0]
    inventory_manager_0 = module_0.InventoryManager(str_1)
    var_0 = inventory_manager_0.list_hosts(str_1)
    var_1 = inventory_manager_0.list_groups()
    var_2 = inventory_manager_0.get_hosts()

def test_case_13():
    tuple_0 = ()
    inventory_manager_0 = module_0.InventoryManager(tuple_0)
    var_0 = inventory_manager_0.get_hosts(inventory_manager_0)

def test_case_14():
    var_0 = None
    inventory_manager_0 = module_0.InventoryManager(var_0, var_0)
    var_1 = inventory_manager_0.list_hosts()

def test_case_15():
    str_0 = 'DEFAULT_TEST_COMMAND'
    inventory_manager_0 = module_0.InventoryManager(str_0, str_0)
    var_0 = inventory_manager_0.list_groups()

def test_case_16():
    list_0 = []
    int_0 = 128
    str_0 = 'S;Gy\r~tUvB'
    inventory_manager_0 = module_0.InventoryManager(int_0, str_0)
    var_0 = inventory_manager_0.restrict_to_hosts(list_0)

def test_case_17():
    str_0 = ''
    inventory_manager_0 = module_0.InventoryManager(str_0)
    var_0 = inventory_manager_0.subset(inventory_manager_0)

def test_case_18():
    bool_0 = True
    inventory_manager_0 = module_0.InventoryManager(bool_0)
    float_0 = 1864.0
    var_0 = module_0.split_host_pattern(float_0)
    str_0 = 'E~{D xeOYNh;=LKO"`z'
    var_1 = module_0.split_host_pattern(str_0)
    var_2 = inventory_manager_0.remove_restriction()

def test_case_19():
    str_0 = '!A\x0cP!T\rLU2Q^*\\:\\iu?<'
    var_0 = module_0.split_host_pattern(str_0)

def test_case_20():
    str_0 = '\tsw5{C]&UxJ'
    str_1 = '}'
    bytes_0 = b'.\xbb,\xf8\xd2$\xeb\x0c\xdd\xfc.0\xda'
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(str_1, bytes_0, list_0)
    set_0 = {str_0}
    bytes_1 = b"\x03\xdc\xbd!\t\xfdK \r\xab@6\x00\x87\x0b'l"
    inventory_manager_1 = module_0.InventoryManager(bytes_1)
    var_0 = inventory_manager_1.subset(set_0)

def test_case_21():
    str_0 = 'Z'
    inventory_manager_0 = module_0.InventoryManager(str_0)
    var_0 = inventory_manager_0.clear_caches()
    list_0 = []
    var_1 = inventory_manager_0.parse_source(list_0)
    str_1 = '/ll'
    tuple_0 = None
    var_2 = inventory_manager_0.parse_source(tuple_0, tuple_0)
    var_3 = inventory_manager_0.subset(str_1)
    bytes_0 = b'\xda\xd6\xf9\x04\xfdOt\xaf\xc3\x10'
    str_2 = '\n    A CSV reader which will iterate over lines in the CSV file "f",\n    which is encoded in the given encoding.\n    '
    var_4 = inventory_manager_0.get_hosts(bytes_0, str_2)
    var_5 = inventory_manager_0.get_hosts()

def test_case_22():
    int_0 = -327
    set_0 = {int_0}
    bytes_0 = b'\x05HG\xa7\xd1\xdb\xbd'
    inventory_manager_0 = module_0.InventoryManager(bytes_0)
    var_0 = inventory_manager_0.parse_source(set_0)

def test_case_23():
    str_0 = 'tg%~\r'
    var_0 = module_0.order_patterns(str_0)
    str_1 = ',(:C3Mt-mC&eEc~^lV^j'
    var_1 = module_0.split_host_pattern(str_1)
    bytes_0 = None
    bytes_1 = b'\x0e\xfa\xb1\x81V\xf0p\xbb\xba\xd4\xb8'
    inventory_manager_0 = module_0.InventoryManager(bytes_1)
    bool_0 = False
    inventory_manager_1 = module_0.InventoryManager(bool_0)
    var_2 = inventory_manager_1.remove_restriction()
    list_0 = None
    var_3 = inventory_manager_0.subset(list_0)
    var_4 = inventory_manager_0.get_host(bytes_0)

def test_case_24():
    str_0 = ''
    inventory_manager_0 = module_0.InventoryManager(str_0)
    var_0 = None
    var_1 = inventory_manager_0.subset(var_0)
    str_1 = 'all'
    var_2 = inventory_manager_0.subset(str_1)

def test_case_25():
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(list_0, list_0)
    var_0 = inventory_manager_0.list_groups()
    str_0 = '\x0c1#~$9Ei^IqoIf\x0b,O'
    inventory_data_0 = module_1.InventoryData()
    bytes_0 = b'\xb5\x87\xfem\xf7\xf7\xf4\x8bQ\t\xe4\x01\xe7'
    var_1 = inventory_manager_0.get_hosts(inventory_data_0, bytes_0)
    var_2 = inventory_manager_0.parse_source(str_0)
    bool_0 = False
    var_3 = inventory_manager_0.subset(bool_0)
    bytes_1 = b'\x95\x98\xc1\xf6\xe4\x80r\x0f'
    inventory_manager_1 = module_0.InventoryManager(list_0)
    var_4 = inventory_manager_1.get_hosts(list_0, bytes_1)
    var_5 = inventory_manager_1.list_groups()
    var_6 = inventory_manager_0.get_hosts()

def test_case_26():
    int_0 = 446
    bool_0 = False
    str_0 = 'o/+HD4;}]Kr3v=o~~'
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(list_0)
    var_0 = inventory_manager_0.get_hosts(int_0, bool_0, str_0)

def test_case_27():
    str_0 = 'localhost'
    str_1 = [str_0]
    inventory_manager_0 = module_0.InventoryManager(str_1)
    var_0 = inventory_manager_0.list_hosts()
    var_1 = inventory_manager_0.list_hosts(str_0)
    str_2 = 'foo'
    var_2 = inventory_manager_0.list_hosts(str_2)
    var_3 = inventory_manager_0.list_hosts(str_2)
    var_4 = inventory_manager_0.list_hosts(str_1)
    var_5 = inventory_manager_0.list_hosts(str_0)
    var_6 = inventory_manager_0.list_hosts(str_2)
    var_7 = inventory_manager_0.list_hosts(str_1)

def test_case_28():
    str_0 = ']W'
    bool_0 = True
    inventory_manager_0 = module_0.InventoryManager(bool_0, str_0)
    var_0 = inventory_manager_0.subset(str_0)
    var_1 = inventory_manager_0.list_hosts()
    str_1 = 'WDIq.l\tTw'
    var_2 = inventory_manager_0.list_hosts(str_1)
    var_3 = inventory_manager_0.list_groups()
    str_2 = None
    var_4 = inventory_manager_0.list_hosts(str_2)
    var_5 = inventory_manager_0.reconcile_inventory()
    var_6 = inventory_manager_0.remove_restriction()
    set_0 = {str_2, bool_0}
    var_7 = inventory_manager_0.parse_source(set_0)
    var_8 = inventory_manager_0.parse_sources()
    var_9 = inventory_manager_0.list_hosts()
    str_3 = 'jT'
    int_0 = 1355
    var_10 = inventory_manager_0.get_hosts(inventory_manager_0, str_3, int_0)
    str_4 = '[sh%;a,K!\t`'
    inventory_manager_1 = module_0.InventoryManager(inventory_manager_0)
    var_11 = inventory_manager_1.parse_source(str_4)
    var_12 = inventory_manager_1.refresh_inventory()
    str_5 = 'H!9zQ|Dd\x0cT\\#p&'
    dict_0 = {}
    var_13 = inventory_manager_1.get_groups_dict()
    inventory_manager_2 = module_0.InventoryManager(str_5, dict_0)
    var_14 = inventory_manager_1.remove_restriction()
    var_15 = inventory_manager_1.restrict_to_hosts(str_2)

def test_case_29():
    bytes_0 = b'F\xb3\xb1&X\x9f[Zbj\xf8\x13\xc8\xe7\x94\xf9\x13{f\xb9'
    list_0 = [bytes_0, bytes_0, bytes_0, bytes_0]
    var_0 = module_0.split_host_pattern(list_0)

def test_case_30():
    str_0 = '!host2'
    str_1 = 'host1'
    str_2 = 'host3'
    str_3 = 'host4'
    str_4 = '&host7'
    str_5 = '&host8'
    str_6 = [str_0, str_1, str_2, str_3, str_4, str_5, str_5]
    var_0 = module_0.order_patterns(str_6)

def test_case_31():
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(list_0, list_0)
    str_0 = '\x0c1#~$9Ei^IqoIf\x0b,O'
    var_0 = inventory_manager_0.parse_source(str_0)
    bool_0 = False
    var_1 = inventory_manager_0.subset(bool_0)
    var_2 = inventory_manager_0.get_hosts()

def test_case_32():
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(list_0, list_0)
    str_0 = '\x0c1#~$9Ei^IqoIf\x0b,O'
    var_0 = inventory_manager_0.parse_source(str_0)
    var_1 = inventory_manager_0.get_hosts()

def test_case_33():
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(list_0, list_0)
    str_0 = '\x0c1#~$9Ei^IqoIf\x0b,O'
    var_0 = inventory_manager_0.parse_source(str_0)
    bool_0 = False
    var_1 = inventory_manager_0.subset(bool_0)
    var_2 = inventory_manager_0.list_groups()
    var_3 = inventory_manager_0.get_hosts(str_0)

def test_case_34():
    inventory_data_0 = module_1.InventoryData()
    str_0 = 'localhost'
    str_1 = [str_0, inventory_data_0]
    inventory_manager_0 = module_0.InventoryManager(str_1)
    var_0 = inventory_manager_0.list_hosts()
    str_2 = 'uR4GpMmU(]!n/.W'
    var_1 = inventory_manager_0.list_hosts(str_2)
    var_2 = inventory_manager_0.list_groups()
    var_3 = inventory_manager_0.get_hosts()

def test_case_35():
    inventory_data_0 = module_1.InventoryData()
    inventory_manager_0 = module_0.InventoryManager(inventory_data_0)
    str_0 = 'localhost'
    str_1 = [inventory_manager_0, str_0, str_0]
    inventory_manager_1 = module_0.InventoryManager(str_1)
    var_0 = inventory_manager_1.list_hosts()
    str_2 = 'uR4GpMmU(]!n/.W'
    var_1 = inventory_manager_1.list_hosts(str_2)
    bool_0 = True
    var_2 = inventory_manager_1.subset(bool_0)
    var_3 = inventory_manager_1.list_hosts(str_2)
    var_4 = inventory_manager_1.refresh_inventory()
    var_5 = inventory_manager_1.list_hosts(str_1)
    var_6 = inventory_manager_1.list_groups()
    inventory_data_1 = module_1.InventoryData()
    var_7 = inventory_manager_1.get_hosts()
    var_8 = inventory_manager_0.list_groups()

def test_case_36():
    list_0 = []
    inventory_manager_0 = module_0.InventoryManager(list_0, list_0)
    bytes_0 = b'\x9c\x89\x7f\xbf\xdf\xae\x8c\x11\x0c3\xc0\xd4\x00\x9d\xdb\xac\x05['
    var_0 = inventory_manager_0.subset(bytes_0)
    var_1 = inventory_manager_0.list_hosts()
    var_2 = None
    var_3 = inventory_manager_0.subset(var_2)
    var_4 = inventory_manager_0.list_groups()
    str_0 = '.'
    inventory_manager_1 = module_0.InventoryManager(inventory_manager_0, str_0)