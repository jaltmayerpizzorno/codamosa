# Automatically generated by Pynguin.
import tornado.netutil as module_0
import socket as module_1
import ssl as module_2

def test_case_0():
    try:
        int_0 = 4770
        int_1 = 46
        str_0 = 'I'
        socket_0 = module_0.bind_unix_socket(str_0, int_0, int_0)
        list_0 = module_0.bind_sockets(int_1)
    except BaseException:
        pass

def test_case_1():
    try:
        executor_resolver_0 = module_0.ExecutorResolver()
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = '\\NLr%[z'
        int_0 = 657
        list_0 = []
        resolver_0 = module_0.Resolver(*list_0)
        awaitable_0 = resolver_0.resolve(str_0, int_0)
        str_1 = 'E]m=b,ks<|MDH3'
        int_1 = -2927
        list_1 = module_0.bind_sockets(int_1, str_1)
    except BaseException:
        pass

def test_case_3():
    try:
        blocking_resolver_0 = module_0.BlockingResolver()
    except BaseException:
        pass

def test_case_4():
    try:
        resolver_0 = module_0.Resolver()
        int_0 = 16
        str_0 = 'j^\x0cca.\t%\x0cB^%2\x0b5Qo'
        str_1 = '0tn!Pvi'
        int_1 = -1681
        awaitable_0 = resolver_0.resolve(str_1, int_1)
        bool_0 = module_0.is_valid_ip(str_0)
        str_2 = 'I'
        int_2 = -4566
        socket_0 = module_0.bind_unix_socket(str_2, int_2, int_2)
        list_0 = module_0.bind_sockets(int_0)
        var_0 = socket_0.__enter__()
        dict_0 = {}
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_0)
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_5():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_6():
    try:
        str_0 = 'Go$,!+<KR(IgW0!'
        int_0 = 924
        str_1 = '.P/FU\\lYqi'
        list_0 = []
        list_1 = [str_1, list_0]
        override_resolver_0 = module_0.OverrideResolver(*list_1)
        awaitable_0 = override_resolver_0.resolve(str_0, int_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = 'lZa;/|=D\x0cknt5$,4Y'
        int_0 = 128
        str_1 = 'posix'
        dict_0 = {str_0: int_0, str_0: int_0, str_1: int_0}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = 'cert_reqs'
        dict_0 = {str_0: str_0}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_9():
    try:
        socket_0 = module_1.socket()
        int_0 = 1017
        tuple_0 = (int_0, socket_0)
        list_0 = [tuple_0, tuple_0, tuple_0]
        callable_0 = module_0.add_accept_handler(socket_0, list_0)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = None
        int_0 = -2002
        socket_0 = module_0.bind_unix_socket(str_0, int_0)
    except BaseException:
        pass

def test_case_11():
    try:
        socket_0 = module_1.socket()
        s_s_l_context_0 = None
        optional_0 = None
        str_0 = 'nmYv&bo,=@f_&t?B\t'
        dict_0 = {str_0: str_0, str_0: socket_0}
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, s_s_l_context_0, optional_0, **dict_0)
    except BaseException:
        pass

def test_case_12():
    try:
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        int_0 = 97
        str_0 = 'I'
        socket_0 = module_0.bind_unix_socket(str_0, int_0, int_0)
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, s_s_l_context_0)
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_13():
    try:
        socket_0 = module_1.socket()
        dict_0 = {}
        s_s_l_context_0 = module_2.SSLContext(**dict_0)
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, s_s_l_context_0, **dict_0)
        resolver_0 = module_0.Resolver()
        str_0 = None
        int_0 = -3748
        awaitable_0 = resolver_0.resolve(str_0, int_0)
        int_1 = 2
        str_1 = '0tn!Pvi'
        awaitable_1 = resolver_0.resolve(str_1, int_1)
        bool_0 = module_0.is_valid_ip(str_0)
        str_2 = 'I'
        int_2 = -4581
        socket_1 = module_0.bind_unix_socket(str_2, int_2, int_2)
        list_0 = module_0.bind_sockets(int_1)
        var_0 = socket_1.__enter__()
        list_1 = module_0.bind_sockets(int_1, str_1, int_2)
    except BaseException:
        pass

def test_case_14():
    try:
        resolver_0 = module_0.Resolver()
        str_0 = 'j^\x0cca.\t%\x0cB^%2\x0b5Qo'
        bool_0 = module_0.is_valid_ip(str_0)
        str_1 = '/'
        int_0 = -4566
        socket_0 = module_0.bind_unix_socket(str_1, int_0, int_0)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = None
        int_0 = -2002
        address_family_0 = None
        bool_0 = False
        list_0 = module_0.bind_sockets(int_0, str_0, address_family_0, int_0, bool_0)
    except BaseException:
        pass

def test_case_16():
    try:
        resolver_0 = module_0.Resolver()
        str_0 = 'Allows to set context for translation, accepts plural forms.\n\n        Usage example::\n\n            pgettext("law", "right")\n            pgettext("good", "right")\n\n        Plural message example::\n\n            pgettext("organization", "club", "clubs", len(clubs))\n            pgettext("stick", "club", "clubs", len(clubs))\n\n        To generate POT file with context, add following options to step 1\n        of `load_gettext_translations` sequence::\n\n            xgettext [basic options] --keyword=pgettext:1c,2 --keyword=pgettext:1c,2,3\n\n        .. versionadded:: 4.2\n        '
        int_0 = -1205
        awaitable_0 = resolver_0.resolve(str_0, int_0)
        bool_0 = module_0.is_valid_ip(str_0)
    except BaseException:
        pass

def test_case_17():
    try:
        socket_0 = module_1.socket()
        dict_0 = {}
        s_s_l_context_0 = module_2.SSLContext(**dict_0)
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, s_s_l_context_0, **dict_0)
        resolver_0 = module_0.Resolver()
        str_0 = None
        int_0 = -3748
        awaitable_0 = resolver_0.resolve(str_0, int_0)
        int_1 = 16
        str_1 = 'j^\x0cca.\t%\x0cB^%2\x0b5Qo'
        str_2 = '0tn!Pvi'
        int_2 = -1681
        awaitable_1 = resolver_0.resolve(str_2, int_2)
        list_0 = [socket_0, awaitable_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        override_resolver_0.close()
        bool_0 = module_0.is_valid_ip(str_1)
        str_3 = 'I'
        int_3 = -4566
        socket_1 = module_0.bind_unix_socket(str_3, int_3, int_3)
        list_1 = module_0.bind_sockets(int_1)
    except BaseException:
        pass

def test_case_18():
    try:
        resolver_0 = module_0.Resolver()
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        str_0 = '0'
        bool_0 = module_0.is_valid_ip(str_0)
        str_1 = 'Logs the current request.\n\n        Sort of deprecated since this functionality was moved to the\n        Application, but left in place for the benefit of existing apps\n        that have overridden this method.\n        '
        int_0 = 111
        socket_0 = module_0.bind_unix_socket(str_1, int_0)
    except BaseException:
        pass

def test_case_19():
    try:
        str_0 = 'o0EFEBKKOr\r4\\.m/y.l'
        bool_0 = module_0.is_valid_ip(str_0)
        int_0 = None
        str_1 = '9'
        list_0 = module_0.bind_sockets(int_0, str_1, bool_0)
    except BaseException:
        pass