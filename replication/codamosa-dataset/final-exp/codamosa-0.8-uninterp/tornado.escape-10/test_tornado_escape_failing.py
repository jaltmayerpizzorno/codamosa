# Automatically generated by Pynguin.
import tornado.escape as module_0

def test_case_0():
    try:
        str_0 = '3'
        list_0 = []
        str_1 = 'rCCt`fTrX*AHK'
        dict_0 = {str_0: list_0, str_1: list_0, str_0: list_0, str_0: list_0}
        str_2 = module_0.json_encode(dict_0)
        bytes_0 = b'\x87\x89'
        optional_0 = module_0.to_unicode(bytes_0)
    except BaseException:
        pass

def test_case_1():
    try:
        bytes_0 = b'6\xb3\x1b>\xd5#\x8bs'
        any_0 = module_0.json_decode(bytes_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = None
        str_1 = module_0.squeeze(str_0)
    except BaseException:
        pass

def test_case_3():
    try:
        bytes_0 = b'\xd9\x8e\xb1h\x1c\xa0'
        bool_0 = None
        var_0 = module_0.url_unescape(bytes_0, bool_0)
    except BaseException:
        pass

def test_case_4():
    try:
        bytes_0 = b'\xef\x0bwV\x0b%\xd3\xf8":\xe7\xde%\xd3\xc1\xee\x9e'
        var_0 = module_0.url_unescape(bytes_0)
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = '}FERso!nH?r]>m'
        bool_0 = True
        bool_1 = False
        dict_0 = module_0.parse_qs_bytes(str_0, bool_0, bool_1)
        any_0 = module_0.json_decode(str_0)
    except BaseException:
        pass

def test_case_6():
    try:
        bytes_0 = b"0\x98\x17'o\x99w\xba}\xcd\xcb\x1cI\xdc_|"
        dict_0 = module_0.parse_qs_bytes(bytes_0)
        str_0 = module_0.xhtml_escape(bytes_0)
    except BaseException:
        pass

def test_case_7():
    try:
        float_0 = 1051.3705
        str_0 = ' 5m/'
        var_0 = module_0.url_unescape(str_0)
        optional_0 = module_0.utf8(float_0)
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = 'https://github.com/google'
        optional_0 = module_0.to_unicode(str_0)
        dict_0 = {optional_0: optional_0, str_0: optional_0, optional_0: optional_0}
        any_0 = module_0.recursive_unicode(dict_0)
        bytes_0 = b'+3[}'
        str_1 = module_0.xhtml_escape(bytes_0)
        str_2 = None
        str_3 = module_0.squeeze(str_2)
    except BaseException:
        pass

def test_case_9():
    try:
        str_0 = 'd\n;\x0bBrY*,HDx['
        list_0 = [str_0, str_0]
        str_1 = module_0.linkify(str_0, str_0, list_0)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = 'A command line parsing module that lets modules define their own options.\n\nThis module is inspired by Google\'s `gflags\n<https://github.com/google/python-gflags>`_. The primary difference\nwith libraries such as `argparse` is that a global registry is used so\nthat options may be defined in any module (it also enables\n`tornado.log` by default). The rest of Tornado does not depend on this\nmodule, so feel free to use `argparse` or other configuration\nlibraries if you prefer them.\n\nOptions must be defined with `tornado.options.define` before use,\ngenerally at the top level of a module. The options are then\naccessible as attributes of `tornado.options.options`::\n\n    # myapp/db.py\n    from tornado.options import define, options\n\n    define("mysql_host", default="127.0.0.1:3306", help="Main user DB")\n    define("memcache_hosts", default="127.0.0.1:11011", multiple=True,\n           help="Main user memcache servers")\n\n    def connect():\n        db = database.Connection(options.mysql_host)\n        ...\n\n    # myapp/server.py\n    from tornado.options import define, options\n\n    define("port", default=8080, help="port to listen on")\n\n    def start_server():\n        app = make_app()\n        app.listen(options.port)\n\nThe ``main()`` method of your application does not need to be aware of all of\nthe options used throughout your program; they are all automatically loaded\nwhen the modules are loaded.  However, all modules that define options\nmust have been imported before the command line is parsed.\n\nYour ``main()`` method can parse the command line or parse a config file with\neither `parse_command_line` or `parse_config_file`::\n\n    import myapp.db, myapp.server\n    import tornado.options\n\n    if __name__ == \'__main__\':\n        tornado.options.parse_command_line()\n        # or\n        tornado.options.parse_config_file("/etc/server.conf")\n\n.. note::\n\n   When using multiple ``parse_*`` functions, pass ``final=False`` to all\n   but the last one, or side effects may occur twice (in particular,\n   this can result in log messages being doubled).\n\n`tornado.options.options` is a singleton instance of `OptionParser`, and\nthe top-level functions in this module (`define`, `parse_command_line`, etc)\nsimply call methods on it.  You may create additional `OptionParser`\ninstances to define isolated sets of options, such as for subcommands.\n\n.. note::\n\n   By default, several options are defined that will configure the\n   standard `logging` module when `parse_command_line` or `parse_config_file`\n   are called.  If you want Tornado to leave the logging configuration\n   alone so you can manage it yourself, either pass ``--logging=none``\n   on the command line or do the following to disable it in code::\n\n       from tornado.options import options, parse_command_line\n       options.logging = None\n       parse_command_line()\n\n.. versionchanged:: 4.3\n   Dashes and underscores are fully interchangeable in option names;\n   options can be defined, set, and read with any mix of the two.\n   Dashes are typical for command-line usage while config files require\n   underscores.\n'
        str_1 = '\x0ctq\x0b&6O==V'
        str_2 = '"V3$vI_%C\r05+7'
        list_0 = [str_2, str_1, str_0, str_1]
        str_3 = module_0.linkify(str_0, list_0)
        bool_0 = False
        str_4 = module_0.xhtml_unescape(str_3)
        str_5 = module_0.json_encode(str_2)
        dict_0 = module_0.parse_qs_bytes(str_4)
        bytes_0 = b'J\xe0'
        str_6 = module_0.linkify(bytes_0, bool_0, str_4)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = ''
        str_1 = '\x0ctq\x0b&6O==V'
        str_2 = '"V3$vI_%C\r05+7'
        list_0 = [str_0, str_1, str_1, str_1]
        str_3 = module_0.linkify(str_0, list_0)
        var_0 = module_0.url_unescape(str_0)
        str_4 = module_0.url_escape(str_1)
        str_5 = module_0.json_encode(list_0)
        str_6 = module_0.json_encode(str_3)
        str_7 = module_0.xhtml_unescape(str_3)
        str_8 = module_0.json_encode(str_2)
        dict_0 = module_0.parse_qs_bytes(str_7)
        bool_0 = False
        var_1 = module_0.url_unescape(str_6, str_5, bool_0)
        str_9 = ')]H'
        bytes_0 = b'\x8cJ\xe0'
        str_10 = module_0.linkify(bytes_0, bool_0, str_9)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = '@02q4EXopc+'
        bool_0 = False
        optional_0 = module_0.utf8(str_0)
        dict_0 = module_0.parse_qs_bytes(str_0)
        any_0 = module_0.recursive_unicode(dict_0)
        bytes_0 = b'\xee\x80\x9a\xd0\x9e\xd5t\x15a\xd8\x1b?\xca\xed\xbah .'
        str_1 = module_0.url_escape(bytes_0, bool_0)
        str_2 = module_0.xhtml_escape(str_0)
        any_1 = module_0.json_decode(str_1)
    except BaseException:
        pass

def test_case_13():
    try:
        str_0 = "Decorator to run a synchronous method asynchronously on an executor.\n\n    Returns a future.\n\n    The executor to be used is determined by the ``executor``\n    attributes of ``self``. To use a different attribute name, pass a\n    keyword argument to the decorator::\n\n        @run_on_executor(executor='_thread_pool')\n        def foo(self):\n            pass\n\n    This decorator should not be confused with the similarly-named\n    `.IOLoop.run_in_executor`. In general, using ``run_in_executor``\n    when *calling* a blocking method is recommended instead of using\n    this decorator when *defining* a method. If compatibility with older\n    versions of Tornado is required, consider defining an executor\n    and using ``executor.submit()`` at the call site.\n\n    .. versionchanged:: 4.2\n       Added keyword arguments to use alternative attributes.\n\n    .. versionchanged:: 5.0\n       Always uses the current IOLoop instead of ``self.io_loop``.\n\n    .. versionchanged:: 5.1\n       Returns a `.Future` compatible with ``await`` instead of a\n       `concurrent.futures.Future`.\n\n    .. deprecated:: 5.1\n\n       The ``callback`` argument is deprecated and will be removed in\n       6.0. The decorator itself is discouraged in new code but will\n       not be removed in 6.0.\n\n    .. versionchanged:: 6.0\n\n       The ``callback`` argument was removed.\n    "
        bytes_0 = b''
        bool_0 = False
        str_1 = ':l"%4A_w_2eW[H37#uV'
        var_0 = module_0.url_unescape(bytes_0)
        var_1 = module_0.url_unescape(bytes_0, bool_0)
        str_2 = ';$1y!Ysy,\t`v'
        str_3 = module_0.xhtml_unescape(str_1)
        list_0 = [str_2, str_0]
        str_4 = module_0.linkify(bytes_0, bool_0, str_1, list_0)
        dict_0 = {}
        any_0 = module_0.recursive_unicode(dict_0)
        str_5 = module_0.xhtml_unescape(str_3)
        any_1 = module_0.recursive_unicode(list_0)
        bool_1 = False
        var_2 = module_0.url_unescape(bytes_0, str_1, bool_1)
        any_2 = module_0.json_decode(str_4)
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = 'A command line parsing module that lets modules define their own options.\n\nThis module is inspired by Google\'s `gflags\n<https://github.com/google/python-gflags>`_. The primary difference\nwith libraries such as `argparse` is that a global registry is used so\nthat options may be defined in any module (it also enables\n`tornado.log` by default). The rest of Tornado does not depend on this\nmodule, so feel free to use `argparse` or other configuration\nlibraries if you prefer them.\n\nOptions must be defined with `tornado.options.define` before use,\ngenerally at the top level of a module. The options are then\naccessible as attributes of `tornado.options.options`::\n\n    # myapp/db.py\n    from tornado.options import define, options\n\n    define("mysql_host", default="127.0.0.1:3306", help="Main user DB")\n    define("memcache_hosts", default="127.0.0.1:11011", multiple=True,\n           help="Main user memcache servers")\n\n    def connect():\n        db = database.Connection(options.mysql_host)\n        ...\n\n    # myapp/server.py\n    from tornado.options import define, options\n\n    define("port", default=8080, help="port to listen on")\n\n    def start_server():\n        app = make_app()\n        app.listen(options.port)\n\nThe ``main()`` method of your application does not need to be aware of all of\nthe options used throughout your program; they are all automatically loaded\nwhen the modules are loaded.  However, all modules that define options\nmust have been imported before the command line is parsed.\n\nYour ``main()`` method can parse the command line or parse a config file with\neither `parse_command_line` or `parse_config_file`::\n\n    import myapp.db, myapp.server\n    import tornado.options\n\n    if __name__ == \'__main__\':\n        tornado.options.parse_command_line()\n        # or\n        tornado.options.parse_config_file("/etc/server.conf")\n\n.. note::\n\n   When using multiple ``parse_*`` functions, pass ``final=False`` to all\n   but the last one, or side effects may occur twice (in particular,\n   this can result in log messages being doubled).\n\n`tornado.options.options` is a singleton instance of `OptionParser`, and\nthe top-level functions in this module (`define`, `parse_command_line`, etc)\nsimply call methods on it.  You may create additional `OptionParser`\ninstances to define isolated sets of options, such as for subcommands.\n\n.. note::\n\n   By default, several options are defined that will configure the\n   standard `logging` module when `parse_command_line` or `parse_config_file`\n   are called.  If you want Tornado to leave the logging configuration\n   alone so you can manage it yourself, either pass ``--logging=none``\n   on the command line or do the following to disable it in code::\n\n       from tornado.options import options, parse_command_line\n       options.logging = None\n       parse_command_line()\n\n.. versionchanged:: 4.3\n   Dashes and underscores are fully interchangeable in option names;\n   options can be defined, set, and read with any mix of the two.\n   Dashes are typical for command-line usage while config files require\n   underscores.\n'
        any_0 = module_0.recursive_unicode(str_0)
        str_1 = '\n\tU'
        str_2 = '\x0ctq\x0b&6O==V'
        str_3 = '"V3$vI_%C\r05+7'
        list_0 = [str_2, str_1, str_2, str_1, str_2]
        str_4 = module_0.linkify(str_0, list_0)
        var_0 = module_0.url_unescape(str_1)
        str_5 = module_0.url_escape(str_2)
        any_1 = module_0.recursive_unicode(list_0)
        str_6 = module_0.json_encode(list_0)
        str_7 = module_0.json_encode(str_4)
        str_8 = module_0.xhtml_unescape(str_4)
        str_9 = module_0.json_encode(str_3)
        str_10 = module_0.xhtml_unescape(str_2)
        str_11 = module_0.json_encode(str_6)
        str_12 = module_0.xhtml_unescape(str_4)
        bool_0 = False
        dict_0 = module_0.parse_qs_bytes(str_5, bool_0)
        str_13 = None
        bool_1 = False
        var_1 = module_0.url_unescape(str_0, str_13, bool_1)
        bytes_0 = b'w\xb0Yy\\\xed\xdb\xaf\x06'
        bool_2 = False
        var_2 = module_0.url_unescape(bytes_0, bool_2)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = 'VI yS'
        set_0 = {str_0}
        optional_0 = module_0.to_unicode(set_0)
    except BaseException:
        pass

def test_case_16():
    try:
        tuple_0 = ()
        str_0 = module_0.json_encode(tuple_0)
        any_0 = module_0.recursive_unicode(tuple_0)
        str_1 = 'B'
        any_1 = module_0.recursive_unicode(str_1)
        str_2 = module_0.xhtml_unescape(str_1)
        bool_0 = False
        dict_0 = module_0.parse_qs_bytes(str_1, bool_0)
        str_3 = 'k7&4\x0c'
        str_4 = module_0.xhtml_escape(str_1)
        str_5 = module_0.linkify(str_3, bool_0)
        bool_1 = True
        str_6 = 'I$'
        optional_0 = module_0.utf8(str_4)
        str_7 = module_0.linkify(str_5, bool_1, str_6)
        str_8 = module_0.xhtml_unescape(str_7)
        str_9 = module_0.xhtml_escape(str_1)
        str_10 = module_0.linkify(str_3, bool_0)
        bytes_0 = b'\x8bg\x81\xa0(\xd5$\xee'
        str_11 = module_0.xhtml_escape(str_1)
        str_12 = module_0.xhtml_unescape(bytes_0)
    except BaseException:
        pass

def test_case_17():
    try:
        bytes_0 = b'3\x93\xbc\x18\x9f\xd7!3\xb9\x01\xabv\xb1\x8d1\x1b\xc9\xeb\xf2'
        int_0 = 30
        tuple_0 = (bytes_0, int_0)
        any_0 = module_0.recursive_unicode(tuple_0)
    except BaseException:
        pass