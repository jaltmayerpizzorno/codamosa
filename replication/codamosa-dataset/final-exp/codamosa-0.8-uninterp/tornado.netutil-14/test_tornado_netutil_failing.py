# Automatically generated by Pynguin.
import tornado.netutil as module_0
import ssl as module_1
import socket as module_2

def test_case_0():
    try:
        str_0 = "\trRwQc8(VI5{k1'GnCfw"
        int_0 = 3394
        socket_0 = module_0.bind_unix_socket(str_0)
        list_0 = module_0.bind_sockets(int_0, str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = '_*jGFI\nqb6a;A9v4a'
        socket_0 = module_0.bind_unix_socket(str_0)
        str_1 = '7'
        dict_0 = {str_1: str_0}
        s_s_l_context_0 = module_1.SSLContext(**dict_0)
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, s_s_l_context_0)
        callable_0 = module_0.add_accept_handler(socket_0, s_s_l_socket_0)
    except BaseException:
        pass

def test_case_2():
    try:
        blocking_resolver_0 = module_0.BlockingResolver()
    except BaseException:
        pass

def test_case_3():
    try:
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        str_0 = "t$`^y,'CA$0"
        int_0 = 949
        awaitable_0 = resolver_0.resolve(str_0, int_0)
        list_0 = []
        executor_resolver_0 = module_0.ExecutorResolver(*list_0)
    except BaseException:
        pass

def test_case_4():
    try:
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        override_resolver_0 = module_0.OverrideResolver()
    except BaseException:
        pass

def test_case_5():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_6():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = '\\(B\\'
        dict_0 = {str_0: str_0, str_0: str_0}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_8():
    try:
        int_0 = 8888
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_9():
    try:
        bool_0 = True
        socket_0 = module_2.socket(bool_0)
        s_s_l_context_0 = None
        str_0 = 'Tg\t<guED2Y\tI\\'
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, s_s_l_context_0, str_0)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = None
        socket_0 = module_0.bind_unix_socket(str_0)
    except BaseException:
        pass

def test_case_11():
    try:
        list_0 = []
        list_1 = [list_0, list_0]
        override_resolver_0 = module_0.OverrideResolver(*list_1)
        str_0 = 'Convert a Tornado yieldable object to an `asyncio.Future`.\n\n    .. versionadded:: 4.1\n\n    .. versionchanged:: 4.3\n       Now accepts any yieldable object, not just\n       `tornado.concurrent.Future`.\n\n    .. deprecated:: 5.0\n       Tornado ``Futures`` have been merged with `asyncio.Future`,\n       so this method is now equivalent to `tornado.gen.convert_yielded`.\n    '
        int_0 = 399
        awaitable_0 = override_resolver_0.resolve(str_0, int_0)
    except BaseException:
        pass

def test_case_12():
    try:
        int_0 = 8888
        default_executor_resolver_0 = module_0.DefaultExecutorResolver()
        address_family_0 = module_2.AddressFamily.AF_UNIX
        bool_0 = True
        list_0 = module_0.bind_sockets(int_0, default_executor_resolver_0, address_family_0, int_0, int_0, bool_0)
    except BaseException:
        pass

def test_case_13():
    try:
        str_0 = '#_uyA5+or(NlTU)#oDR`'
        resolver_0 = module_0.Resolver()
        bool_0 = module_0.is_valid_ip(str_0)
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        str_1 = '1'
        int_0 = 0
        int_1 = None
        list_0 = module_0.bind_sockets(int_0, int_1)
        bool_1 = False
        list_1 = module_0.bind_sockets(int_0, str_1, bool_1)
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = '#_uyA5+or(NlTU)#oDR`'
        int_0 = 3
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        awaitable_0 = resolver_0.resolve(str_0, int_0)
        bool_0 = module_0.is_valid_ip(str_0)
        list_0 = [bool_0, awaitable_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        override_resolver_0.close()
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = '+N0)R~tN'
        resolver_0 = module_0.Resolver()
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        s_s_l_context_1 = module_0.ssl_options_to_context(s_s_l_context_0)
        socket_0 = module_0.bind_unix_socket(str_0)
        resolver_0.close()
        str_1 = 'Default method used to render the final embedded css for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        '
        bool_0 = module_0.is_valid_ip(str_1)
    except BaseException:
        pass

def test_case_16():
    try:
        str_0 = '+N0)R~tN'
        str_1 = '#_uyA5+or(NlTU)#oDR`'
        int_0 = 9
        resolver_0 = module_0.Resolver()
        awaitable_0 = resolver_0.resolve(str_1, int_0)
        bool_0 = module_0.is_valid_ip(str_0)
        dict_0 = {}
        socket_0 = module_0.bind_unix_socket(str_1)
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_0, str_1)
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        s_s_l_context_1 = module_0.ssl_options_to_context(s_s_l_context_0)
        str_2 = '.'
        socket_1 = module_0.bind_unix_socket(str_2)
    except BaseException:
        pass

def test_case_17():
    try:
        var_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(var_0)
        str_0 = 'certfile'
        str_1 = 'cert'
        str_2 = {str_0: str_1}
        s_s_l_context_1 = module_0.ssl_options_to_context(str_2)
    except BaseException:
        pass