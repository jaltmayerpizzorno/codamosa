# Automatically generated by Pynguin.
import ansible.module_utils.connection as module_0
import socket as module_1

def test_case_0():
    try:
        list_0 = []
        float_0 = 1483.70261
        var_0 = module_0.write_to_file_descriptor(list_0, float_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = 'exec_wrapper'
        bool_0 = False
        set_0 = set()
        var_0 = module_0.write_to_file_descriptor(bool_0, set_0)
        socket_0 = module_1.socket()
        int_0 = -1256
        str_1 = ''
        bytes_0 = None
        tuple_0 = (int_0, str_1, bytes_0)
        str_2 = '||e7'
        dict_0 = {str_2: str_0, str_0: str_0}
        var_1 = module_0.send_data(tuple_0, dict_0)
    except BaseException:
        pass

def test_case_2():
    try:
        socket_0 = module_1.socket()
        var_0 = module_0.recv_data(socket_0)
    except BaseException:
        pass

def test_case_3():
    try:
        str_0 = 'S=@26me'
        var_0 = module_0.exec_command(str_0, str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = '\n    nit test for ethod __rp__ of class Connection\n    '
        connection_0 = module_0.Connection(str_0)
        var_0 = connection_0.__rpc__(str_0)
    except BaseException:
        pass

def test_case_5():
    try:
        int_0 = 23
        str_0 = '^;sNfE/}oW\rIF'
        dict_0 = {str_0: int_0}
        connection_error_0 = module_0.ConnectionError(int_0, **dict_0)
    except BaseException:
        pass

def test_case_6():
    try:
        dict_0 = None
        connection_0 = module_0.Connection(dict_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = 'Loading collection {0} from {1}'
        connection_0 = module_0.Connection(str_0)
        var_0 = module_0.recv_data(connection_0)
    except BaseException:
        pass

def test_case_8():
    try:
        bool_0 = True
        connection_0 = module_0.Connection(bool_0)
        var_0 = connection_0.__rpc__(connection_0)
    except BaseException:
        pass

def test_case_9():
    try:
        str_0 = 'og&{4\r/R3[7nZh\\+ZOQ\n'
        bool_0 = True
        connection_0 = module_0.Connection(bool_0)
        var_0 = connection_0.__rpc__(str_0)
    except BaseException:
        pass

def test_case_10():
    try:
        float_0 = 512.0
        list_0 = [float_0]
        bytes_0 = b'\x16)\xca'
        connection_0 = module_0.Connection(bytes_0)
        dict_0 = {}
        list_1 = [list_0, dict_0, list_0]
        int_0 = -373
        tuple_0 = (dict_0, connection_0, list_1, int_0)
        var_0 = connection_0.send(tuple_0)
    except BaseException:
        pass

def test_case_11():
    try:
        bytes_0 = b'\xe4\xca<\x03\x84\xd0'
        str_0 = "\n        Takes a single pattern and returns a list of matching host names.\n        Ignores intersection (&) and exclusion (!) specifiers.\n\n        The pattern may be:\n\n            1. A regex starting with ~, e.g. '~[abc]*'\n            2. A shell glob pattern with ?/*/[chars]/[!chars], e.g. 'foo*'\n            3. An ordinary word that matches itself only, e.g. 'foo'\n\n        The pattern is matched using the following rules:\n\n            1. If it's 'all', it matches all hosts in all groups.\n            2. Otherwise, for each known group name:\n                (a) if it matches the group name, the results include all hosts\n                    in the group or any of its children.\n                (b) otherwise, if it matches any hosts in the group, the results\n                    include the matching hosts.\n\n        This means that 'foo*' may match one or more groups (thus including all\n        hosts therein) but also hosts in other groups.\n\n        The built-in groups 'all' and 'ungrouped' are special. No pattern can\n        match these group names (though 'all' behaves as though it matches, as\n        described above). The word 'ungrouped' can match a host of that name,\n        and patterns like 'ungr*' and 'al*' can match either hosts or groups\n        other than all and ungrouped.\n\n        If the pattern matches one or more group names according to these rules,\n        it may have an optional range suffix to select a subset of the results.\n        This is allowed only if the pattern is not a regex, i.e. '~foo[1]' does\n        not work (the [1] is interpreted as part of the regex), but 'foo*[1]'\n        would work if 'foo*' matched the name of one or more groups.\n\n        Duplicate matches are always eliminated from the results.\n        "
        dict_0 = {bytes_0: bytes_0, bytes_0: bytes_0, bytes_0: bytes_0, str_0: bytes_0}
        float_0 = -594.5
        connection_0 = module_0.Connection(float_0)
        var_0 = connection_0.__getattr__(dict_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = '\n    Unit test for method __rpc__ of class Connection\n    '
        connection_0 = module_0.Connection(str_0)
        bool_0 = True
        connection_error_0 = None
        var_0 = module_0.write_to_file_descriptor(bool_0, connection_error_0)
        var_1 = module_0.recv_data(connection_0)
    except BaseException:
        pass