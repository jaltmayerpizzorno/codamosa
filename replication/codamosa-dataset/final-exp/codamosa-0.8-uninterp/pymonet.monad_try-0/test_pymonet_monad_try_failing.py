# Automatically generated by Pynguin.
import pymonet.monad_try as module_0

def test_case_0():
    try:
        float_0 = -5401.3
        str_0 = 'wsIEAXp7keY\x0cS\x0b'
        list_0 = [str_0]
        tuple_0 = (list_0,)
        list_1 = [tuple_0]
        bool_0 = True
        try_0 = module_0.Try(list_1, bool_0)
        var_0 = try_0.map(float_0)
    except BaseException:
        pass

def test_case_1():
    try:
        int_0 = -1345
        bool_0 = True
        try_0 = module_0.Try(int_0, bool_0)
        float_0 = 4354.0
        var_0 = try_0.on_fail(float_0)
        bytes_0 = b'\x1b"J3C\x18\x00'
        bool_1 = True
        try_1 = module_0.Try(bytes_0, bool_1)
        var_1 = try_1.bind(try_0)
    except BaseException:
        pass

def test_case_2():
    try:
        set_0 = None
        str_0 = '\n        Applies the function inside the Lazy[A] structure to another applicative type for notempty Lazy.\n        For empty returns copy of itself\n\n        :param applicative: applicative contains function\n        :type applicative: Lazy[Function(A) -> B]\n        :returns: new Lazy with result of contains function\n        :rtype: Lazy[B]\n        '
        bool_0 = True
        try_0 = module_0.Try(str_0, bool_0)
        var_0 = try_0.on_success(set_0)
    except BaseException:
        pass

def test_case_3():
    try:
        bytes_0 = b'F\x16\x89\x06\xcc\x06|\xc8\xe1\x8b'
        bool_0 = False
        try_0 = module_0.Try(bytes_0, bool_0)
        str_0 = '\n        Two Validations are equals when values and errors lists are equal.\n        '
        var_0 = try_0.on_fail(str_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = None
        tuple_0 = ()
        bool_0 = True
        try_0 = module_0.Try(tuple_0, bool_0)
        var_0 = try_0.filter(str_0)
    except BaseException:
        pass

def test_case_5():
    try:
        bool_0 = None
        list_0 = [bool_0]
        try_0 = module_0.Try(list_0, bool_0)
        str_0 = '\n        Transform Lazy into Try with constructor_fn result.\n        Try will be successful only when constructor_fn not raise anything.\n\n        :returns: Try with constructor_fn result\n        :rtype: Try[A] | Try[Error]\n        '
        bool_1 = True
        try_1 = module_0.Try(str_0, bool_1)
        var_0 = try_1.get_or_else(try_0)
        str_1 = 'rIS\r_~(ai8b'
        int_0 = -3347
        bool_2 = True
        try_2 = module_0.Try(int_0, bool_2)
        var_1 = try_2.on_fail(str_1)
        dict_0 = {bool_2: int_0}
        var_2 = try_2.filter(dict_0)
    except BaseException:
        pass

def test_case_6():
    try:
        float_0 = 126.3336
        str_0 = 'q+'
        bool_0 = False
        try_0 = module_0.Try(str_0, bool_0)
        var_0 = try_0.filter(float_0)
        dict_0 = {}
        bool_1 = try_0.__eq__(dict_0)
        var_1 = try_0.get()
        bytes_0 = b'B'
        int_0 = True
        bool_2 = try_0.__eq__(try_0)
        bool_3 = True
        tuple_0 = ()
        var_2 = try_0.on_success(float_0)
        set_0 = set()
        var_3 = try_0.map(set_0)
        list_0 = []
        var_4 = try_0.on_success(list_0)
        bool_4 = try_0.__eq__(tuple_0)
        int_1 = 913
        var_5 = try_0.filter(int_1)
        var_6 = try_0.get_or_else(list_0)
        try_1 = module_0.Try(int_0, bool_3)
        bool_5 = None
        try_2 = module_0.Try(str_0, bool_5)
        var_7 = try_1.get()
        var_8 = try_1.bind(bytes_0)
    except BaseException:
        pass