

---- 2024-06-01 15:19:53.905911
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Constant of class Resolver\ndef test_Resolver_visit_Constant():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:19:59.714809
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method load_docstring of class Parser\ndef test_Parser_load_docstring():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:03.156367
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method is_public of class Parser\ndef test_Parser_is_public():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:09.331051
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Constant of class Resolver\ndef test_Resolver_visit_Constant():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:11.793577
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Attribute of class Resolver\ndef test_Resolver_visit_Attribute():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:14.853270
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method class_api of class Parser\ndef test_Parser_class_api():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:19.093070
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method func_api of class Parser\ndef test_Parser_func_api():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:21.703895
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Subscript of class Resolver\ndef test_Resolver_visit_Subscript():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:24.864091
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Constant of class Resolver\ndef test_Resolver_visit_Constant():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:20:28.105770
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n# Unit test for function doctest\ndef test_doctest():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:21:57.298714
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n# Unit test for function walk_body\ndef test_walk_body():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:00.514226
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Name of class Resolver\ndef test_Resolver_visit_Name():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:04.659404
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method compile of class Parser\ndef test_Parser_compile():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:07.905208
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Subscript of class Resolver\ndef test_Resolver_visit_Subscript():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:10.798275
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n# Unit test for function const_type\ndef test_const_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:14.764026
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method func_ann of class Parser\ndef test_Parser_func_ann():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:17.961658
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method func_api of class Parser\ndef test_Parser_func_api():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:21.633693
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n# Unit test for function walk_body\ndef test_walk_body():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:24.962119
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method func_api of class Parser\ndef test_Parser_func_api():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:22:28.107686
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n# Unit test for function table\ndef test_table():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:23:44.298407
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method func_api of class Parser\ndef test_Parser_func_api():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:23:47.714372
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Data structures.\"\"\"\n\n__author__ = \"Yuan Chang\"\n__copyright__ = \"Copyright (C) 2020-2021\"\n__license__ = \"MIT\"\n__email__ = \"pyslvs@gmail.com\"\n\nfrom typing import cast, TypeVar, Union, Optional\nfrom types import ModuleType\nfrom collections.abc import Sequence, Iterable, Iterator\nfrom itertools import chain\nfrom dataclasses import dataclass, field\nfrom inspect import getdoc\nfrom ast import (\n    parse, unparse, get_docstring, AST, FunctionDef, AsyncFunctionDef, ClassDef,\n    Assign, AnnAssign, Delete, Import, ImportFrom, Name, Expr, Subscript, BinOp,\n    BitOr, Call, If, Try, Tuple, List, Set, Dict, Constant, Load, Attribute,\n    arg, expr, stmt, arguments, NodeTransformer,\n)\nfrom .logger import logger\nfrom .pep585 import PEP585\n\n_I = Union[Import, ImportFrom]\n_G = Union[Assign, AnnAssign]\n_API = Union[FunctionDef, AsyncFunctionDef, ClassDef]\nANY = 'Any'\n\n\ndef _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)\n\n\ndef _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n\n\n\ndef _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)\n\n\ndef parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'\n\n\ndef is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True\n\n\ndef walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node\n\n\ndef code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"\n\n\ndef esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc\n\n\ndef doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)\n\n\ndef _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'\n\n\ndef _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'\n\n\ndef table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'\n\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY\n\n\nclass Resolver(NodeTransformer):\n    \"\"\"Annotation resolver.\"\"\"\n\n    def __init__(self, root: str, alias: dict[str, str], self_ty: str = \"\"):\n        \"\"\"Set root module, alias and generic self name.\"\"\"\n        super(Resolver, self).__init__()\n        self.root = root\n        self.alias = alias\n        self.self_ty = self_ty\n\n    def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)\n\n    def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node\n\n    def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node\n\n    def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node\n# Unit test for method visit_Attribute of class Resolver\ndef test_Resolver_visit_Attribute():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:23:50.131858
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method globals of class Parser\ndef test_Parser_globals():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:23:53.794576
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method class_api of class Parser\ndef test_Parser_class_api():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:23:57.099449
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method func_ann of class Parser\ndef test_Parser_func_ann():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:24:00.394406
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method load_docstring of class Parser\ndef test_Parser_load_docstring():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:24:03.102159
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method load_docstring of class Parser\ndef test_Parser_load_docstring():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:24:05.911196
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method compile of class Parser\ndef test_Parser_compile():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:24:09.090276
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method compile of class Parser\ndef test_Parser_compile():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 15:24:12.379516
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)\n\n    def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))\n\n    def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)\n\n    def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])\n\n    def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))\n\n    def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY\n\n    def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))\n\n    def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)\n\n    def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))\n\n    def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)\n\n    def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)\n\n    def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"\n\n    def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()\n\n    def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'\n# Unit test for method func_api of class Parser\ndef test_Parser_func_api():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}