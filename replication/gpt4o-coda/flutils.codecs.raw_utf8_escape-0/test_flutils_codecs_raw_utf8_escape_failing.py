# Automatically generated by Pynguin.
import flutils.codecs.raw_utf8_escape as module_0
import collections as module_1

def test_case_0():
    try:
        module_0.register()
        bytes_0 = b'S\x8c\x1e\x8a\x15'
        user_string_0 = module_1.UserString(bytes_0)
        tuple_0 = module_0.encode(user_string_0)
    except BaseException:
        pass

def test_case_1():
    try:
        bytes_0 = b'-:2\xe4J\x1e\x9f\x07\xa3^(\x88n.\xe4W'
        tuple_0 = module_0.decode(bytes_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = 'find_paths'
        tuple_0 = module_0.decode(str_0)
    except BaseException:
        pass

def test_case_3():
    try:
        module_0.register()
        str_0 = 'A4\x0c!dKis27,nx::PX#'
        tuple_0 = module_0.encode(str_0, str_0)
        module_0.register()
        int_0 = -337
        tuple_1 = module_0.decode(int_0)
    except BaseException:
        pass

def test_case_4():
    try:
        module_0.register()
        bytes_0 = b'S\x8c\x1e\x8a\x15'
        user_string_0 = module_1.UserString(bytes_0)
        str_0 = 'A'
        var_0 = user_string_0.encode(str_0)
    except BaseException:
        pass

def test_case_5():
    try:
        float_0 = None
        module_0.register()
        tuple_0 = None
        tuple_1 = None
        dict_0 = {float_0: float_0, float_0: tuple_0, float_0: float_0, tuple_1: tuple_0}
        tuple_2 = module_0.decode(dict_0)
    except BaseException:
        pass

def test_case_6():
    try:
        bytes_0 = b'3\xb0\xeeGS\xe4-H\xce71'
        user_string_0 = module_1.UserString(bytes_0)
        bytes_1 = b'\xe9\xe4o\t\xf0\xf9\xf2\x05k\x84\xfaj\x9c\xff'
        user_string_1 = module_1.UserString(bytes_1)
        tuple_0 = module_0.encode(user_string_0, user_string_1)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = 'i"GX]X|>6\rr\x0cw~[Ew'
        tuple_0 = module_0.encode(str_0)
        str_1 = 'z>'
        tuple_1 = module_0.encode(str_0)
        tuple_2 = module_0.encode(str_1)
        bytes_0 = b'\xee\x8e\xa4A\xc9\xc3\x039\xb6S\t-T2"\x97\x00\xf9\xff'
        tuple_3 = module_0.decode(bytes_0, str_1)
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = "A property decorator that is only computed once per instance and then\n    replaces itself with an ordinary attribute.\n\n    Deleting the attribute resets the property.\n\n    Note:\n        In Python 3.8 the :obj:`functools.cached_property` decorator was\n        added. It is recommended to use the built-in\n        :obj:`functools.cached_property`; provided you're using\n        Python >= 3.8.  :obj:`~flutils.decorators.cached_property` remains\n        for use with Python 3.6 and 3.7.\n\n    Example:\n\n        Code::\n\n            from flutils.decorators import cached_property\n\n            class MyClass:\n\n                def __init__(self):\n                    self.x = 5\n\n                @cached_property\n                def y(self):\n                    return self.x + 1\n\n        Usage:\n\n            >>> obj = MyClass()\n            >>> obj.y\n            6\n\n    *New in version 0.2.0*\n\n    This decorator is a derivative work of\n    `cached_property <https://bit.ly/2R9U3Qa>`__ and is:\n\n    `Copyright © 2015 Daniel Greenfeld; All Rights Reserved\n    <https://bit.ly/2CwtJM1>`__\n\n    Also this decorator is a derivative work of\n    `cached_property  <https://bit.ly/2JbYB5L>`__ and is:\n\n    `Copyright © 2011 Marcel Hellkamp <https://bit.ly/2ECEO0M>`__\n\n    "
        tuple_0 = module_0.encode(str_0)
        tuple_1 = module_0.encode(str_0)
        bytes_0 = b'O>\xb7\xaa\xff\xbb# \x8fZx=\t&\x05'
        tuple_2 = module_0.decode(bytes_0)
    except BaseException:
        pass