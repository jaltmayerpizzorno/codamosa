

---- 2024-05-31 16:33:36.103426
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getkeyid of class RpmKey\ndef test_RpmKey_getkeyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:33:40.011846
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for constructor of class RpmKey\ndef test_RpmKey():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:33:42.646370
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getfingerprint of class RpmKey\ndef test_RpmKey_getfingerprint():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:33:46.057038
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getfingerprint of class RpmKey\ndef test_RpmKey_getfingerprint():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:33:49.526898
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method fetch_key of class RpmKey\ndef test_RpmKey_fetch_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:33:52.813142
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getkeyid of class RpmKey\ndef test_RpmKey_getkeyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:33:55.913730
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for constructor of class RpmKey\ndef test_RpmKey():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:33:58.286594
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getkeyid of class RpmKey\ndef test_RpmKey_getkeyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:34:01.469678
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for constructor of class RpmKey\ndef test_RpmKey():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:34:05.406666
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for constructor of class RpmKey\ndef test_RpmKey():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:34:42.192681
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method is_keyid of class RpmKey\ndef test_RpmKey_is_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:34:47.045142
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method import_key of class RpmKey\ndef test_RpmKey_import_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:34:51.869508
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method normalize_keyid of class RpmKey\ndef test_RpmKey_normalize_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:34:55.104002
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method fetch_key of class RpmKey\ndef test_RpmKey_fetch_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:34:58.715848
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method fetch_key of class RpmKey\ndef test_RpmKey_fetch_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:35:02.916206
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method drop_key of class RpmKey\ndef test_RpmKey_drop_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:35:06.229934
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method is_keyid of class RpmKey\ndef test_RpmKey_is_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:35:09.569045
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getfingerprint of class RpmKey\ndef test_RpmKey_getfingerprint():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:35:15.687077
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method drop_key of class RpmKey\ndef test_RpmKey_drop_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:35:19.452607
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method is_keyid of class RpmKey\ndef test_RpmKey_is_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:28.093232
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method fetch_key of class RpmKey\ndef test_RpmKey_fetch_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:31.816250
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for constructor of class RpmKey\ndef test_RpmKey():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:36.166832
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method normalize_keyid of class RpmKey\ndef test_RpmKey_normalize_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:39.730140
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method execute_command of class RpmKey\ndef test_RpmKey_execute_command():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:42.302235
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method execute_command of class RpmKey\ndef test_RpmKey_execute_command():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:45.023241
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getfingerprint of class RpmKey\ndef test_RpmKey_getfingerprint():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:48.652205
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method fetch_key of class RpmKey\ndef test_RpmKey_fetch_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:52.522947
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method is_keyid of class RpmKey\ndef test_RpmKey_is_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:55.943649
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method drop_key of class RpmKey\ndef test_RpmKey_drop_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:36:59.776192
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method normalize_keyid of class RpmKey\ndef test_RpmKey_normalize_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:08.745537
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method is_keyid of class RpmKey\ndef test_RpmKey_is_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:12.705149
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method getfingerprint of class RpmKey\ndef test_RpmKey_getfingerprint():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:15.994495
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method drop_key of class RpmKey\ndef test_RpmKey_drop_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:19.709461
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method fetch_key of class RpmKey\ndef test_RpmKey_fetch_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:23.383840
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method fetch_key of class RpmKey\ndef test_RpmKey_fetch_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:29.800122
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method is_keyid of class RpmKey\ndef test_RpmKey_is_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:33.547653
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method drop_key of class RpmKey\ndef test_RpmKey_drop_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:37.705991
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method is_keyid of class RpmKey\ndef test_RpmKey_is_keyid():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:42.161655
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method drop_key of class RpmKey\ndef test_RpmKey_drop_key():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 16:39:46.296750
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Ansible module to import third party repo keys to your rpm db\n# Copyright: (c) 2013, H\u00e9ctor Acosta <hector.acosta@gazzang.com>\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nDOCUMENTATION = '''\n---\nmodule: rpm_key\nauthor:\n  - Hector Acosta (@hacosta) <hector.acosta@gazzang.com>\nshort_description: Adds or removes a gpg key from the rpm db\ndescription:\n  - Adds or removes (rpm --import) a gpg key to your rpm database.\nversion_added: \"1.3\"\noptions:\n    key:\n      description:\n        - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key\n          already exists in the database.\n      type: str\n      required: true\n    state:\n      description:\n        - If the key will be imported or removed from the rpm db.\n      type: str\n      default: present\n      choices: [ absent, present ]\n    validate_certs:\n      description:\n        - If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\n        - This should only be used on personally controlled sites using self-signed certificates.\n      type: bool\n      default: 'yes'\n    fingerprint:\n      description:\n        - The long-form fingerprint of the key being imported.\n        - This will be used to verify the specified key.\n      type: str\n      version_added: 2.9\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: none\n    platform:\n        platforms: rhel\n'''\n\nEXAMPLES = '''\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n'''\n\nRETURN = r'''#'''\n\nimport re\nimport os.path\nimport tempfile\n\n# import module snippets\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_native\n\n\ndef is_pubkey(string):\n    \"\"\"Verifies if string is a pubkey\"\"\"\n    pgp_regex = \".*?(-----BEGIN PGP PUBLIC KEY BLOCK-----.*?-----END PGP PUBLIC KEY BLOCK-----).*\"\n    return bool(re.match(pgp_regex, to_native(string, errors='surrogate_or_strict'), re.DOTALL))\n\n\nclass RpmKey(object):\n\n    def __init__(self, module):\n        # If the key is a url, we need to check if it's present to be idempotent,\n        # to do that, we need to check the keyid, which we can get from the armor.\n        keyfile = None\n        should_cleanup_keyfile = False\n        self.module = module\n        self.rpm = self.module.get_bin_path('rpm', True)\n        state = module.params['state']\n        key = module.params['key']\n        fingerprint = module.params['fingerprint']\n        if fingerprint:\n            fingerprint = fingerprint.replace(' ', '').upper()\n\n        self.gpg = self.module.get_bin_path('gpg')\n        if not self.gpg:\n            self.gpg = self.module.get_bin_path('gpg2', required=True)\n\n        if '://' in key:\n            keyfile = self.fetch_key(key)\n            keyid = self.getkeyid(keyfile)\n            should_cleanup_keyfile = True\n        elif self.is_keyid(key):\n            keyid = key\n        elif os.path.isfile(key):\n            keyfile = key\n            keyid = self.getkeyid(keyfile)\n        else:\n            self.module.fail_json(msg=\"Not a valid key %s\" % key)\n        keyid = self.normalize_keyid(keyid)\n\n        if state == 'present':\n            if self.is_key_imported(keyid):\n                module.exit_json(changed=False)\n            else:\n                if not keyfile:\n                    self.module.fail_json(msg=\"When importing a key, a valid file must be given\")\n                if fingerprint:\n                    has_fingerprint = self.getfingerprint(keyfile)\n                    if fingerprint != has_fingerprint:\n                        self.module.fail_json(\n                            msg=\"The specified fingerprint, '%s', does not match the key fingerprint '%s'\" % (fingerprint, has_fingerprint)\n                        )\n                self.import_key(keyfile)\n                if should_cleanup_keyfile:\n                    self.module.cleanup(keyfile)\n                module.exit_json(changed=True)\n        else:\n            if self.is_key_imported(keyid):\n                self.drop_key(keyid)\n                module.exit_json(changed=True)\n            else:\n                module.exit_json(changed=False)\n\n    def fetch_key(self, url):\n        \"\"\"Downloads a key from url, returns a valid path to a gpg key\"\"\"\n        rsp, info = fetch_url(self.module, url)\n        if info['status'] != 200:\n            self.module.fail_json(msg=\"failed to fetch key at %s , error was: %s\" % (url, info['msg']))\n\n        key = rsp.read()\n        if not is_pubkey(key):\n            self.module.fail_json(msg=\"Not a public key: %s\" % url)\n        tmpfd, tmpname = tempfile.mkstemp()\n        self.module.add_cleanup_file(tmpname)\n        tmpfile = os.fdopen(tmpfd, \"w+b\")\n        tmpfile.write(key)\n        tmpfile.close()\n        return tmpname\n\n    def normalize_keyid(self, keyid):\n        \"\"\"Ensure a keyid doesn't have a leading 0x, has leading or trailing whitespace, and make sure is uppercase\"\"\"\n        ret = keyid.strip().upper()\n        if ret.startswith('0x'):\n            return ret[2:]\n        elif ret.startswith('0X'):\n            return ret[2:]\n        else:\n            return ret\n\n    def getkeyid(self, keyfile):\n        stdout, stderr = self.execute_command([self.gpg, '--no-tty', '--batch', '--with-colons', '--fixed-list-mode', keyfile])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('pub:'):\n                return line.split(':')[4]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def getfingerprint(self, keyfile):\n        stdout, stderr = self.execute_command([\n            self.gpg, '--no-tty', '--batch', '--with-colons',\n            '--fixed-list-mode', '--with-fingerprint', keyfile\n        ])\n        for line in stdout.splitlines():\n            line = line.strip()\n            if line.startswith('fpr:'):\n                # As mentioned here,\n                #\n                # https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS\n                #\n                # The description of the `fpr` field says\n                #\n                # \"fpr :: Fingerprint (fingerprint is in field 10)\"\n                #\n                return line.split(':')[9]\n\n        self.module.fail_json(msg=\"Unexpected gpg output\")\n\n    def is_keyid(self, keystr):\n        \"\"\"Verifies if a key, as provided by the user is a keyid\"\"\"\n        return re.match('(0x)?[0-9a-f]{8}', keystr, flags=re.IGNORECASE)\n\n    def execute_command(self, cmd):\n        rc, stdout, stderr = self.module.run_command(cmd, use_unsafe_shell=True)\n        if rc != 0:\n            self.module.fail_json(msg=stderr)\n        return stdout, stderr\n\n    def is_key_imported(self, keyid):\n        cmd = self.rpm + ' -q  gpg-pubkey'\n        rc, stdout, stderr = self.module.run_command(cmd)\n        if rc != 0:  # No key is installed on system\n            return False\n        cmd += ' --qf \"%{description}\" | ' + self.gpg + ' --no-tty --batch --with-colons --fixed-list-mode -'\n        stdout, stderr = self.execute_command(cmd)\n        for line in stdout.splitlines():\n            if keyid in line.split(':')[4]:\n                return True\n        return False\n\n    def import_key(self, keyfile):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--import', keyfile])\n\n    def drop_key(self, keyid):\n        if not self.module.check_mode:\n            self.execute_command([self.rpm, '--erase', '--allmatches', \"gpg-pubkey-%s\" % keyid[-8:].lower()])\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            key=dict(type='str', required=True, no_log=False),\n            fingerprint=dict(type='str'),\n            validate_certs=dict(type='bool', default=True),\n        ),\n        supports_check_mode=True,\n    )\n\n    RpmKey(module)\n\n\nif __name__ == '__main__':\n    main()\n\n# Unit test for method execute_command of class RpmKey\ndef test_RpmKey_execute_command():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}