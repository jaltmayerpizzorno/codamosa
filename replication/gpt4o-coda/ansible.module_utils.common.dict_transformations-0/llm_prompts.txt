

---- 2024-05-30 23:50:39.372919
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:50:43.355784
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:50:46.788738
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:50:50.487483
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:50:54.246750
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:50:57.898410
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:02.443846
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:06.006929
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:10.299376
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:13.787229
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:23.186743
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:26.328172
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:30.827276
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:34.713422
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:38.182132
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:41.609210
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:44.863117
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:50.562276
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:55.323227
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:51:58.881627
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:08.980511
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:12.505770
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:15.586807
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:18.718771
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:21.892337
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:25.672113
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:29.209548
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:32.356819
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:36.021292
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:52:42.155346
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:02.114208
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:05.742429
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:10.584926
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:14.513775
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:19.004040
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:22.615481
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:26.765571
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:30.111011
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:35.259112
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:53:38.684977
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:02.957725
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:07.692090
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:11.040478
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:16.766696
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:20.179641
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:23.560024
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:30.298357
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:34.046270
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:37.169820
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:54:40.003402
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:12.893989
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:16.899751
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:19.892485
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:24.634646
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:27.594809
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:31.226096
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:34.488218
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:39.098871
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:42.471115
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:55:46.015393
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:19.015206
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:22.039769
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:28.489621
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:31.508895
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:34.128224
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:38.031090
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:41.994865
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:44.942316
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:48.809358
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:56:54.806589
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:10.136599
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:13.521351
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:17.010041
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:20.917713
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:26.129383
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:30.012511
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:33.779841
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function dict_merge\ndef test_dict_merge():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:38.520634
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function camel_dict_to_snake_dict\ndef test_camel_dict_to_snake_dict():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:42.236537
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-30 23:58:45.400032
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2018, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nimport re\nfrom copy import deepcopy\n\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n\n\ndef camel_dict_to_snake_dict(camel_dict, reversible=False, ignore_list=()):\n    \"\"\"\n    reversible allows two way conversion of a camelized dict\n    such that snake_dict_to_camel_dict(camel_dict_to_snake_dict(x)) == x\n\n    This is achieved through mapping e.g. HTTPEndpoint to h_t_t_p_endpoint\n    where the default would be simply http_endpoint, which gets turned into\n    HttpEndpoint if recamelized.\n\n    ignore_list is used to avoid converting a sub-tree of a dict. This is\n    particularly important for tags, where keys are case-sensitive. We convert\n    the 'Tags' key but nothing below.\n    \"\"\"\n\n    def value_is_list(camel_list):\n\n        checked_list = []\n        for item in camel_list:\n            if isinstance(item, dict):\n                checked_list.append(camel_dict_to_snake_dict(item, reversible))\n            elif isinstance(item, list):\n                checked_list.append(value_is_list(item))\n            else:\n                checked_list.append(item)\n\n        return checked_list\n\n    snake_dict = {}\n    for k, v in camel_dict.items():\n        if isinstance(v, dict) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = camel_dict_to_snake_dict(v, reversible)\n        elif isinstance(v, list) and k not in ignore_list:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = value_is_list(v)\n        else:\n            snake_dict[_camel_to_snake(k, reversible=reversible)] = v\n\n    return snake_dict\n\n\ndef snake_dict_to_camel_dict(snake_dict, capitalize_first=False):\n    \"\"\"\n    Perhaps unexpectedly, snake_dict_to_camel_dict returns dromedaryCase\n    rather than true CamelCase. Passing capitalize_first=True returns\n    CamelCase. The default remains False as that was the original implementation\n    \"\"\"\n\n    def camelize(complex_type, capitalize_first=False):\n        if complex_type is None:\n            return\n        new_type = type(complex_type)()\n        if isinstance(complex_type, dict):\n            for key in complex_type:\n                new_type[_snake_to_camel(key, capitalize_first)] = camelize(complex_type[key], capitalize_first)\n        elif isinstance(complex_type, list):\n            for i in range(len(complex_type)):\n                new_type.append(camelize(complex_type[i], capitalize_first))\n        else:\n            return complex_type\n        return new_type\n\n    return camelize(snake_dict, capitalize_first)\n\n\ndef _snake_to_camel(snake, capitalize_first=False):\n    if capitalize_first:\n        return ''.join(x.capitalize() or '_' for x in snake.split('_'))\n    else:\n        return snake.split('_')[0] + ''.join(x.capitalize() or '_' for x in snake.split('_')[1:])\n\n\ndef _camel_to_snake(name, reversible=False):\n\n    def prepend_underscore_and_lower(m):\n        return '_' + m.group(0).lower()\n\n    if reversible:\n        upper_pattern = r'[A-Z]'\n    else:\n        # Cope with pluralized abbreviations such as TargetGroupARNs\n        # that would otherwise be rendered target_group_ar_ns\n        upper_pattern = r'[A-Z]{3,}s$'\n\n    s1 = re.sub(upper_pattern, prepend_underscore_and_lower, name)\n    # Handle when there was nothing before the plural_pattern\n    if s1.startswith(\"_\") and not name.startswith(\"_\"):\n        s1 = s1[1:]\n    if reversible:\n        return s1\n\n    # Remainder of solution seems to be https://stackoverflow.com/a/1176023\n    first_cap_pattern = r'(.)([A-Z][a-z]+)'\n    all_cap_pattern = r'([a-z0-9])([A-Z]+)'\n    s2 = re.sub(first_cap_pattern, r'\\1_\\2', s1)\n    return re.sub(all_cap_pattern, r'\\1_\\2', s2).lower()\n\n\ndef dict_merge(a, b):\n    '''recursively merges dicts. not just simple a['key'] = b['key'], if\n    both a and b have a key whose value is a dict then dict_merge is called\n    on both values and the result stored in the returned dictionary.'''\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.items():\n        if k in result and isinstance(result[k], dict):\n            result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result\n\n\ndef recursive_diff(dict1, dict2):\n    \"\"\"Recursively diff two dictionaries\n\n    Raises ``TypeError`` for incorrect argument type.\n\n    :arg dict1: Dictionary to compare against.\n    :arg dict2: Dictionary to compare with ``dict1``.\n    :return: Tuple of dictionaries of differences or ``None`` if there are no differences.\n    \"\"\"\n\n    if not all((isinstance(item, MutableMapping) for item in (dict1, dict2))):\n        raise TypeError(\"Unable to diff 'dict1' %s and 'dict2' %s. \"\n                        \"Both must be a dictionary.\" % (type(dict1), type(dict2)))\n\n    left = dict((k, v) for (k, v) in dict1.items() if k not in dict2)\n    right = dict((k, v) for (k, v) in dict2.items() if k not in dict1)\n    for k in (set(dict1.keys()) & set(dict2.keys())):\n        if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):\n            result = recursive_diff(dict1[k], dict2[k])\n            if result:\n                left[k] = result[0]\n                right[k] = result[1]\n        elif dict1[k] != dict2[k]:\n            left[k] = dict1[k]\n            right[k] = dict2[k]\n    if left or right:\n        return left, right\n    return None\n\n# Unit test for function recursive_diff\ndef test_recursive_diff():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}