

---- 2024-06-01 19:41:38.590271
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:41:42.364398
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:41:45.325864
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:41:48.761681
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:41:52.861202
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:41:56.065210
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:41:59.281732
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:01.911189
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:04.726038
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:08.006002
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:21.234361
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:24.508622
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:27.457224
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:30.487003
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:34.395167
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:37.162359
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:40.244707
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:43.111661
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:46.088606
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:42:48.855154
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:13.155116
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:16.172701
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:18.942272
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:22.583368
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:25.224248
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:28.339051
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:31.984791
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:35.029131
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:37.928796
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:43:40.546469
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:44:46.991294
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:44:49.557909
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:00.762190
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:04.072752
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:07.745844
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:12.548237
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:15.337264
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:18.479375
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:27.866814
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:45:30.799835
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:18.347289
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:22.194043
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:25.500577
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:28.935674
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:39.099352
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:42.550802
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:45.883427
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:48.844891
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:51.818617
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:47:54.679599
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:50:44.849631
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:50:48.314558
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:50:51.345131
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:50:55.520330
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:50:58.408622
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:51:01.653300
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:51:05.858228
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:51:10.552382
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:51:13.074305
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-01 19:51:16.009713
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n# noinspection PyUnusedFunction,Mypy\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n# noinspection PyUnusedFunction,PyProtectedMember,Mypy\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n# Unit test for function to_namedtuple\ndef test_to_namedtuple():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}