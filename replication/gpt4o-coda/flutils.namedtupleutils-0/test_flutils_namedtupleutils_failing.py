# Automatically generated by Pynguin.
import flutils.namedtupleutils as module_0
import types as module_1
import collections.abc as module_2

def test_case_0():
    try:
        simple_namespace_0 = None
        var_0 = module_0.to_namedtuple(simple_namespace_0)
    except BaseException:
        pass

def test_case_1():
    try:
        bytes_0 = b'\xae\xf0'
        var_0 = module_0.to_namedtuple(bytes_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = 'Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The "login name" used to\n            set the owner of the given ``path``.  A value of ``\'-1\'`` will\n            leave the owner unchanged.  Defaults to the "login name" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``\'-1\'`` will leave\n            the group unchanged.  Defaults to the current user\'s group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present(\'~/tmp/test_path\')\n        PosixPath(\'/Users/len/tmp/test_path\')\n\n    '
        str_1 = 'Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    '
        dict_0 = {str_0: str_0, str_1: str_1}
        simple_namespace_0 = module_1.SimpleNamespace()
        var_0 = module_0.to_namedtuple(simple_namespace_0)
        var_1 = module_0.to_namedtuple(dict_0)
        tuple_0 = ()
        var_2 = module_0.to_namedtuple(tuple_0)
        var_3 = module_0.to_namedtuple(tuple_0)
        var_4 = module_0.to_namedtuple(simple_namespace_0)
        var_5 = module_0.to_namedtuple(simple_namespace_0)
        var_6 = module_0.to_namedtuple(simple_namespace_0)
        var_7 = module_0.to_namedtuple(simple_namespace_0)
        str_2 = ' iC'
        dict_1 = {str_1: var_6}
        dict_2 = {str_2: dict_1}
        simple_namespace_1 = module_1.SimpleNamespace(**dict_2)
        var_8 = module_0.to_namedtuple(simple_namespace_1)
        var_9 = module_0.to_namedtuple(simple_namespace_1)
        var_10 = module_0.to_namedtuple(simple_namespace_0)
        mapping_0 = module_2.Mapping()
    except BaseException:
        pass

def test_case_3():
    try:
        bytes_0 = b'\t]\xf4\x06\xca\xba'
        dict_0 = {bytes_0: bytes_0, bytes_0: bytes_0, bytes_0: bytes_0, bytes_0: bytes_0}
        var_0 = module_0.to_namedtuple(dict_0)
    except BaseException:
        pass