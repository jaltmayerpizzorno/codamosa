

---- 2024-06-04 20:07:15.732726
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:18.460909
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:21.865576
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:23.783260
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:25.806058
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Reference\ndef test_Reference():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:31.911625
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:36.130907
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Reference\ndef test_Reference():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:40.274891
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Reference\ndef test_Reference():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:44.053289
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:07:48.046904
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __setitem__ of class SchemaDefinitions\ndef test_SchemaDefinitions___setitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:03.445793
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:05.562437
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:09.231743
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:11.921126
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:14.370616
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:16.897598
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:19.385885
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:22.717259
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:24.449815
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:26.110712
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:41.019155
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:44.236524
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:45.958520
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:48.439550
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:50.468818
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Reference\ndef test_Reference():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:54.013484
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:08:55.994204
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:00.642561
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:02.989690
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __setitem__ of class SchemaDefinitions\ndef test_SchemaDefinitions___setitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:04.969690
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:38.435527
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method validate of class Reference\ndef test_Reference_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:42.368538
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:44.246983
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:46.078782
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:49.135775
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:51.306123
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:55.015190
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:09:59.710948
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:01.706936
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:05.834382
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __repr__ of class Schema\ndef test_Schema___repr__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:28.105804
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __getitem__ of class Schema\ndef test_Schema___getitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:31.434943
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:34.259670
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:36.542406
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:40.026158
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __getitem__ of class Schema\ndef test_Schema___getitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:42.928887
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:48.989482
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:51.251703
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method validate of class Reference\ndef test_Reference_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:55.520779
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:10:59.127585
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:11:42.692458
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:11:45.581417
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __getitem__ of class Schema\ndef test_Schema___getitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:11:49.003543
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Reference\ndef test_Reference():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:11:52.230916
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:11:54.306891
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:11:57.584638
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:11:59.477420
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:12:02.891636
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:12:04.861922
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:12:08.933373
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:10.491097
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:15.296793
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:20.137806
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:22.428706
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:24.524070
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:26.668574
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for constructor of class Schema\ndef test_Schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:31.399958
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:34.500256
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:38.048341
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:13:41.690914
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:23.732550
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:28.011850
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __repr__ of class Schema\ndef test_Schema___repr__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:29.939082
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:32.672646
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:37.394910
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:39.619245
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:41.417819
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:43.608490
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:46.775135
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __getitem__ of class Schema\ndef test_Schema___getitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:14:50.051303
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __repr__ of class Schema\ndef test_Schema___repr__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:30.592523
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:33.960323
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __new__ of class SchemaMetaclass\ndef test_SchemaMetaclass___new__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:37.714389
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __eq__ of class Schema\ndef test_Schema___eq__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:40.811536
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:45.666976
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __len__ of class Schema\ndef test_Schema___len__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:48.745447
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:51.017256
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:54.386200
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __getitem__ of class Schema\ndef test_Schema___getitem__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:57.197897
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for method __iter__ of class Schema\ndef test_Schema___iter__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:15:59.682808
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nimport typing\nfrom abc import ABCMeta\nfrom collections.abc import Mapping, MutableMapping\n\nfrom typesystem.base import ValidationError, ValidationResult\nfrom typesystem.fields import Array, Field, Object\n\n\nclass SchemaDefinitions(MutableMapping):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        self._definitions = dict(*args, **kwargs)  # type: dict\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        return self._definitions[key]\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self._definitions)\n\n    def __len__(self) -> int:\n        return len(self._definitions)\n\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        assert (\n            key not in self._definitions\n        ), r\"Definition for {key!r} has already been set.\"\n        self._definitions[key] = value\n\n    def __delitem__(self, key: typing.Any) -> None:\n        del self._definitions[key]\n\n\ndef set_definitions(field: Field, definitions: SchemaDefinitions) -> None:\n    \"\"\"\n    Recursively set the definitions that string-referenced `Reference` fields\n    should use.\n    \"\"\"\n    if isinstance(field, Reference) and field.definitions is None:\n        field.definitions = definitions\n    elif isinstance(field, Array):\n        if field.items is not None:\n            if isinstance(field.items, (tuple, list)):\n                for child in field.items:\n                    set_definitions(child, definitions)\n            else:\n                set_definitions(field.items, definitions)\n    elif isinstance(field, Object):\n        for child in field.properties.values():\n            set_definitions(child, definitions)\n\n\nclass SchemaMetaclass(ABCMeta):\n    def __new__(\n        cls: type,\n        name: str,\n        bases: typing.Sequence[type],\n        attrs: dict,\n        definitions: SchemaDefinitions = None,\n    ) -> type:\n        fields: typing.Dict[str, Field] = {}\n\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                attrs.pop(key)\n                fields[key] = value\n\n        # If this class is subclassing other Schema classes, add their fields.\n        for base in reversed(bases):\n            base_fields = getattr(base, \"fields\", {})\n            for key, value in base_fields.items():\n                if isinstance(value, Field) and key not in fields:\n                    fields[key] = value\n\n        # Add the definitions to any `Reference` fields that we're including.\n        if definitions is not None:\n            for field in fields.values():\n                set_definitions(field, definitions)\n\n        # \u00a0Sort fields by their actual position in the source code,\n        # using `Field._creation_counter`\n        attrs[\"fields\"] = dict(\n            sorted(fields.items(), key=lambda item: item[1]._creation_counter)\n        )\n\n        new_type = super(SchemaMetaclass, cls).__new__(  # type: ignore\n            cls, name, bases, attrs\n        )\n        if definitions is not None:\n            definitions[name] = new_type\n        return new_type\n\n\nclass Schema(Mapping, metaclass=SchemaMetaclass):\n    fields: typing.Dict[str, Field] = {}\n\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        if args:\n            assert len(args) == 1\n            assert not kwargs\n            item = args[0]\n            if isinstance(item, dict):\n                for key in self.fields.keys():\n                    if key in item:\n                        setattr(self, key, item[key])\n            else:\n                for key in self.fields.keys():\n                    if hasattr(item, key):\n                        setattr(self, key, getattr(item, key))\n            return\n\n        for key, schema in self.fields.items():\n            if key in kwargs:\n                value = kwargs.pop(key)\n                value, error = schema.validate_or_error(value)\n                if error:\n                    class_name = self.__class__.__name__\n                    error_text = \" \".join(\n                        [message.text for message in error.messages()]\n                    )\n                    message = (\n                        f\"Invalid argument {key!r} for {class_name}(). {error_text}\"\n                    )\n                    raise TypeError(message)\n                setattr(self, key, value)\n            elif schema.has_default():\n                setattr(self, key, schema.get_default_value())\n\n        if kwargs:\n            key = list(kwargs.keys())[0]\n            class_name = self.__class__.__name__\n            message = f\"{key!r} is an invalid keyword argument for {class_name}().\"\n            raise TypeError(message)\n\n    @classmethod\n    def make_validator(cls: typing.Type[\"Schema\"], *, strict: bool = False) -> Field:\n        required = [key for key, value in cls.fields.items() if not value.has_default()]\n        return Object(\n            properties=cls.fields,\n            required=required,\n            additional_properties=False if strict else None,\n        )\n\n    @classmethod\n    def validate(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> \"Schema\":\n        validator = cls.make_validator(strict=strict)\n        value = validator.validate(value, strict=strict)\n        return cls(value)\n\n    @classmethod\n    def validate_or_error(\n        cls: typing.Type[\"Schema\"], value: typing.Any, *, strict: bool = False\n    ) -> ValidationResult:\n        try:\n            value = cls.validate(value, strict=strict)\n        except ValidationError as error:\n            return ValidationResult(value=None, error=error)\n        return ValidationResult(value=value, error=None)\n\n    @property\n    def is_sparse(self) -> bool:\n        # A schema is sparsely populated if it does not include attributes\n        # for all its fields.\n        return bool([key for key in self.fields.keys() if not hasattr(self, key)])\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        for key in self.fields.keys():\n            if getattr(self, key) != getattr(other, key):\n                return False\n        return True\n\n    def __getitem__(self, key: typing.Any) -> typing.Any:\n        try:\n            field = self.fields[key]\n            value = getattr(self, key)\n        except (KeyError, AttributeError):\n            raise KeyError(key) from None\n        else:\n            return field.serialize(value)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        for key in self.fields:\n            if hasattr(self, key):\n                yield key\n\n    def __len__(self) -> int:\n        return len([key for key in self.fields if hasattr(self, key)])\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        arguments = {\n            key: getattr(self, key) for key in self.fields.keys() if hasattr(self, key)\n        }\n        argument_str = \", \".join(\n            [f\"{key}={value!r}\" for key, value in arguments.items()]\n        )\n        sparse_indicator = \" [sparse]\" if self.is_sparse else \"\"\n        return f\"{class_name}({argument_str}){sparse_indicator}\"\n\n\nclass Reference(Field):\n    errors = {\"null\": \"May not be null.\"}\n\n    def __init__(\n        self,\n        to: typing.Union[str, typing.Type[Schema]],\n        definitions: typing.Mapping = None,\n        **kwargs: typing.Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.to = to\n        self.definitions = definitions\n        if isinstance(to, str):\n            self._target_string = to\n        else:\n            assert issubclass(to, Schema)\n            self._target = to\n\n    @property\n    def target_string(self) -> str:\n        if not hasattr(self, \"_target_string\"):\n            self._target_string = self._target.__name__\n        return self._target_string\n\n    @property\n    def target(self) -> typing.Union[Field, typing.Type[Schema]]:\n        if not hasattr(self, \"_target\"):\n            assert (\n                self.definitions is not None\n            ), \"String reference missing 'definitions'.\"\n            self._target = self.definitions[self.to]\n        return self._target\n\n    def validate(self, value: typing.Any, *, strict: bool = False) -> typing.Any:\n        if value is None and self.allow_null:\n            return None\n        elif value is None:\n            raise self.validation_error(\"null\")\n        return self.target.validate(value, strict=strict)\n\n    def serialize(self, obj: typing.Any) -> typing.Any:\n        if obj is None:\n            return None\n        return dict(obj)\n\n# Unit test for function set_definitions\ndef test_set_definitions():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}