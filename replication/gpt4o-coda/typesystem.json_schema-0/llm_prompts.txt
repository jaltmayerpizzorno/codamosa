

---- 2024-06-04 19:57:36.417237
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n# Unit test for function type_from_json_schema\ndef test_type_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:57:40.165820
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n# Unit test for function one_of_from_json_schema\ndef test_one_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:57:45.699257
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:57:50.965016
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:57:55.193807
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:57:57.382063
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n# Unit test for function const_from_json_schema\ndef test_const_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:01.132596
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n# Unit test for function all_of_from_json_schema\ndef test_all_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:04.745441
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:07.796313
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:10.455293
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:43.043418
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n# Unit test for function one_of_from_json_schema\ndef test_one_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:45.546895
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:49.934226
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:53.219564
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:57.291343
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:58:59.971975
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:03.714298
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:06.849910
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:10.790872
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:13.580757
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n# Unit test for function from_json_schema\ndef test_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:45.083016
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n# Unit test for function one_of_from_json_schema\ndef test_one_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:48.074018
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:51.149731
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:54.915500
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 19:59:58.345741
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:00:01.123633
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:00:04.733656
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:00:09.506589
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:00:13.712499
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:00:16.749467
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n# Unit test for function from_json_schema\ndef test_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:00:55.973292
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:00:58.852354
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:02.036860
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:03.602473
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:06.149999
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:10.961420
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:14.299232
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:17.076818
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:19.689516
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:01:23.218956
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:02:36.814011
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:02:38.647256
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:02:41.896625
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n# Unit test for function type_from_json_schema\ndef test_type_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:02:52.955169
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:02:55.393123
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:02:57.718735
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n# Unit test for function one_of_from_json_schema\ndef test_one_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:02:59.808494
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:03:11.037187
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n# Unit test for function one_of_from_json_schema\ndef test_one_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:03:13.781693
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:03:17.468507
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:20.492544
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:24.592075
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:27.509724
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n# Unit test for function not_from_json_schema\ndef test_not_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:29.390317
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:32.176172
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n# Unit test for function ref_from_json_schema\ndef test_ref_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:34.395093
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n# Unit test for function from_json_schema_type\ndef test_from_json_schema_type():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:38.289625
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n# Unit test for function if_then_else_from_json_schema\ndef test_if_then_else_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:40.565108
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:46.169581
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nProvides 'typesystem.from_json_schema()' and 'typesystem.to_json_schema()'.\n\"\"\"\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n# Unit test for function any_of_from_json_schema\ndef test_any_of_from_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 20:05:49.521134
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n# Unit test for function to_json_schema\ndef test_to_json_schema():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}