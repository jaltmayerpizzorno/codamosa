

---- 2024-05-31 21:10:40.241312
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:10:43.817757
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:10:47.612958
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:10:51.254436
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:10:55.523366
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:10:59.516617
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:04.404030
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:07.725280
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:12.367719
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:16.731300
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:28.571154
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:32.844740
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:36.750676
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:39.862677
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:43.838161
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:48.514684
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:52.436120
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:11:58.001956
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:05.076289
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:08.149843
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:25.570226
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:29.443100
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:33.269371
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:40.946714
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:45.015979
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:48.520457
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:52.291417
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:12:56.576457
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:00.052965
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:03.254452
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:19.276592
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:22.196811
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:26.405266
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:30.896546
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:34.373922
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:38.147397
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:41.492834
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:47.289179
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:51.878376
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:13:55.556042
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:23.358064
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:26.548438
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:30.417424
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:34.402220
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:38.355502
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:41.593923
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:45.237089
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:48.383163
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:53.576366
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:14:58.096285
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:25.946438
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:29.031580
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:32.548286
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:41.864520
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:45.585774
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:52.328675
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:55.826134
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:15:58.959903
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:16:03.120056
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:16:08.659532
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:07.900449
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:12.017325
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:15.373754
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:18.682523
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:21.955105
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:25.493910
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:28.817568
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:34.018967
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:37.416331
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:18:42.904049
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:19:29.268655
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:19:32.265466
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:19:42.609964
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:19:46.851553
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:19:51.589846
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method preprocess_data of class PlaybookInclude\ndef test_PlaybookInclude_preprocess_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:20:06.309220
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:20:10.198831
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:20:14.244303
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:20:17.862573
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-05-31 21:20:21.170498
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\n\nimport ansible.constants as C\nfrom ansible.errors import AnsibleParserError, AnsibleAssertionError\nfrom ansible.module_utils._text import to_bytes\nfrom ansible.module_utils.six import iteritems, string_types\nfrom ansible.parsing.splitter import split_args, parse_kv\nfrom ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping\nfrom ansible.playbook.attribute import FieldAttribute\nfrom ansible.playbook.base import Base\nfrom ansible.playbook.conditional import Conditional\nfrom ansible.playbook.taggable import Taggable\nfrom ansible.utils.collection_loader import AnsibleCollectionConfig\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_name_from_path, _get_collection_playbook_path\nfrom ansible.template import Templar\nfrom ansible.utils.display import Display\n\ndisplay = Display()\n\n\nclass PlaybookInclude(Base, Conditional, Taggable):\n\n    _import_playbook = FieldAttribute(isa='string')\n    _vars = FieldAttribute(isa='dict', default=dict)\n\n    @staticmethod\n    def load(data, basedir, variable_manager=None, loader=None):\n        return PlaybookInclude().load_data(ds=data, basedir=basedir, variable_manager=variable_manager, loader=loader)\n\n    def load_data(self, ds, basedir, variable_manager=None, loader=None):\n        '''\n        Overrides the base load_data(), as we're actually going to return a new\n        Playbook() object rather than a PlaybookInclude object\n        '''\n\n        # import here to avoid a dependency loop\n        from ansible.playbook import Playbook\n        from ansible.playbook.play import Play\n\n        # first, we use the original parent method to correctly load the object\n        # via the load_data/preprocess_data system we normally use for other\n        # playbook objects\n        new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)\n\n        all_vars = self.vars.copy()\n        if variable_manager:\n            all_vars.update(variable_manager.get_vars())\n\n        templar = Templar(loader=loader, variables=all_vars)\n\n        # then we use the object to load a Playbook\n        pb = Playbook(loader=loader)\n\n        file_name = templar.template(new_obj.import_playbook)\n\n        # check for FQCN\n        resource = _get_collection_playbook_path(file_name)\n        if resource is not None:\n            playbook = resource[1]\n            playbook_collection = resource[2]\n        else:\n            # not FQCN try path\n            playbook = file_name\n            if not os.path.isabs(playbook):\n                playbook = os.path.join(basedir, playbook)\n\n            # might still be collection playbook\n            playbook_collection = _get_collection_name_from_path(playbook)\n\n        if playbook_collection:\n            # it is a collection playbook, setup default collections\n            AnsibleCollectionConfig.default_collection = playbook_collection\n        else:\n            # it is NOT a collection playbook, setup adjecent paths\n            AnsibleCollectionConfig.playbook_paths.append(os.path.dirname(os.path.abspath(to_bytes(playbook, errors='surrogate_or_strict'))))\n\n        pb._load_playbook_data(file_name=playbook, variable_manager=variable_manager, vars=self.vars.copy())\n\n        # finally, update each loaded playbook entry with any variables specified\n        # on the included playbook and/or any tags which may have been set\n        for entry in pb._entries:\n\n            # conditional includes on a playbook need a marker to skip gathering\n            if new_obj.when and isinstance(entry, Play):\n                entry._included_conditional = new_obj.when[:]\n\n            temp_vars = entry.vars.copy()\n            temp_vars.update(new_obj.vars)\n            param_tags = temp_vars.pop('tags', None)\n            if param_tags is not None:\n                entry.tags.extend(param_tags.split(','))\n            entry.vars = temp_vars\n            entry.tags = list(set(entry.tags).union(new_obj.tags))\n            if entry._included_path is None:\n                entry._included_path = os.path.dirname(playbook)\n\n            # Check to see if we need to forward the conditionals on to the included\n            # plays. If so, we can take a shortcut here and simply prepend them to\n            # those attached to each block (if any)\n            if new_obj.when:\n                for task_block in (entry.pre_tasks + entry.roles + entry.tasks + entry.post_tasks):\n                    task_block._attributes['when'] = new_obj.when[:] + task_block.when[:]\n\n        return pb\n\n    def preprocess_data(self, ds):\n        '''\n        Regorganizes the data for a PlaybookInclude datastructure to line\n        up with what we expect the proper attributes to be\n        '''\n\n        if not isinstance(ds, dict):\n            raise AnsibleAssertionError('ds (%s) should be a dict but was a %s' % (ds, type(ds)))\n\n        # the new, cleaned datastructure, which will have legacy\n        # items reduced to a standard structure\n        new_ds = AnsibleMapping()\n        if isinstance(ds, AnsibleBaseYAMLObject):\n            new_ds.ansible_pos = ds.ansible_pos\n\n        for (k, v) in iteritems(ds):\n            if k in C._ACTION_IMPORT_PLAYBOOK:\n                self._preprocess_import(ds, new_ds, k, v)\n            else:\n                # some basic error checking, to make sure vars are properly\n                # formatted and do not conflict with k=v parameters\n                if k == 'vars':\n                    if 'vars' in new_ds:\n                        raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                    elif not isinstance(v, dict):\n                        raise AnsibleParserError(\"vars for import_playbook statements must be specified as a dictionary\", obj=ds)\n                new_ds[k] = v\n\n        return super(PlaybookInclude, self).preprocess_data(new_ds)\n\n    def _preprocess_import(self, ds, new_ds, k, v):\n        '''\n        Splits the playbook import line up into filename and parameters\n        '''\n\n        if v is None:\n            raise AnsibleParserError(\"playbook import parameter is missing\", obj=ds)\n        elif not isinstance(v, string_types):\n            raise AnsibleParserError(\"playbook import parameter must be a string indicating a file path, got %s instead\" % type(v), obj=ds)\n\n        # The import_playbook line must include at least one item, which is the filename\n        # to import. Anything after that should be regarded as a parameter to the import\n        items = split_args(v)\n        if len(items) == 0:\n            raise AnsibleParserError(\"import_playbook statements must specify the file name to import\", obj=ds)\n        else:\n            new_ds['import_playbook'] = items[0].strip()\n            if len(items) > 1:\n                display.deprecated(\"Additional parameters in import_playbook statements are deprecated. \"\n                                   \"Use 'vars' instead. See 'import_playbook' documentation for examples.\", version='2.14')\n                # rejoin the parameter portion of the arguments and\n                # then use parse_kv() to get a dict of params back\n                params = parse_kv(\" \".join(items[1:]))\n                if 'tags' in params:\n                    new_ds['tags'] = params.pop('tags')\n                if 'vars' in new_ds:\n                    raise AnsibleParserError(\"import_playbook parameters cannot be mixed with 'vars' entries for import statements\", obj=ds)\n                new_ds['vars'] = params\n\n# Unit test for method load_data of class PlaybookInclude\ndef test_PlaybookInclude_load_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}