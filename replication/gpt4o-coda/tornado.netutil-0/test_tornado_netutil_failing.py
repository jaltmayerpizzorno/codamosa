# Automatically generated by Pynguin.
import tornado.netutil as module_0
import socket as module_1
import ssl as module_2

def test_case_0():
    try:
        int_0 = 416
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_1():
    try:
        resolver_0 = module_0.Resolver()
        str_0 = 'nt'
        int_0 = -935
        socket_0 = module_0.bind_unix_socket(str_0, int_0, int_0)
        str_1 = 'finally'
        callable_0 = module_0.add_accept_handler(socket_0, str_1)
    except BaseException:
        pass

def test_case_2():
    try:
        override_resolver_0 = module_0.OverrideResolver()
    except BaseException:
        pass

def test_case_3():
    try:
        bool_0 = True
        str_0 = '6~ms~W$IZQ8#s&'
        int_0 = -299
        address_family_0 = module_1.AddressFamily.AF_NETROM
        resolver_0 = module_0.Resolver()
        awaitable_0 = resolver_0.resolve(str_0, int_0, address_family_0)
        list_0 = [bool_0]
        set_0 = set()
        list_1 = [list_0, set_0]
        str_1 = '%L?vAi7KwbM|SmTnTtt/'
        str_2 = 'Indonesian'
        dict_0 = {str_1: str_1, str_2: str_2}
        resolver_1 = module_0.Resolver()
        resolver_1.close()
        resolver_2 = module_0.Resolver(*list_1, **dict_0)
    except BaseException:
        pass

def test_case_4():
    try:
        resolver_0 = module_0.Resolver()
        int_0 = 353
        resolver_0.close()
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_5():
    try:
        blocking_resolver_0 = module_0.BlockingResolver()
    except BaseException:
        pass

def test_case_6():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_7():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = ')]M4V'
        int_0 = None
        default_executor_resolver_0 = module_0.DefaultExecutorResolver()
        list_0 = default_executor_resolver_0.resolve(str_0, int_0)
        int_1 = 525
        dict_0 = {str_0: str_0, str_0: int_1}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_9():
    try:
        int_0 = 612
        bool_0 = False
        str_0 = 'module'
        list_0 = module_0.bind_sockets(int_0, str_0, int_0, int_0, bool_0)
    except BaseException:
        pass

def test_case_10():
    try:
        resolver_0 = module_0.Resolver()
        s_s_l_context_0 = None
        resolver_0.close()
        s_s_l_context_1 = module_0.ssl_options_to_context(s_s_l_context_0)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = None
        socket_0 = module_0.bind_unix_socket(str_0)
    except BaseException:
        pass

def test_case_12():
    try:
        int_0 = 2079
        str_0 = '3'
        list_0 = module_0.bind_sockets(int_0, str_0)
    except BaseException:
        pass

def test_case_13():
    try:
        resolver_0 = module_0.Resolver()
        str_0 = 'UP~}8l5%a'
        int_0 = -1593
        socket_0 = module_0.bind_unix_socket(str_0, int_0)
        str_1 = '.e+ \nnocg${'
        bool_0 = module_0.is_valid_ip(str_1)
    except BaseException:
        pass

def test_case_14():
    try:
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        str_0 = '&\n%pS_~p~>'
        int_0 = 2072
        str_1 = ''
        list_0 = module_0.bind_sockets(int_0, str_1)
        list_1 = [list_0, str_0, dict_0, list_0]
        s_s_l_context_1 = module_2.SSLContext(*list_1)
    except BaseException:
        pass

def test_case_15():
    try:
        dict_0 = {}
        str_0 = 'Set the internal flag to ``True``. All waiters are awakened.\n\n       Calling `.wait` once the flag is set will not block.\n       '
        int_0 = -2371
        address_family_0 = module_1.AddressFamily.AF_TIPC
        list_0 = [dict_0, dict_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        awaitable_0 = override_resolver_0.resolve(str_0, int_0, address_family_0)
    except BaseException:
        pass

def test_case_16():
    try:
        bool_0 = True
        resolver_0 = module_0.Resolver()
        str_0 = 'UP~}8l5%a'
        int_0 = -1593
        socket_0 = module_0.bind_unix_socket(str_0, int_0)
        list_0 = [int_0, bool_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        override_resolver_0.close()
    except BaseException:
        pass

def test_case_17():
    try:
        resolver_0 = module_0.Resolver()
        resolver_0.close()
        int_0 = -2682
        address_family_0 = module_1.AddressFamily.AF_NETROM
        dict_0 = {resolver_0: resolver_0, resolver_0: resolver_0, resolver_0: resolver_0}
        dict_1 = {}
        list_0 = [resolver_0, resolver_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        override_resolver_0.initialize(resolver_0, dict_0)
        dict_2 = {}
        str_0 = 'Utility classes to write to and read from non-blocking files and sockets.\n\nContents:\n\n* `BaseIOStream`: Generic interface for reading and writing.\n* `IOStream`: Implementation of BaseIOStream using non-blocking sockets.\n* `SSLIOStream`: SSL-aware version of IOStream.\n* `PipeIOStream`: Pipe-based IOStream implementation.\n'
        awaitable_0 = override_resolver_0.resolve(str_0, int_0)
        str_1 = 'tF\x0b=_>'
        int_1 = 4549
        socket_0 = module_0.bind_unix_socket(str_1, int_1)
        str_2 = 'wsgi.multithread'
        awaitable_1 = resolver_0.resolve(str_2, int_1)
        s_s_l_socket_0 = module_0.ssl_wrap_socket(socket_0, dict_1)
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_2)
        bool_0 = True
        list_1 = module_0.bind_sockets(int_0, str_1, address_family_0, int_0, int_0, bool_0)
    except BaseException:
        pass

def test_case_18():
    try:
        str_0 = '/'
        socket_0 = module_0.bind_unix_socket(str_0)
    except BaseException:
        pass