

---- 2024-06-02 18:42:32.147011
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:33.335177
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:34.411117
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:35.298829
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:36.580873
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:37.474571
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:38.431008
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:39.454131
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:40.397351
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:42:41.190553
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:02.429241
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:03.228350
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:04.345959
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:05.206219
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:06.873183
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:07.858858
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:08.740161
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:09.579363
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:10.388664
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:11.227704
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:32.704609
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:33.623126
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:34.513617
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:35.310660
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:36.156883
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:37.030255
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:37.949820
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:38.753371
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:39.631532
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:43:40.526076
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:23.050115
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:23.947264
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:24.747586
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:25.543695
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:26.502227
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:27.328053
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:28.325717
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:29.849652
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:30.652394
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:44:31.491697
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:45:53.535348
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:45:54.485669
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:45:55.319168
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:45:56.126085
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:45:57.179053
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:45:58.436202
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:45:59.780752
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:46:00.765491
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:46:01.675357
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:46:02.552076
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:51.581875
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:52.880645
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:53.789137
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:54.848283
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:55.929023
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:56.919382
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:58.830909
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:48:59.866260
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:49:00.804276
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-02 18:49:01.867865
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n# -*- coding: utf-8 -*-\n\n\"\"\"Address module.\n\nThis module contains provider Address() and other utils which represents\ndata related to location, such as street name, city, country and etc.\n\"\"\"\n\nfrom typing import Optional, Union\n\nfrom mimesis.data import (\n    CALLING_CODES,\n    CONTINENT_CODES,\n    COUNTRY_CODES,\n    SHORTENED_ADDRESS_FMT,\n)\nfrom mimesis.enums import CountryCode\nfrom mimesis.providers.base import BaseDataProvider\n\n__all__ = ['Address']\n\n\nclass Address(BaseDataProvider):\n    \"\"\"Class for generate fake address data.\n\n    This object provides all the data related to\n    geographical location.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize attributes.\n\n        :param locale: Current locale.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._datafile = 'address.json'\n        self._pull(self._datafile)\n\n    class Meta:\n        \"\"\"Class for metadata.\"\"\"\n\n        name = 'address'\n\n    @staticmethod\n    def _dd_to_dms(num: float, _type: str) -> str:\n        \"\"\"Convert decimal number to DMS format.\n\n        :param num: Decimal number.\n        :param _type: Type of number.\n        :return: Number in DMS format.\n        \"\"\"\n        degrees = int(num)\n        minutes = int((num - degrees) * 60)\n        seconds = (num - degrees - minutes / 60) * 3600.00\n        seconds = round(seconds, 3)\n        result = [abs(i) for i in (degrees, minutes, seconds)]\n\n        direction = ''\n        if _type == 'lg':\n            direction = 'W' if degrees < 0 else 'E'\n        elif _type == 'lt':\n            direction = 'S' if degrees < 0 else 'N'\n\n        return ('{}\u00ba{}\\'{:.3f}\"' + direction).format(*result)\n\n    def street_number(self, maximum: int = 1400) -> str:\n        \"\"\"Generate a random street number.\n\n        :param maximum: Maximum value.\n        :return: Street number.\n        \"\"\"\n        return str(self.random.randint(1, maximum))\n\n    def street_name(self) -> str:\n        \"\"\"Get a random street name.\n\n        :return: Street name.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['name'])\n\n    def street_suffix(self) -> str:\n        \"\"\"Get a random street suffix.\n\n        :return: Street suffix.\n        \"\"\"\n        return self.random.choice(\n            self._data['street']['suffix'])\n\n    def address(self) -> str:\n        \"\"\"Generate a random full address.\n\n        :return: Full address.\n        \"\"\"\n        fmt = self._data['address_fmt']\n\n        st_num = self.street_number()\n        st_name = self.street_name()\n\n        if self.locale in SHORTENED_ADDRESS_FMT:\n            return fmt.format(\n                st_num=st_num,\n                st_name=st_name,\n            )\n\n        if self.locale == 'ja':\n            return fmt.format(\n                self.random.choice(self._data['city']),\n                # Generate list of random integers\n                # in amount of 3, from 1 to 100.\n                *self.random.randints(amount=3, a=1, b=100),\n            )\n\n        return fmt.format(\n            st_num=st_num,\n            st_name=st_name,\n            st_sfx=self.street_suffix(),\n\n        )\n\n    def state(self, abbr: bool = False) -> str:\n        \"\"\"Get a random administrative district of country.\n\n        :param abbr: Return ISO 3166-2 code.\n        :return: Administrative district.\n        \"\"\"\n        return self.random.choice(\n            self._data['state']['abbr' if abbr else 'name'])\n\n    def region(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def province(self, *args, **kwargs) -> str:\n        \"\"\"Get a random province.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def federal_subject(self, *args, **kwargs) -> str:\n        \"\"\"Get a random region.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def prefecture(self, *args, **kwargs) -> str:\n        \"\"\"Get a random prefecture.\n\n        An alias for :meth:`~Address.state()`.\n        \"\"\"\n        return self.state(*args, **kwargs)\n\n    def postal_code(self) -> str:\n        \"\"\"Generate a postal code for current locale.\n\n        :return: Postal code.\n        \"\"\"\n        return self.random.custom_code(\n            self._data['postal_code_fmt'])\n\n    def zip_code(self) -> str:\n        \"\"\"Generate a zip code.\n\n        An alias for :meth:`~Address.postal_code()`.\n\n        :return: Zip code.\n        \"\"\"\n        return self.postal_code()\n\n    def country_code(self, fmt: Optional[CountryCode] = CountryCode.A2) -> str:\n        \"\"\"Get a random code of country.\n\n        Default format is :attr:`~enums.CountryCode.A2` (ISO 3166-1-alpha2),\n        you can change it by passing parameter ``fmt`` with enum object\n        :class:`~enums.CountryCode`.\n\n        :param fmt: Enum object CountryCode.\n        :return: Country code in selected format.\n        :raises KeyError: if fmt is not supported.\n        \"\"\"\n        key = self._validate_enum(fmt, CountryCode)\n        return self.random.choice(COUNTRY_CODES[key])\n\n    def country(self, allow_random: bool = False) -> str:\n        \"\"\"Get the country of the current locale.\n\n        :allow_random: Return a random country name.\n        :return: The Country.\n        \"\"\"\n        if allow_random:\n            return self.random.choice(self._data['country']['name'])\n\n        return self._data['country']['current_locale']\n\n    def city(self) -> str:\n        \"\"\"Get a random city.\n\n        :return: City name.\n        \"\"\"\n        return self.random.choice(\n            self._data['city'])\n\n    def _get_fs(self, key: str, dms: bool = False) -> Union[str, float]:\n        \"\"\"Get float number.\n\n        :param key: Key (`lt` or `lg`).\n        :param dms: DMS format.\n        :return: Float number\n        \"\"\"\n        # Default range is a range of longitude.\n        rng = (-90, 90) if key == 'lt' else (-180, 180)\n        result = self.random.uniform(*rng, precision=6)\n\n        if dms:\n            return self._dd_to_dms(result, key)\n\n        return result\n\n    def latitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of latitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lt', dms)\n\n    def longitude(self, dms: bool = False) -> Union[str, float]:\n        \"\"\"Generate a random value of longitude.\n\n        :param dms: DMS format.\n        :return: Value of longitude.\n        \"\"\"\n        return self._get_fs('lg', dms)\n\n    def coordinates(self, dms: bool = False) -> dict:\n        \"\"\"Generate random geo coordinates.\n\n        :param dms: DMS format.\n        :return: Dict with coordinates.\n        \"\"\"\n        return {\n            'longitude': self._get_fs('lg', dms),\n            'latitude': self._get_fs('lt', dms),\n        }\n\n    def continent(self, code: bool = False) -> str:\n        \"\"\"Get a random continent name or continent code.\n\n        :param code: Return code of continent.\n        :return: Continent name.\n        \"\"\"\n        codes = CONTINENT_CODES if \\\n            code else self._data['continent']\n\n        return self.random.choice(codes)\n\n    def calling_code(self) -> str:\n        \"\"\"Get a random calling code of random country.\n\n        :return: Calling code.\n        \"\"\"\n        return self.random.choice(CALLING_CODES)\n\n# Unit test for method address of class Address\ndef test_Address_address():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}