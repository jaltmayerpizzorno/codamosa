

---- 2024-06-04 22:06:54.015047
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:06:57.443943
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:01.074722
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:05.037566
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:06.492495
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:09.716446
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:11.698927
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:14.857813
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:19.638431
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:23.371731
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n# Unit test for function extract_box_data\ndef test_extract_box_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:40.396945
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:41.583461
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:45.725199
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:46.814272
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:50.357465
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:53.399294
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:56.743134
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:07:57.644171
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:01.735331
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:02.648497
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:27.167905
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:31.068035
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:34.991425
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:38.038596
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:41.744610
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:42.784179
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n# Unit test for function extract_box_data\ndef test_extract_box_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:46.495447
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:50.109398
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:53.075047
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:08:54.001107
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:09:36.426541
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:09:39.428809
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:09:42.891422
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:09:48.254998
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:09:51.619391
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:09:54.847939
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:10:00.466034
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:10:01.328577
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:10:06.816685
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:10:09.806471
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n# Unit test for function extract_box_data\ndef test_extract_box_data():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:10:55.348260
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:10:56.268480
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:10:59.717409
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:11:03.382033
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:11:06.493293
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:11:09.718200
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:11:12.833863
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:11:16.279815
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:11:19.607219
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:11:21.535265
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:12:58.221079
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:12:59.397379
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:00.463121
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:04.368241
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:07.832432
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:08.596652
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:13.525243
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:14.476798
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n# Unit test for constructor of class IsmFD\ndef test_IsmFD():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:15.690069
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:13:18.783371
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n\n\ndef extract_box_data(data, box_sequence):\n    data_reader = io.BytesIO(data)\n    while True:\n        box_size = u32.unpack(data_reader.read(4))[0]\n        box_type = data_reader.read(4)\n        if box_type == box_sequence[0]:\n            box_data = data_reader.read(box_size - 8)\n            if len(box_sequence) == 1:\n                return box_data\n            return extract_box_data(box_data, box_sequence[1:])\n        data_reader.seek(box_size - 8, 1)\n\n\nclass IsmFD(FragmentFD):\n    \"\"\"\n    Download segments in a ISM manifest\n    \"\"\"\n\n    FD_NAME = 'ism'\n\n    def real_download(self, filename, info_dict):\n        segments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(segments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        track_written = False\n        frag_index = 0\n        for i, segment in enumerate(segments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)\n                    if not success:\n                        return False\n                    if not track_written:\n                        tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])\n                        info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]\n                        write_piff_header(ctx['dest_stream'], info_dict['_download_params'])\n                        track_written = True\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if skip_unavailable_fragments:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n# Unit test for method real_download of class IsmFD\ndef test_IsmFD_real_download():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:16:31.599022
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-04 22:16:40.438660
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\nfrom __future__ import unicode_literals\n\nimport time\nimport binascii\nimport io\n\nfrom .fragment import FragmentFD\nfrom ..compat import (\n    compat_Struct,\n    compat_urllib_error,\n)\n\n\nu8 = compat_Struct('>B')\nu88 = compat_Struct('>Bx')\nu16 = compat_Struct('>H')\nu1616 = compat_Struct('>Hxx')\nu32 = compat_Struct('>I')\nu64 = compat_Struct('>Q')\n\ns88 = compat_Struct('>bx')\ns16 = compat_Struct('>h')\ns1616 = compat_Struct('>hxx')\ns32 = compat_Struct('>i')\n\nunity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)\n\nTRACK_ENABLED = 0x1\nTRACK_IN_MOVIE = 0x2\nTRACK_IN_PREVIEW = 0x4\n\nSELF_CONTAINED = 0x1\n\n\ndef box(box_type, payload):\n    return u32.pack(8 + len(payload)) + box_type + payload\n\n\ndef full_box(box_type, version, flags, payload):\n    return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)\n\n\ndef write_piff_header(stream, params):\n    track_id = params['track_id']\n    fourcc = params['fourcc']\n    duration = params['duration']\n    timescale = params.get('timescale', 10000000)\n    language = params.get('language', 'und')\n    height = params.get('height', 0)\n    width = params.get('width', 0)\n    is_audio = width == 0 and height == 0\n    creation_time = modification_time = int(time.time())\n\n    ftyp_payload = b'isml'  # major brand\n    ftyp_payload += u32.pack(1)  # minor version\n    ftyp_payload += b'piff' + b'iso2'  # compatible brands\n    stream.write(box(b'ftyp', ftyp_payload))  # File Type Box\n\n    mvhd_payload = u64.pack(creation_time)\n    mvhd_payload += u64.pack(modification_time)\n    mvhd_payload += u32.pack(timescale)\n    mvhd_payload += u64.pack(duration)\n    mvhd_payload += s1616.pack(1)  # rate\n    mvhd_payload += s88.pack(1)  # volume\n    mvhd_payload += u16.pack(0)  # reserved\n    mvhd_payload += u32.pack(0) * 2  # reserved\n    mvhd_payload += unity_matrix\n    mvhd_payload += u32.pack(0) * 6  # pre defined\n    mvhd_payload += u32.pack(0xffffffff)  # next track id\n    moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box\n\n    tkhd_payload = u64.pack(creation_time)\n    tkhd_payload += u64.pack(modification_time)\n    tkhd_payload += u32.pack(track_id)  # track id\n    tkhd_payload += u32.pack(0)  # reserved\n    tkhd_payload += u64.pack(duration)\n    tkhd_payload += u32.pack(0) * 2  # reserved\n    tkhd_payload += s16.pack(0)  # layer\n    tkhd_payload += s16.pack(0)  # alternate group\n    tkhd_payload += s88.pack(1 if is_audio else 0)  # volume\n    tkhd_payload += u16.pack(0)  # reserved\n    tkhd_payload += unity_matrix\n    tkhd_payload += u1616.pack(width)\n    tkhd_payload += u1616.pack(height)\n    trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box\n\n    mdhd_payload = u64.pack(creation_time)\n    mdhd_payload += u64.pack(modification_time)\n    mdhd_payload += u32.pack(timescale)\n    mdhd_payload += u64.pack(duration)\n    mdhd_payload += u16.pack(((ord(language[0]) - 0x60) << 10) | ((ord(language[1]) - 0x60) << 5) | (ord(language[2]) - 0x60))\n    mdhd_payload += u16.pack(0)  # pre defined\n    mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box\n\n    hdlr_payload = u32.pack(0)  # pre defined\n    hdlr_payload += b'soun' if is_audio else b'vide'  # handler type\n    hdlr_payload += u32.pack(0) * 3  # reserved\n    hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\\0'  # name\n    mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box\n\n    if is_audio:\n        smhd_payload = s88.pack(0)  # balance\n        smhd_payload += u16.pack(0)  # reserved\n        media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header\n    else:\n        vmhd_payload = u16.pack(0)  # graphics mode\n        vmhd_payload += u16.pack(0) * 3  # opcolor\n        media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header\n    minf_payload = media_header_box\n\n    dref_payload = u32.pack(1)  # entry count\n    dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box\n    dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box\n    minf_payload += box(b'dinf', dinf_payload)  # Data Information Box\n\n    stsd_payload = u32.pack(1)  # entry count\n\n    sample_entry_payload = u8.pack(0) * 6  # reserved\n    sample_entry_payload += u16.pack(1)  # data reference index\n    if is_audio:\n        sample_entry_payload += u32.pack(0) * 2  # reserved\n        sample_entry_payload += u16.pack(params.get('channels', 2))\n        sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u1616.pack(params['sampling_rate'])\n\n        if fourcc == 'AACL':\n            sample_entry_box = box(b'mp4a', sample_entry_payload)\n    else:\n        sample_entry_payload += u16.pack(0)  # pre defined\n        sample_entry_payload += u16.pack(0)  # reserved\n        sample_entry_payload += u32.pack(0) * 3  # pre defined\n        sample_entry_payload += u16.pack(width)\n        sample_entry_payload += u16.pack(height)\n        sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi\n        sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi\n        sample_entry_payload += u32.pack(0)  # reserved\n        sample_entry_payload += u16.pack(1)  # frame count\n        sample_entry_payload += u8.pack(0) * 32  # compressor name\n        sample_entry_payload += u16.pack(0x18)  # depth\n        sample_entry_payload += s16.pack(-1)  # pre defined\n\n        codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))\n        if fourcc in ('H264', 'AVC1'):\n            sps, pps = codec_private_data.split(u32.pack(1))[1:]\n            avcc_payload = u8.pack(1)  # configuration version\n            avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication\n            avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one\n            avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)\n            avcc_payload += u16.pack(len(sps))\n            avcc_payload += sps\n            avcc_payload += u8.pack(1)  # number of pps\n            avcc_payload += u16.pack(len(pps))\n            avcc_payload += pps\n            sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record\n            sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry\n    stsd_payload += sample_entry_box\n\n    stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box\n\n    stts_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box\n\n    stsc_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box\n\n    stco_payload = u32.pack(0)  # entry count\n    stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box\n\n    minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box\n\n    mdia_payload += box(b'minf', minf_payload)  # Media Information Box\n\n    trak_payload += box(b'mdia', mdia_payload)  # Media Box\n\n    moov_payload += box(b'trak', trak_payload)  # Track Box\n\n    mehd_payload = u64.pack(duration)\n    mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box\n\n    trex_payload = u32.pack(track_id)  # track id\n    trex_payload += u32.pack(1)  # default sample description index\n    trex_payload += u32.pack(0)  # default sample duration\n    trex_payload += u32.pack(0)  # default sample size\n    trex_payload += u32.pack(0)  # default sample flags\n    mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box\n\n    moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box\n    stream.write(box(b'moov', moov_payload))  # Movie Box\n# Unit test for function write_piff_header\ndef test_write_piff_header():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}